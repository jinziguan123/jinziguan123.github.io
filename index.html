<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="琐碎和思考的堆放处">
<meta property="og:type" content="website">
<meta property="og:title" content="CigaCase">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="CigaCase">
<meta property="og:description" content="琐碎和思考的堆放处">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="愚者大人的铁质卷烟盒">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CigaCase</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CigaCase</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/18/%E6%AE%8B%E5%8F%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/18/%E6%AE%8B%E5%8F%B6/" class="post-title-link" itemprop="url">残叶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-18 22:15:40" itemprop="dateCreated datePublished" datetime="2025-01-18T22:15:40+08:00">2025-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-28 16:53:47" itemprop="dateModified" datetime="2025-01-28T16:53:47+08:00">2025-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>八九十年代的上海有一种说不清道不明的魅力，改革开放的风刚吹起不久，在这片临海的土地上与旧时代的海派文化一拍即合，复古和新潮这两个截然相反的名字毅然不计前嫌地将根茎缠绕、扎根，汲取着黄浦江的养分开始野蛮生长。水一灌，褪去隐忍的种子发了芽；风一吹，野草拨开泥土发疯似的向无穷远处的天空攀登。</p>
<p>当然，我的父亲并没有加入这片野草的队伍。在89年前后，出于某些原因，刚拿到了高中毕业证的他放弃了求学的道路，转而去日本另谋机会。时至今日当他追忆往昔，这个决策总会以其他参赛选手望尘莫及的水平，在他的“错误选择排行榜”高居榜首，其程度之深，甚至可以将日后的大部分失败挫折归咎于此；尽管后悔，不可否认的是那时的他尚且被幸运女神眷顾，乘上了日本经济增长的最后一个高峰，挣了一笔不小的钱，其数量之多，甚至足以为他日后的大部分失败挫折兜底。</p>
<p>相比起父亲，母亲更符合当时人们对于一位青年的评价标准：老实本份地念完义务教育，进入一家规模不小的国企工作，每天朝九晚五工作稳定。尽管挣得不算多，但所幸工作与她的爱好一致，舞蹈出身的她甚至有时间在下班之后私底下接一些串场演出的活，用现在的话来说就是把自己养的很好。</p>
<p>90年代初，刚回国的父亲遇到了母亲，带着自由回归的人遇到了生性向往自由的人，爱情的火花一触即发。他们曾经是坚定的丁克族，在八九十年代的中国，的确算是个十分新潮的思想。虽然不知道他们有没有和家里人谈过这个问题，但既然今天你能够看到我的这段絮叨的文字，至少说明丁克族前面的修饰词需要加一个双引号。此外，时至今日我能够从他们回忆往昔的只言片语中隐约摸索出来：这两个人的丁克思想其实很大程度建立在年轻贪玩的基础上，一个刚刚出生的婴儿无疑是这个基础最有力的破坏者。</p>
<p>他们结婚后不久，母亲从工作单位分到了一套房，就在周家嘴路通北路口的宝钢又一村，于是这里就成了我童年时期不可或缺的一方小天地。推开曾经那处住所的房门，最为吸引人的莫过于采光极好的客厅、柔软的沙发以及略显老气的酒柜，午后的阳光偶尔会从朝南开的窗户闯入，映出些许空中的浮尘。连同牵着金龟子的绳子、打在木质地板上的玩具的影子、被茶几磕破的膝盖以及自己的抽泣声一道投影在记忆的剧场里。不过在我印象中最俱存在感的莫过于左手边略显逼仄的衣帽间，我在以前写过一篇名为《自我剖析报告》的小作文里面提到过，进入小学之前是外公外婆照顾的我，呆在市光二村的时间远比呆在自己家的时间长久；再加上我很害怕当时的父亲，一套“怕屋及乌”的组合拳下来，难免对老房子本身也蒙上了一层灰色的滤镜。每当我犯下什么错，这个衣帽间就成了关押我反省的囹圄，又几乎每一次我哭个精疲力尽之后，都会在四周衣服味道的裹挟下昏昏睡去。对于幼年的我来说，这个小小的借不到光的空间是悲伤的牢笼，也是黑暗中给予我抚慰的摇篮，即使在稍微大一点之后，父母不再用关小房间的方式来惩罚我的淘气，我也会不时抱着自己的玩具躲进去玩上一下午。</p>
<p>我不懂车，对车也没有太大的兴趣——对内燃机的了解仅仅停留在初高中的物理知识；很多耳熟能详的牌子我都分辨不清；即使大三勉强考出了驾照，至今也没有上路开过。人有路痴、音痴，这样的说法借鉴到我身上，或许可以称呼我为车痴。这样的车痴却对桑塔纳情有独钟，只是因为曾几何时，家里也有过一台黑白相间的桑塔纳。印象里这辆车总是被随意得停在路边，一副唾手可得的样子（可能宝钢又一村压根儿就没有地下停车场），一家三口出门的时候我总是跟着母亲下楼，走过小区的一个拐角就能够看到那辆桑塔纳，车里坐着先一步出门暖车的父亲。在他们的罗曼史和回忆录中，这辆车的出场率总是高得离谱：今天嘴巴馋了，遂驱车到阳澄湖买两个大闸蟹带回来吃；明天客人要回老家了，索性开着车送他一程，顺便还能路上吃吃喝喝兜兜风……诸如此类。再后来，不知是因为这辆车该寿终正寝了，也不知是家里经济的缘故，黑白桑塔纳从我的世界里消失了，尽管我对此的记忆已经模糊，尽管我对桑塔纳的喜爱远超其他的燃油车。于是我无数次路过小区的那个拐角，再也没见到安静地等待着一家三口的忠实仆人，发动机的轰鸣声从我尚未出生的时光里驶向我的身边，又带着同样的轰鸣声朝着不知去向的无穷远处奔袭。</p>
<p>小学四年级的时候，我们卖掉了这间房。那天晚上我躺在床上听着父母在客厅里的窃窃私语，我不知道发生了什么，只是隐约认为他们聊的并不是什么值得高兴的事情。朦胧之中母亲悄悄推开门来到床边，我感受着额头被轻抚的温柔，耳边传来略带哭腔的声音：“要是我们从这个家搬走了，你会怎么想？”人在脑子乱作一团的时候是没有办法思考这种问题的，在大脑控制嘴唇做出反应之前，泪水已经抢先一涌而出，代替言语给出了回答。房间很安静，我和母亲都明白对方想说什么，却只是无语凝噎。那天晚上的很多事情我都已经记不清了，在一个轻柔的吻和眼角悲伤的湿润中，我睡的很沉很沉，就好像是为了忘掉那个夜晚发生的一切。再过没多久，我们从这个家搬走了。</p>
<p>记忆是台老式放映机，胶片上布满划痕却仍固执地转动。当我在高架桥的轰鸣声里辨认出周家嘴路的路牌时，恍惚看见1998年的桑塔纳正碾过满地梧桐碎影。后视镜里倒退的宝钢又一村逐渐失焦，像被泪水浸泡过的显影液里浮起的底片——幼儿园的尖叫成了默片，父亲书房的木香凝结成胶卷齿孔间的灰尘，衣帽间房门铰链开合的钝响，原来与枯叶碎裂是同一种频率的心跳。此刻导航提示“前方施工路段”，二十年前未竣工的马路突然穿透时间柏油，将我的车轮卡在童年与成年的裂缝之间。仪表盘上闪烁的充电标志突然幻化成黑白桑塔纳的转速表，后座传来孩童的抽泣与诺基亚的蜂鸣，后视镜里没有车，只有千禧年的夕阳固执的追赶。</p>
<p><img src="/../images/%E6%AE%8B%E5%8F%B6.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/%E6%B3%A5%E6%B3%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/21/%E6%B3%A5%E6%B3%9E/" class="post-title-link" itemprop="url">泥泞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-21 16:50:46 / 修改时间：16:52:34" itemprop="dateCreated datePublished" datetime="2024-10-21T16:50:46+08:00">2024-10-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大概每个人小时候都会被长辈们问到的一个问题：“爸爸和妈妈你更喜欢谁”，相对应的回答也大多是犹豫再三之后丢出的一句“都喜欢”。有些长辈只是为了逗逗小孩，见目的达成，也就打个哈哈过去了，可偶尔也有长辈觉得这种程度的调侃不够过瘾，于是假装打破砂锅问到底地非要讨到个结果</p>
<p>于是我开始意识到，这世界上有太多的选择题值得纠结，这选择题并非如同考试的单选一般非对即错；亦不像多选题一般可以照单全收。可谁又能说这样的选择题一定是让人避之不及的灾难呢？只不过是因为贪婪的本性让人想要两头兼顾，而现实却又告诉自己绝无这样的希望，只能眼睁睁看着名为“失望”的达摩克利斯之剑一点点落向自己的脖颈</p>
<p>所以我不喜欢做选择题，面对难以两全齐美的抉择，我感到惶恐</p>
<p>令我惶恐的是站在十字路口必须决定接下来前行的方向，而我并没有做好准备</p>
<p>令我惶恐的是作出了决定之后，我必须接受另一种可能性必然的消失</p>
<p>令我惶恐的是我不得不将属于自己的部分一个个拆分开来，置于天平的两端来比较利弊——这边加一点“兴趣”和“社交”，那边加一点“工资”和“前途”</p>
<p>明明这些本就都属于我生命的一部分，为何此时不得不因为我的选择而犹如碎石一般，从我身上剥离？</p>
<p>我一直以来都这么认为，在人每一次做出选择的时候，无非是舍弃了某些东西，来获取另一些东西，认为世界运转的逻辑建立在等价交换的基础上，于是对此感到安心</p>
<p>殊不知世界并非只正襟危坐于帘幕之后观察世间一切交易的观众，而是一位善于伪装且精打细算的掮客，于无尽的选择与交易之中，祂不断偷偷收取双方的一些东西作为手续费——譬如时间、精力、热爱之类的东西，可能那些过于廉价的东西也入不了祂的眼——直到一个生命完成了谢幕为止。祂的存在感是如此的淡薄，以至于我时至今日才在胡思乱想之中找到了让我郁郁寡欢的罪魁祸首</p>
<p>在高中的时候，我对博尔赫斯的作品赞不绝口，对他写下的《小径分叉的花园》印象尤为深刻，可如今我发现，博尔赫斯所设想的宇宙——那个小径分叉永不停歇的花园——从科幻的角度或许有迹可循，可站在一个渺小的人类的视角来看，实在过于慷慨。人类的生命说到底是有限的，不管是否做出选择，时间的流逝总是推动着自己滑向死亡的终点；与此同时社会的结构和个人的命运又进一步限制了一个人先天的条件和后天有所作为的方向。站在个人的视角来看，宇宙、世界、耶和华、佛祖、上天……这些存在实在过于庞大而无法接近，即便祂们真的许诺过给予人类永恒，落在个人的肩上，也一定是重如泰山的引力；祂们许诺的天堂也好来时也好，或许也不过是用来榨取个体的话术</p>
<p>我为自己花了21年光阴才切身理解这个浅显道理的后知后觉感到惭愧，又对无法从这条绝对正确的公理之中抽身感到绝望</p>
<p>所以人活一世，本质上是在做减法，绝非加法：我无时无刻不在杀死自己，杀死无数个时空的自己，只为让当下这个自己苟且偷生。在我打下这段话的时候，我在杀死正在旅行的自己，我在杀死演奏音乐的自己，我在杀死正在写一本名为《余烬》的小说的自己，我在杀死骑在马背上肆意的自己，我在杀死21岁踌躇满志的自己，空余一个充满了嫉妒和失望和迷茫和扭曲的希望的躯壳留在世上；而到了下一秒，这个苟活于世的自己又开始做着同样的恶事</p>
<p>这么来看，当抉择的时刻临近，我能留给自己的只剩下了叹息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/17/%E6%97%A0%E8%B6%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/17/%E6%97%A0%E8%B6%A3/" class="post-title-link" itemprop="url">无趣</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-17 19:56:54 / 修改时间：21:41:14" itemprop="dateCreated datePublished" datetime="2024-07-17T19:56:54+08:00">2024-07-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们这一代人，可能包括我们下一代人，缺乏想象力——你知道吗？很多还是学生的孩子都自杀了，我认为他们无法想象出一个充满乐趣的未来——说的直白一点，他们父母的样子应该为其未来提供动力，但他们的父母看起来并没有在享受乐趣。从根本上说，孩子们无法想象出成为大人的乐趣，与孩子沟通的大人通常是他们的父母和老师，或许在观察他们的时候，孩子们看不到未来会变得快乐的希望。我认为那并不是父母的过失，而是想象力的匮乏。</p>
</blockquote>
<p>这是1997年几原邦彦接受关于自己的作品《少女革命》的采访时说的一段话，巧的是今天早上上班途中我偶然看见了，巧的是今天mentor找我谈了谈关于日后工作的事，巧的是今天下班之后我的某位朋友给我分享了他那令我咋舌的加班情况，巧的是回到家与父母讨论关于自己日后的安排后发现自己与他们意见的分歧</p>
<p>于是不禁回想起了上午瞥过的这段话。尽管这只是几原邦彦从少女革命这部作品本身所衍生出来的一段感想，可结合今天的种种经历，实在让我没法对此产生一笑了之的想法</p>
<p>“那么你怎么考虑自己将来的发展呢？”</p>
<p>“不想去大厂上班，因为我讨厌加班和高压的氛围，一天八小时的工作已经是自己的极限。”</p>
<p>“那就待在现在的公司上班吧，至少不容易被裁。”</p>
<p>“我又觉得工资低，没有办法满足我想要的生活。”（事实上我连自己想要的生活究竟是什么样子都并没有一个明确的答案，只知道钱这种东西永远不嫌多）</p>
<p>“那么创业呢？”</p>
<p>“如果人的创造力果真是一种能够量化的存在的话，或许我在这方面的数值已经归零。”</p>
<p>“那就在现在这个公司继续呆着吧，好歹骑驴找马，你说是也不是。”</p>
<p>“嗯……大概是这个道理吧。”</p>
<p>于是我找到了答案，但这不是决策，而是妥协，是无奈之举，中庸的产物。当我思考自己日后会成为什么样的人，要做什么样的事，自己其实根本无从下手，依然没办法讲清楚如果自己继续这样每天像机械一样地上下班究竟能得到什么、是否成为了小时候幻想中长大后的自己，只不过劝说自己放下心里对于远低于互联网大厂的工资的芥蒂，用安逸和稳定聊以自慰，强迫自己接受打工一辈子也大概率碌碌无为地过完这一生的事实</p>
<p>我问朋友明明只是实习，明明五点半六点钟就能走，没有人强迫你加班，加了班也得不到其他好处，所谓的锻炼自己只不过是一个幌子，本质上只不过是根赛博螺丝钉，为什么还要加班呢？</p>
<p>他匆匆给我发了几句话，简单来说就是deadline的压迫辅以同事们的等待，最终调制出了名为愧疚的苦涩药剂让他不得不一口服下，并且在下班之后给我发了两段各自长达50秒含妈量极高的语音诉说自己加班两三个小时的愤怒——然后该上班接着上班，第二天该加班接着加班</p>
<p>多么无趣呀，你也好我也罢，似乎命中注定被世界束缚而无法脱身，又去哪里能够找到梦幻一般的未来呢？可我想无趣的不是世界而是人类本身。因为懒惰而选择平庸，因为愧疚而折磨自己，因为利益而欺骗他人，因为软弱而沉默不语，因为自卑而否定一切，因为傲慢而言辞无知。无论站在什么样的起点，有过什么样的经历，这世界上的数亿人类最终殊途同归成为了大致相同的货色，连带着从井底看到的整个世界都失去了色彩，可这并不是你我的过错——钢铁的森林用你我的血肉筑起坚不可摧的身体，用你我的精力当作木材点燃永不熄灭的炉火，用规训将每个不听指挥个体打成异端，用霓虹广告吸引着未经世事的新芽</p>
<p>多么无趣呀，不管是这看不到尽头的循环，还是如灰烬一般的你我</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/10/%E5%80%BE%E8%BD%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/10/%E5%80%BE%E8%BD%A7/" class="post-title-link" itemprop="url">倾轧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-10 20:56:21 / 修改时间：23:12:55" itemprop="dateCreated datePublished" datetime="2024-06-10T20:56:21+08:00">2024-06-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实这段话早在高中就应该已经有所头绪了，但出乎意料的是这样的想法被最近几年的安逸掩盖过去，直到最近两天才重新浮于心头。</p>
<p>事情的起因是一场不足为道的家庭矛盾，主角是我和父亲，导火索是我的一句语气中带着不耐烦的回应，结局是劈头盖脸的沉重的教训。尽管我一再强调认识到了自己的错误并且进行了反思，也无法平息他的怒气。</p>
<p>当然，我并非因此而怒不可遏，以至于恨不得用小作文来记录这些重量级的言语，我知道造成这场矛盾、这个局面的根本原因在于我自己；而促使我动手写下这段话的直接理由是：人类无论多么理性、多么有智慧，无论平时多么善于思考、张弛有度，其心理防线的崩塌也只不过是一瞬间的事情——于是愤怒接管大脑，无差别地对现实进行自我意识的扭曲篡改，以此作为武器来攻击对方。而对于东亚的家长来说，最不可忍耐的、罪不可赦的莫过于家庭中比自己地位低的人对自己的忤逆（我自认为我们家算是典型的东亚强权家庭，所以这里仅从「我自己的家庭」出发作分析，范围也只限定东亚家长，但我相信即便这个范围拓宽到全人类也不为过）</p>
<p>好了，写了这么多话，我到底想表达什么观点呢？典型东亚家庭建立的感情基础是倾轧——即，强权者从弱权者甚至无权者的服从获取快感，相对应的，如果强权者无法获得快感，或者其威信受到了挑战，那么大战便一触即发。这里的强权、弱权和无权的区分指的是经济控制权，而非话语权，因为「一般」来说，谁掌控了经济，谁就掌握了话语权。此外这里我本来想用“剥削”，因为这种现象的确是一种人类情感上的剥削，但这会造成歧义，所以我会用倾轧来指代这种现象（其实“倾轧”也有歧义，但是能看懂就行）</p>
<p>为什么我说这是典型东亚家庭建立的基础。首先是家庭中强权者的存在，这几乎是必然的，无论在生活中是否有表现出来、是否有刻意塑造自己的权威形象，在组建家庭的初期，家庭的经济重心一定会往某个人身上靠，这个人可以是父母双方的任何一人，而身为重心的这个人就会顺理成章成为强权者。这个角色的分配不是一蹴而就的，而是随着率先对对方展开倾轧的一方发动攻势，日积月累导致的。而后随着孩子——这个天生的无权者的诞生，强权、弱权的格局就会敲定下来。除非强权者做了极大的错事例如出轨、犯罪等越界行为，否则不会有什么变化。回到这一段的开头，为什么倾轧是典型东亚家庭建立的基础，因为你会发现，倾轧的出现是被动的，因为财富天平的倾斜是必然的，即使是前面提到的所谓“率先对对方展开倾轧的一方发动攻势”，在家庭初期也可能只是其下意识的举动——举个简单的例子。</p>
<blockquote>
<p>我现在和路人甲谈了恋爱，双方都需要情感的往来，甜甜蜜蜜恩恩爱爱，两个人相互从对方对自己的依赖中获得快感；此时由于金钱和社会地位还没有彻底成为两人关系的重要一环，两个人的身份地位几乎是平等的，没有到失去对方意味着极大变故的程度，所以还没有到“倾轧”的地步（特殊关系这里我们暂不讨论）。</p>
<p>后来我们结了婚组建了家庭，此时我们就需要考虑：现在咱俩结婚了，有夫妻共同财产了，那么谁来管钱？假设我的收入比路人甲要略高，那么为了平衡家庭地位，我们可能会选择让路人甲来管钱。此时，家庭经济的掌控权看似在路人甲身上，实则我们相互是独立的，即便没有对方，至少自己还有收入，倾轧的效果也就不明显。</p>
<p>后来有了孩子，由于我们无法兼顾工作和家庭，于是路人甲放弃了自己的工作成为了全职主妇。这个时候倾轧就显现出来了，在这个阶段我实质上掌握了经济的绝对主动权，虽然挣到的钱全部上交给路人甲，但是没有了我，这个家庭就会面临崩溃的威胁。</p>
<p>现在我们换一个世界线，在这个世界线中路人甲没有放弃工作，我们暂时把小孩交给爷爷奶奶或者外公外婆照顾。现在我们双方都有收入，但是钱还是交给路人甲来管，那么时间长了，路人甲掌管的钱越来越多，手上会掌握家里经济的绝对控制权，我为了不让家庭崩溃，只能在情感上听从路人甲，同样会出现倾轧。</p>
<p>现在我们再换一个世界线，在这个世界线中路人甲没有放弃工作，我们暂时把小孩交给爷爷奶奶或者外公外婆照顾，但是钱我们两个人自己管好自己的，这样似乎倾轧的可能性变得很小，但与此同时，我们双方都过着各自的生活，仿佛有一堵看不见的墙壁阻拦了我们二人，我们各自的收入足够养活自己，不必为了钱而麻烦对方；我们不需要为了生活而迁就对方，大不了我用自己的钱过自己想过的日子——那么婚姻也名存实亡。</p>
</blockquote>
<p>如何？尽管这几个例子有些过于简单和理想化，但足够说明为什么我认为倾轧的道理对于人类社会大部分都是成立的。但是在典型东亚的家庭环境下，一个三口之家的父亲&#x2F;母亲会在某一个时间点选择放弃工作，担任全职主夫&#x2F;主妇，几乎断掉了自身的经济来源，只能用「情感」来制衡对方，也就给了强权者在情感上剥削弱权者的绝好机会，那么这样来看，倾轧几乎从一个家庭的诞生之初就存在，其存在感也必然会在某一个时间点达到顶峰，所以说它是一个家庭的基础也的确不为过。</p>
<p>强权者享受着家庭中绝对的话语权，当弱权者和无权者向其观点发起了挑战，即便明知双方意见达成了一致没有争吵的必要，甚至自己意识到自己是理亏的一方，强权者也不会主动示弱——因为一旦示弱，那么在家庭中自己的地位就会受到实质上的威胁，而对于弱权者和无权者来说，这样的威胁能有一次就能有无数次，久而久之，强权者的地位破产，手头上仅剩经济控制权作为威胁来让弱权者和无权者服软：</p>
<blockquote>
<p>“我是你爹&#x2F;妈，你竟然敢顶我的嘴？！”</p>
<p>“日子过不过了，不过就离婚！”</p>
<p>“我挣钱多不容易，你怎么还好意思和我搞七搞八？！”</p>
</blockquote>
<p>身为人类，没有野兽般强健的身躯，于是诞生了氏族，用血缘将我们捆绑在一起</p>
<p>身为人类，无法像三体人那样直截了当获取对方内心的想法，于是阴谋算计让我们不得不对外设防，氏族的范围逐渐缩小，最终出现了现在的家庭</p>
<p>可尽管血脉相连，剥削却依然存在，压迫从未消失，只不过对象从国家财富到生产资料和剩余价值，最终变成了感情和教育。家庭这个社会的最小单位中没有生产资料的纠葛，但倾轧本身未必会比剥削好上多少</p>
<p>如果倾轧有存在的必要，那么在社会的结构发生极大变动之前，我们似乎注定需要忍受这样的压迫</p>
<p>如果倾轧没有存在的必要，那么家庭是否也就没有了存在的必要？随着性别对立、阶级矛盾的日益加剧，婚姻家庭在将来可能会慢慢淡出人们的视野，这个问题的答案也似乎已经有迹可循——当生产力足够发达，社会化抚养或许会打破当下普世的伦理观念，成为新的社会模式</p>
<p>可当我们没有了家庭，成了一座座孤岛，人类又能够依靠什么来和他人建立长久的联系，由此获得精神上的寄托？或许我们会愈发需要诗词歌赋音乐艺术这样的兴趣爱好来充实自己的内心，可仅靠这些外在的动力，真的足以让一个个体产生“自己已经在这个世界立足”的实感吗？这样一来，人类是否又要再一次将内心世界献给那些模糊不清的概念呢？</p>
<p>我好像能看到，在那不知远近的未来，宗教带着它的信徒卷土重来…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/16/%E4%B8%B4%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/16/%E4%B8%B4%E8%A1%8C/" class="post-title-link" itemprop="url">临行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-16 09:33:14 / 修改时间：09:33:44" itemprop="dateCreated datePublished" datetime="2024-05-16T09:33:14+08:00">2024-05-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大三最后一个学期的考试前一周<br>中午排了三刻钟的队才带回寝室的麦当劳<br>花上半个晚上的时间和室友一起玩的大乱斗<br>下楼倒垃圾时抬头从树叶间隙窥见皎洁的月<br>赶路时打趣的只言片语</p>
<p>从自己开始找实习、他们开始准备考研以来，已经很久没有度过这样无忧无虑纯粹享受快乐的夜晚了<br>没有作业，没有实验，没有考研，没有实习，仿佛单纯地从分针与秒针之间无限逼近的距离中扣出一小块，然后无限地拉长，又在下一个瞬间回归了正轨</p>
<p>常言道人生苦短，光影似箭<br>可往往只有如此这般肆意挥霍时间的片刻才能够成为支撑起一段人生经历的快照<br>如今我马上就不住在宿舍，这般玩乐的机会在将来也只会越来越少，一想到这里，纵使平时有再多的不满，此刻也都显得无关紧要<br>人们终究会如同行的旅伴一样分道扬镳，踏上各自的前程，也总要学会和过去一个阶段的自己做个告别，但往往时间如暗流般淌过，而自己却无法察觉；当不得不面对现实时，才发现为时已晚<br>我不知道将来的自己会成为什么样的人、结交什么样的人，在生活的重压下能否抽出如今夜般的片刻来和某人一道用欢笑声短暂地驱散愁绪<br>我只知道当下及过去这样仿佛永恒的热闹的日子，的确是马上就要结束了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/11/%E7%96%B2%E6%83%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/11/%E7%96%B2%E6%83%AB/" class="post-title-link" itemprop="url">疲惫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-11 22:36:24 / 修改时间：23:21:56" itemprop="dateCreated datePublished" datetime="2024-04-11T22:36:24+08:00">2024-04-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一个人急眼的时候，大多是被别人点出了自己不想承认的事实</p>
<p>如果说有什么是比「被大厂拒绝实习」更让人感到痛苦的，那莫过于「被小厂拒绝实习」了，前者姑且还能够用“世上大佬云集，我只是没有名列头部”这样的理由舔舐自己的伤口，后者几乎完全将自己虚伪的表皮剥了个一干二净。虽说「实际工作所需要用到的工具和知识，与学校传授的内容堪称云泥之别」这个事实我早就已经心安理得地接受了，但是最近接连不断受挫的笔试和面试让我不得不抱着失望的目光审视自己过去这两年半的学习经历</p>
<p>说实话，我其实打心底觉得自己是没什么学习计算机的天赋的，我很难像认识的一些大佬一样接连几个小时地coding并且乐此不疲，也很难想方设法地去创造有闪光点的idea然后用代码去实现——我并不是一个富有创造力的人，也没有坚持迎难而上的主观能动性。计算机是一个拥有「明确且理性的答案」的学科，因为机器总是正确的，为对不可知的事物抱有强烈恐惧的我很喜欢这一点，但也正因如此，我喜欢尽可能地使用已经存在于世界上的方式去理解、解决问题，而非另辟蹊径将自己的头脑风暴发挥到极致——后者对于coding来说往往更加重要，这实在是一件令人失望的事实</p>
<p>大一结束的时候我决定转到计科，一方面是对机械所涉及到的力学和材料实在提不起兴趣，另一方面是抱着对计算机的憧憬。说是为了「自身钱途」考虑也好，说是为了圆高中那个胎死腹中的coding梦也好，我义无反顾地冲进这片看不到边际的汪洋大海，以为自己能够闯出一片自己的小天地<br>然而事实是残酷的：我自认为在过去的两年半中并没有荒废自己的学业，始终尝试着学习新的技术，可当我立足于当下去回顾这段时间的经历，对自己的评价并没有比漫无目的地原地绕圈的无头苍蝇好多少，这就是另一件令人失望的事实——没有规划和明确目标的学习本质上是无用功，归根结底，与荒废两年半的时间殊途同归，在最终的效果上是一致的。也直到最近开始海投实习，我才对自己究竟应该做些什么、学些什么有一个大致的方向，但可惜已经太晚了：我那被分流拖垮的大一时光和身处迷茫四处撞墙的大二大三导致了如今一事无成的情景</p>
<p>ICPC的遗憾打铁，ASC的没有后文，以及寻找实习的失败，我想这大多都可以归咎于自己装模作样的假努力，不长也不短的coding生涯始终笼罩在失败的阴影下让我开始怀疑自己究竟是不是真的不太适合学计算机</p>
<p>可如果让我再回到大一做一次选择，我还是会头也不回地选择这个专业，我依然会回忆起初中那个被计算机和代码的力量震撼到的那个下午，和高中抱着向往却没有入坑的遗憾</p>
<p>可我没能够做到用未来的时光和努力来弥补过去的遗憾，如果前方终究只是一条用梦泡点缀着的看不到光亮道路，我究竟该如何说服自己在这条路上继续走下去呢……</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/25/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%EF%BC%9A%E4%BB%A5GMP%E4%B8%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/25/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%EF%BC%9A%E4%BB%A5GMP%E4%B8%BA%E4%BE%8B/" class="post-title-link" itemprop="url">进程、线程、协程：以GMP为例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-25 10:45:41 / 修改时间：13:31:19" itemprop="dateCreated datePublished" datetime="2024-03-25T10:45:41+08:00">2024-03-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GMP的原理与调度"><a href="#GMP的原理与调度" class="headerlink" title="GMP的原理与调度"></a>GMP的原理与调度</h1><h2 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h2><p>在早期的操作系统中，一个程序就是一个进程，只有当一个进程运行完，下一个进程才能够启动，一切都是串行的。这样的系统面临两个问题：</p>
<ol>
<li>执行流程单一</li>
<li>进程阻塞会导致CPU时间的浪费</li>
</ol>
<p>因此，后来OS加入了多进程并发：当一个进程阻塞，就会切换到其他就绪的进程，以避免浪费CPU时间</p>
<h2 id="线程和协程"><a href="#线程和协程" class="headerlink" title="线程和协程"></a>线程和协程</h2><p>多线程就是指一个进程中同时有多个线程正在执行</p>
<p>线程是一个基本的cpu执行单元，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，可以与同属于一个进程的其他线程共享进程所拥有的全部资源。引入线程之后，进程只作为除cpu以外系统资源的分配单元，线程则作为处理机的分配单元</p>
<p>而一个线程的实现又可以被划分为<strong>用户线程</strong>和<strong>内核线程</strong>，一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”(Linux 的 PCB 进程控制块)。因此，我们只需再做个分类，将内核态线程依然称为“线程”，而用户态线程就被称为“协程”</p>
<p>这也就涉及到了线程与协程之间的绑定关系：</p>
<ul>
<li><p>N:1 关系</p>
<p>N 个协程绑定 1 个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1 个进程的所有协程都绑定在 1 个线程上</p>
<blockquote>
<p>缺点：</p>
<ul>
<li>某个程序用不了硬件的多核加速能力</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了</li>
</ul>
</blockquote>
</li>
<li><p>1:1 关系</p>
<p>1 个协程绑定 1 个线程，这种最容易实现。协程的调度都由 CPU 完成了，不存在 N:1 缺点，</p>
<blockquote>
<p>缺点：</p>
<ul>
<li>协程的创建、删除和切换的代价都由 CPU 完成，有点略显昂贵了</li>
</ul>
</blockquote>
</li>
<li><p>M:N 关系</p>
<p>M 个协程绑定 1 个线程，是 N:1 和 1:1 类型的结合，克服了以上 2 种模型的缺点，但实现起来最为复杂</p>
</li>
</ul>
<p>协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go 为了提供更容易使用的并发方法，使用了 goroutine 和 channel。goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发</p>
<p>Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配</p>
<p>Goroutine 特点：</p>
<ul>
<li>占用内存更小（几 kb）</li>
<li>调度更灵活 (runtime 调度)</li>
</ul>
<h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><p>事实上goroutine的调度器因为开销、锁竞争、局部性等原因，曾经一度被废除过，而重新设计过后的就是现在的GMP模型</p>
<p>在新调度器中，出列 M (thread) 和 G (goroutine)，又引进了 P (processor处理器)</p>
<p>在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上，其中涉及到几个部分：</p>
<ul>
<li>全局队列（Global Queue）：存放等待运行的 G</li>
<li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列</li>
<li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个</li>
<li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去</li>
</ul>
<p>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行</p>
<h3 id="关于M和P的数量"><a href="#关于M和P的数量" class="headerlink" title="关于M和P的数量"></a>关于M和P的数量</h3><p>P 的数量：</p>
<ul>
<li>由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $​GOMAXPROCS 个 goroutine 在同时运行</li>
</ul>
<p>2、M 的数量:</p>
<ul>
<li>go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略</li>
<li>runtime&#x2F;debug 中的 SetMaxThreads 函数，设置 M 的最大数量</li>
<li>一个 M 阻塞了，会创建新的 M</li>
</ul>
<p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来</p>
<h3 id="关于M和P的创建时机"><a href="#关于M和P的创建时机" class="headerlink" title="关于M和P的创建时机"></a>关于M和P的创建时机</h3><p>P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P</p>
<p>2、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M</p>
<h2 id="调度器设计策略"><a href="#调度器设计策略" class="headerlink" title="调度器设计策略"></a>调度器设计策略</h2><p>为了减少线程的频繁创建和销毁，对于闲置的线程，GMP的策略是对其复用</p>
<ol>
<li><p>work stealing机制：</p>
<p>当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程</p>
</li>
<li><p>hand off机制：</p>
<p>当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行</p>
</li>
</ol>
<p>利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS &#x3D; 核数&#x2F;2，则最多利用了一半的 CPU 核进行并行</p>
<p>抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方</p>
<p>全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G</p>
<h2 id="go-func-的调用流程"><a href="#go-func-的调用流程" class="headerlink" title="go func()的调用流程"></a>go func()的调用流程</h2><ol>
<li>我们通过 go func () 来创建一个 goroutine</li>
<li>有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中</li>
<li>G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行</li>
<li>一个 M 调度 G 执行的过程是一个循环机制</li>
<li>当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P</li>
<li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中</li>
</ol>
<h3 id="特殊的M0和G0"><a href="#特殊的M0和G0" class="headerlink" title="特殊的M0和G0"></a>特殊的M0和G0</h3><ul>
<li><p>M0</p>
<p>M0是启动程序后的编号为 0 的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了</p>
</li>
<li><p>G0</p>
<p>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数，每个 M 都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/CMU15-445-2022Fall-Lecture-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/CMU15-445-2022Fall-Lecture-16/" class="post-title-link" itemprop="url">CMU15-445-2022Fall-Lecture-16</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-19 16:35:51 / 修改时间：16:36:31" itemprop="dateCreated datePublished" datetime="2024-03-19T16:35:51+08:00">2024-03-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-16-Two-Phase-Locking"><a href="#Lecture-16-Two-Phase-Locking" class="headerlink" title="Lecture 16: Two-Phase Locking"></a>Lecture 16: Two-Phase Locking</h1><p>本章主要介绍了数据库事务处理中的2-PL协议</p>
<p>上节课介绍了如何使用WW、WR、RW三种冲突来判断事物之间是否是串行化的，但是在现实中，这种方法是不切实际的，因为我们不可能提前预知所有事物到底什么时候到达，以及事务具体要做什么，而在现实生活中，事务有可能会源源不断地发送到数据库，这就意味着数据库每时每刻都需要将新的事务纳入串行化的判断范畴</p>
<p>因此需要一种协议来确保DBMS在不知道事务的具体内容、具体到达时间的情况下，依然能够作出正确的判断，2-PL协议就是一种通过合理地加锁来达到这种目的的协议</p>
<h1 id="Lock-Type"><a href="#Lock-Type" class="headerlink" title="Lock Type"></a>Lock Type</h1><p>首先需要再一次强调一下数据库中两种类型锁的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>Locks</th>
<th>Latches</th>
</tr>
</thead>
<tbody><tr>
<td>Separate</td>
<td>User transactions</td>
<td>Threads</td>
</tr>
<tr>
<td>Protect</td>
<td>Database Contents</td>
<td>In-Memory Data Structures</td>
</tr>
<tr>
<td>During</td>
<td>Entire Transactions</td>
<td>Critical Sections</td>
</tr>
<tr>
<td>Modes</td>
<td>Shared, Exclusive, Update, Intention</td>
<td>Read, Write</td>
</tr>
<tr>
<td>Handle deadlock by</td>
<td>Detection &amp; Resolution Waits-for, Timeout, Aborts</td>
<td>Avoidance Coding Discipline</td>
</tr>
<tr>
<td>Kept in</td>
<td>Lock Manager</td>
<td>Protected Data Structure</td>
</tr>
</tbody></table>
<p>本章关注的是Locks，其有两种基本类型：</p>
<ul>
<li>S-Lock：共享锁（读锁）</li>
<li>X-Lock：互斥锁（写锁）</li>
</ul>
<p>两者的兼容矩阵如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>S-LOCK (shared)</th>
<th>X-LOCK (exclusive)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>S-LOCK (shared)</strong></td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><strong>X-LOCK (exclusive)</strong></td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<p>从上节课我们可以知道，WW、WR、RW都可能导致事务冲突，因此只有RR的时候，两把锁是可以兼容的</p>
<p>DBMS有一个名为Lock Manager的模块，专门负责分配、回收事务的锁。每当事务申请加锁或者升级锁的时候，都需要向其发送请求，而Lock Manager内部还维护着一个Lock Table，记录每一个事务所持有的锁（在实验中以哈希表的形式呈现），Lock Manager会根据Lock Table上面的记录来判断是给该事务分配锁，还是拒绝请求，以此确保事务排列的正确性和并发性</p>
<h1 id="Two-Phase-Locking"><a href="#Two-Phase-Locking" class="headerlink" title="Two-Phase Locking"></a>Two-Phase Locking</h1><p>2-PL帮助数据库在运行过程中决定某个事务是否可以访问某条数据，并且 2PL 的正常工作并不需要提前知道所有事务的执行内容，仅仅依靠已知的信息即可</p>
<h2 id="Growing-amp-Shrinking"><a href="#Growing-amp-Shrinking" class="headerlink" title="Growing &amp; Shrinking"></a>Growing &amp; Shrinking</h2><p>这个协议定义了两个阶段：Growing 和 Shrinking</p>
<ul>
<li>在growing阶段，事务可以按需申请获取锁，Lock Manager可以决定分配与否</li>
<li>在shrinking阶段，事务就只能够释放锁，而不能够获取新的锁或者升级已有的锁,<strong>也就是说，一旦事务释放了锁，那么它就再也无法获得锁了</strong></li>
</ul>
<p>这样的协议保证了事物之间<strong>一定不会出现有向环路，也就是一定是可串行化的</strong>（具体证明可以参考[这篇文章](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59535337">Transaction management：两阶段锁（two-phase locking） - 知乎 (zhihu.com)</a>)）</p>
<h2 id="Cascading-Aborts"><a href="#Cascading-Aborts" class="headerlink" title="Cascading Aborts"></a>Cascading Aborts</h2><p>尽管2-PL能够确保事务之间的串行性，但其可能会引发一种新的问题：联级中止</p>
<p>如果T1产生了Abort，那么已经读取了T1写入数据的T2就变成了脏读，这种情况下，DBMS需要将有过脏读的事务也反馈为Abort，而这些中止可能进而使得其它正在进行的事务级联地中止，这个过程就是所谓的级联中止</p>
<h2 id="Strong-Strict-2-PL"><a href="#Strong-Strict-2-PL" class="headerlink" title="Strong Strict 2-PL"></a>Strong Strict 2-PL</h2><p>为了解决联级中止的问题，我们可以将2-PL进行改进，也被称为Rigorous 2-PL：</p>
<ul>
<li>growing阶段和2-PL相同</li>
<li>shrinking阶段，每一个事务<strong>只有在自身结束之后才能够释放所有的锁</strong>，无论最终该事务是提交还是中止</li>
</ul>
<p>通过比较Non-2PL、2PL和Rigorous-2PL，可以看出，三者的并发程度越来越低，但是安全性是越来越高的（其中2PL和Rigourous-2PL的安全性是一致的，但是2PL可能会引发联级中止）</p>
<h1 id="Deadlock-Detection-amp-Prevention"><a href="#Deadlock-Detection-amp-Prevention" class="headerlink" title="Deadlock Detection &amp; Prevention"></a>Deadlock Detection &amp; Prevention</h1><p>2PL协议无法解决死锁问题，和操作系统中常见的解决死锁问题的方法一样，可以从事后检测（Detection）和事前阻止（Prevention）来考虑</p>
<h2 id="Deadlock-Detection"><a href="#Deadlock-Detection" class="headerlink" title="Deadlock Detection"></a>Deadlock Detection</h2><p>DBMS会维护一张waits-for graph，用来记录多个事务之间的相互等待关系，一旦图中出现了环，那么DBMS就需要考虑如何去打破这个环</p>
<h3 id="Deadlock-Handling"><a href="#Deadlock-Handling" class="headerlink" title="Deadlock Handling"></a>Deadlock Handling</h3><p>当 DBMS 检测到死锁时，它会选择一个 “受害者” (事务)，将该事务回滚，打破环形依赖，而这个 “受害者” 将依靠配置或者应用层逻辑重试或中止。这里有两个设计决定：</p>
<ol>
<li>检测死锁的频率</li>
<li>如何选择合适的 “受害者”</li>
</ol>
<p>检测死锁的频率越高，陷入死锁的事务等待的时间越短，但消耗的 cpu 也就越多。所以这是个典型的 trade-off，通常有一个调优的参数供用户配置</p>
<p>选择 “受害者” 的指标可能有很多：事务持续时间、事务的进度、事务锁住的数据数量、级联事务的数量、事务曾经重启的次数等等。在选择完 “受害者” 后，DBMS 还有一个设计决定需要做：完全回滚还是回滚到足够消除环形依赖即可</p>
<h2 id="Deadlock-Prevention"><a href="#Deadlock-Prevention" class="headerlink" title="Deadlock Prevention"></a>Deadlock Prevention</h2><p>Deadlock prevention 是一种事前行为，采用这种方案的 DBMS 无需维护 waits-for graph，也不需要实现 detection 算法，而是在事务尝试获取其它事务持有的锁时直接决定是否需要将其中一个事务中止。</p>
<p>通常 prevention 会按照事务的年龄来赋予优先级，事务的时间戳越老，优先级越高。有两种 prevention 的策略： </p>
<ul>
<li>Old Waits for Young：如果 requesting txn 优先级比 holding txn 更高则等待后者释放锁；更低则自行中止</li>
<li>Young Waits for Old：如果 requesting txn 优先级比 holding txn 更高则后者自行中止释放锁，让前者获取锁，否则 requesting txn 等待 holding txn 释放锁</li>
</ul>
<p>无论是 Old Waits for Young 还是 Young Waits for Old，只要保证 prevention 的方向是一致的，就能阻止死锁发生，其原理类似哲学家就餐设定顺序的解决方案：先给哲学家排个序，遇到获取刀叉冲突时，顺序高的优先</p>
<h1 id="Lock-Granularity"><a href="#Lock-Granularity" class="headerlink" title="Lock Granularity"></a>Lock Granularity</h1><p>当事务在获取锁的时候，DBMS可以决定分配给它的锁的粒度（到底是给它锁住一整张表？还是一个tuple？还是一个page？），DBMS需要尽可能给事务分配最少的锁，并且在并行性和开销之间进行权衡（更少，但粒度更大的锁 vs. 更多，但粒度更细的锁）</p>
<h2 id="Intention-Locks"><a href="#Intention-Locks" class="headerlink" title="Intention Locks"></a>Intention Locks</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>意向锁是一种表级别的锁，用于表明事务将要对某个对象（表、页、行）加锁。它被用来表示一个事务在获取该对象的锁之前是否会先获取其他类型的锁</p>
<blockquote>
<p>来自百度百科的定义：</p>
<p>如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁</p>
</blockquote>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>那么为什么我们需要意向锁呢？举个例子：现在有事务A已经获取了表t的某一行的互斥锁，而此时表B想要获取这张表的表共享锁，由于两把锁互斥，所以B在试图对表t施加锁的时候必须保证：</p>
<ul>
<li>当前没有其他事务持有 users 表的排他锁</li>
<li>当前没有其他事务持有 users 表中任意一行的排他锁</li>
</ul>
<p>而为了确保第二个条件成立，B就需要检查表t的每一行进行判断。很明显效率非常低，而有了意向锁之后，情况就不一样了，我们只需要检查这张表的IS或者IX锁是否空闲，那么就能直接判断能够进行后续的加锁操作，类比来说，意向锁就是这张表所有锁的哨兵</p>
<h3 id="Lock-Types"><a href="#Lock-Types" class="headerlink" title="Lock Types"></a>Lock Types</h3><ul>
<li><p>Intention-Shared Lock</p>
<p>如果我们只需要读取表R的某些行，我们可以在这些行上加上S锁。对于整个表R, 表的任何行都可以被读取。这种情况下，可以给表R加上IS锁。从而，如果此时有另一个事务需要读取表R的某些行或是整个表R, 就能根据R上的IS锁直接做出判断，无需遍历表的每一行</p>
</li>
<li><p>Intention-Exclusive Lock</p>
<p>如果我们需要写表R的某些行，此时可以给表R加上IX锁以表达这个意思。例如，表R加上IX锁后，就不能申请R上的S锁，因为IX锁表明某个事务正在修改表R的某些行</p>
</li>
<li><p>Shared+Intention-Exclusive Lock</p>
<p>共享意向排它锁，是S锁和IX锁的结合，适用于以下场景：如果需要修改表中的某些行，但需要读取整个表，这时候就可以给整张表加上SIX锁。可以看到它与IX锁的区别：加入SIX锁后，不能修改表的其它行，因为需要读整张表。</p>
<p>在MySQL中，并没有SIX锁；但在Oracle、SQL Server中有这种锁，此类数据库有更为复杂的树状组织</p>
</li>
</ul>
<h3 id="Compatibility-Matrix"><a href="#Compatibility-Matrix" class="headerlink" title="Compatibility Matrix"></a>Compatibility Matrix</h3><p>这里给出意向锁、读写锁之间的兼容矩阵，竖为事务T1已经持有的锁，横为T2想要申请的锁：</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>SIX</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IS</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><strong>IX</strong></td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>SIX</strong></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="Locking-Protocol"><a href="#Locking-Protocol" class="headerlink" title="Locking Protocol"></a>Locking Protocol</h2><p>对于一个事务，其需要在数据库层次结构的最高一级获取合适的锁：</p>
<ul>
<li>如果想要获取一个结点的S或者IS锁，事务必须至少获取其双亲结点的IS锁</li>
<li>如果想要获取一个结点的X、IX或者SIX锁，则必须至少获取其双亲结点的IX锁</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/16/CMU15-445-2022Fall-Lecture-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/16/CMU15-445-2022Fall-Lecture-15/" class="post-title-link" itemprop="url">CMU15-445-2022Fall-Lecture-15</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-16 19:50:06 / 修改时间：19:50:23" itemprop="dateCreated datePublished" datetime="2024-03-16T19:50:06+08:00">2024-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-15-Concurrency-Control-Theory"><a href="#Lecture-15-Concurrency-Control-Theory" class="headerlink" title="Lecture 15: Concurrency Control Theory"></a>Lecture 15: Concurrency Control Theory</h1><p>主要介绍了并发控制的原理</p>
<h1 id="Transaction-Managment"><a href="#Transaction-Managment" class="headerlink" title="Transaction Managment"></a>Transaction Managment</h1><p>首先是一些常见的数据库事务上会出现的并发问题：</p>
<p>比如对于以下一系列操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Read(A)</span><br><span class="line">Check(A &gt; 25)</span><br><span class="line">Pay(25)</span><br><span class="line">A = A - 25</span><br><span class="line">Write(A)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果执行到A &#x3D; A - 25的时候，突然发生了断电，那么很有可能银行就收不到钱（这个其实和恢复系统有关系）</li>
<li>如果某个人同时执行了两个相同的该操作，则如果他们同时从数据库中读取了A&#x3D;100，最终A会变成75（即少扣了25）</li>
</ul>
<p>最基础最笨拙的解决这些问题的方式就是让数据库将所有的事务排成一个队列依次执行，只有当前一个事务执行完毕、数据写会，再执行下一个事务，但是这样就会丧失数据库的并发性，还会占用大量的存储（因为我们需要把整个数据库文件进行复制）</p>
<p>因此我们需要数据库支持并发控制，并且在此基础上要保证数据的正确性和公平性</p>
<h1 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h1><p>在正式开始之前，需要明确一下事务的定义。从正式一点的定义上来说，数据库是由一组组固定的命名对象A、B、C组成的，而事务就是对这些对象的一系列处理（比如说读写、插入、删除）</p>
<p>以Sql语言为例，事务的起点会显式地用BEGIN来表示，而结束一般由成功的提交（COMMIT）或者报错（ABORT），如果事务提交，数据库会保存事务所做的所有修改（或者引发报错）；而如果事务报错，那么所有修改都将不复存在，数据库会进行回滚操作</p>
<h1 id="Correctness-Criteria：ACID"><a href="#Correctness-Criteria：ACID" class="headerlink" title="Correctness Criteria：ACID"></a>Correctness Criteria：ACID</h1><p>事务的正确性标准被称为ACID</p>
<ul>
<li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败</li>
<li>一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态</li>
<li>隔离性（Isolation）：多个事务并发执行就像事务单独执行一样并不会相互影响</li>
<li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</li>
</ul>
<h2 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h2><p>事务只有两种可能的输出：提交和报错，要么完成所有的修改，要么所有的修改都不执行</p>
<p>那么该如何保证原子性：</p>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>日志技术几乎在所有的DBMS中都会被使用到，其中有UndoLog（回滚未提交的操作）和RedoLog（执行已经提交的操作）</p>
<p>DBMS在日志中按照顺序记录了事务所作出的所有修改，然后Undo所有报错事务已经执行了的操作</p>
<h3 id="Shadow-Paging"><a href="#Shadow-Paging" class="headerlink" title="Shadow Paging"></a>Shadow Paging</h3><p>在事务执行之前，DBMS首先复制相关的page，让事务修改其中的数据，当且仅当事务正确提交之后，这些page才会对外可见</p>
<h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p>如果 DBMS 在事务开始之前是 consistent，那么在事务执行完毕后也应当是 consistent</p>
<p>比如对于一个银行所使用的数据库，至少钱的数值不能小于100，如果a有90块钱，他想转100给b，此时，事务提交之前符合数据库的规则，但是在提交之后就不符合了，那么此时事务就不能够提交，这就是所谓的一致性</p>
<ul>
<li><p>数据库一致性：数据库中的数据是对现实世界中的模拟，并且满足约束的规则</p>
</li>
<li><p>事务一致性：事务执行前后数据库均满足一致性</p>
</li>
</ul>
<h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p>用户提交事务，不同事务执行过程应当互相隔离，互不影响，每个事务都认为只有自己在执行</p>
<h3 id="并发控制协议"><a href="#并发控制协议" class="headerlink" title="并发控制协议"></a>并发控制协议</h3><p>为了达到并发执行事务的目的，我们需要并发控制协议，包含两种锁</p>
<ul>
<li>乐观锁：假设事物之间的冲突是罕见的，当冲突发生之后再进行处理</li>
<li>悲观锁：事务执行时获取需要的锁，这样不会导致冲突的发生</li>
</ul>
<h3 id="事务并发顺序的正确性"><a href="#事务并发顺序的正确性" class="headerlink" title="事务并发顺序的正确性"></a>事务并发顺序的正确性</h3><p>为了保证结果的正确性，并发执行的顺序必须等同于某种串行的顺序</p>
<ul>
<li><strong>Serial Schedule</strong>：不同事务之间没有重叠，串行执行</li>
<li><strong>Equivalent Schedules</strong>：对于任意数据库起始状态，若两个调度分别执行所到达的数据库最终状态相同，则称这两个调度等价</li>
<li><strong>Serializable Schedule</strong>：如果一个 schedule 与事务之间的某种 serial execution 的效果一致，则称该 schedule 为 serializable schedule</li>
</ul>
<h3 id="事务冲突"><a href="#事务冲突" class="headerlink" title="事务冲突"></a>事务冲突</h3><p>两个不同的事务指向了同一个对象，如果其中一个对对象有写操作，则会产生冲突</p>
<ul>
<li>读写冲突：事务先A读取某行数据、事务B后修改该行数据，和事务B先修改某行事务、事务A后读该行记录两种schedule。事务A读到的结果不同。这种冲突可能会导致Unrepeatable Read（不可重复读，两次读取的数据可能不一样）和Dirty Read（脏读，一个事务读取了另一个事务还没有提交的数据）</li>
<li>写读冲突：读未提交（脏读）</li>
<li>写写冲突：Lost Update（更新丢失，一个事务将另一个事务的未提交的数据覆盖）</li>
</ul>
<h3 id="冲突串行化"><a href="#冲突串行化" class="headerlink" title="冲突串行化"></a>冲突串行化</h3><p>冲突的串行化执行可以通过一定的转换为某种串行化的结果</p>
<ul>
<li>两个 schedules 在 transactions 中有相同的 actions，且每组 conflicting actions 按照相同顺序排列，则称它们为 conflict equivalent</li>
<li>一个 schedule S 如果与某个 serial schedule 是 conflict equivalent，则称 S 是 conflict serializable</li>
<li>如果通过交换不同 transactions 中连续的 non-conflicting operations 可以将 S 转化成 serial schedule，则称 S 是 conflict serializable</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/14/%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/14/%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">如何用Redis实现消息队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-14 15:30:20 / 修改时间：22:11:44" itemprop="dateCreated datePublished" datetime="2024-03-14T15:30:20+08:00">2024-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是消息队列（MQ）"><a href="#什么是消息队列（MQ）" class="headerlink" title="什么是消息队列（MQ）"></a>什么是消息队列（MQ）</h1><p>顾名思义，将消息以队列的形式缓存，生产者（producer）和消费者（consumer）分别使用队列的两个端口进行消息的收发</p>
<h2 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h2><p>消息队列有两个核心能力：解耦和削峰</p>
<ul>
<li><p>解耦：</p>
<p>如果没有消息队列，那么在一次业务流程中，上游的http或者rpc发出请求之后，下游的消费者需要马上进行反馈，否则整个流程就会一直阻塞，这即浪费时间，又浪费CPU性能</p>
<p>因此我们需要一个能够持久化存放请求的容器，这就是消息队列的解耦——将生产者和消费者的应用进行解耦</p>
</li>
<li><p>削峰</p>
<p>如果在某一时刻，生产者给消费者生成了大量的请求，而消费者无法一次性全部消费，那么会产生消息的丢失</p>
<p>而有了消息队列，就可以分批次处理数量过多的请求</p>
</li>
</ul>
<h2 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h2><p>作为消息队列组件，需要满足一些要求：</p>
<ul>
<li><p>消息不丢失</p>
<p>很好理解，毕竟如果消息易失，那么有没有消息队列就都没太大区别了，这一方面可以分为三个部分来看待：</p>
<ul>
<li>生产者将消息投递到MQ的时候不出现丢失</li>
<li>消息存放在MQ时不丢失</li>
<li>消费者从MQ消费消息时不出现丢失</li>
</ul>
<p>针对第二点，各个MQ组件基本都是基于数据落盘+数据备份的方式来完成的</p>
<p>而对于第一第三点，则是通过两个交互环节中的ack机制保证的，譬如生产者向MQ中投递消息，如果没有收到MQ的ack返回确认，那么生产者就应当一直投递这个消息给MQ；另一方面，消费者也需要避免接收重复的消息，所以对于下游的消费者，同样需要具备消息幂等去重的能力</p>
</li>
<li><p>支持消息存储</p>
<p>就像前面提到的，MQ至少需要支持一定规模的数据的存放，而且这种存放需要持久性，能够让消费者自由选择时间进行消费操作</p>
</li>
</ul>
<h2 id="流程类型"><a href="#流程类型" class="headerlink" title="流程类型"></a>流程类型</h2><p>根据消费者的消费流程，MQ可以被分为两种类型：</p>
<ul>
<li><p>Push型：</p>
<p>指当生产者将消息投递到MQ时，由MQ主动将消息以推送的方式发送给各个订阅了的消费者</p>
</li>
<li><p>Pull型：</p>
<p>当MQ中存在消息时，由消费者主动执行拉取消息的操作来获取消息</p>
</li>
</ul>
<p>两种类型各有优劣，实际操作中需要按需取舍</p>
<h1 id="如何用Redis实现消息队列"><a href="#如何用Redis实现消息队列" class="headerlink" title="如何用Redis实现消息队列"></a>如何用Redis实现消息队列</h1><p>Redis虽然是一种非关系型数据库，但是其部分数据结构是能够支持实现消息队列组件的</p>
<h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p>首先需要指出可能存在的一些问题</p>
<ul>
<li><p>存储昂贵</p>
<p>由于Redis是基于内存实现的缓存中间件，所以存储消息容量的限制比较大</p>
</li>
<li><p>数据丢失</p>
<ul>
<li><p>由于Redis是基于内存实现的缓存中间件，所以不可避免地会产生丢失数据的风险（比如断电和宕机），虽然有rdb&#x2F;aof这种持久化机制，但是无法做到百分百安全</p>
</li>
<li><p>此外，Redis走的是ap高可用流派，数据的主从复制流程是异步的，主从切换时数据存在弱一致的问题</p>
</li>
</ul>
</li>
</ul>
<h2 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h2><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>一种比较容易想到的思路就是使用Redis的List结构，这是一个双向链表，天然契合MQ的队列模型，只需要使用LPUSH和RPOP进行消息的投递和读取即可</p>
<p>这种方法的缺点也是显而易见的：如果生产者生产消息的速度赶不上消费者的消费速度，那么消费者使用RPOP拉取消息的时候就会立刻返回空值nil，也就是说，需要消费者不断轮询地访问，这种高频的自旋对于CPU是一种无用的损耗；另一方面，如果让消费者每次轮询之后休眠一段时间，那么可能会导致消息处理不及时，也是我们不希望看到的情况</p>
<p>最理想的方案是：在List中有数据到达时，消费者马上能够意识到，并且处理数据，此外始终保持睡眠状态，也就是阻塞态</p>
<p>因此，我们可以使用Redis中的BRPOP指令来代替RPOP，即可弥补上述的缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP my_topic 0</span><br></pre></td></tr></table></figure>

<p>其中topic后面的数字代表阻塞等待时长，达到此阈值仍未获取数据时会返回nil；如果设置为 0 ，则代表没有这个超时限制</p>
<h3 id="局限性分析"><a href="#局限性分析" class="headerlink" title="局限性分析"></a>局限性分析</h3><p>尽管解决了阻塞问题，List仍然不能算是一个合格的消息队列组件，原因如下：</p>
<ul>
<li><p>无法支持发布&#x2F;订阅模式</p>
<p>显然List的消费者和生产者是一对一的，因为数据在POP出去之后就不复存在，只此一份，如果我们有多个消费者，每个都需要消费者所生产的数据，那么List就束手无策了</p>
</li>
<li><p>无法支持消费端ack机制</p>
<p>当消费者出现了宕机等意外，没有一种有效的手段告诉MQ消息处理失败的反馈，在这种情况下，一旦数据POP，就真的完全丢失了</p>
</li>
</ul>
<h2 id="Redis-pub-x2F-sub"><a href="#Redis-pub-x2F-sub" class="headerlink" title="Redis pub&#x2F;sub"></a>Redis pub&#x2F;sub</h2><p>为了解决无法支持发布&#x2F;订阅模式的问题，Redis提供了pub&#x2F;sub机制，全称为publisher&#x2F;subscriber</p>
<h3 id="具体方法-1"><a href="#具体方法-1" class="headerlink" title="具体方法"></a>具体方法</h3><p>pub&#x2F;sub模式会在两者之间建立一个用于实时通信的信道channel，在传递消息时，会根据channel查找到所有建立订阅关系的subscriber，一一传送消息</p>
<p>操作指令为：</p>
<blockquote>
<p>发布者：publish topic_name message</p>
<p>比如：publish my_new_message 今天天气怎么样</p>
<p>订阅者：subscribe topic_name</p>
<p>订阅者会使用阻塞模式进行监听，解决了List方法中的CPU浪费问题</p>
</blockquote>
<p>这里解释一下背后的原理：</p>
<ul>
<li>首先，消费方 subscriber 通过 subscribe 指令建立和指定 channel 之间的订阅关系. 这时在 redis 中会维护好 channel 和对应 subscriber 列表的映射关系，并在内存中为每个在线活跃的 subscriber 分配好一个缓冲区 buffer，用以承载后续到来的消息数据</li>
<li>接下来随着 publisher 执行 publish 指令，往对应 channel 中投递消息后，此时 redis 会实时查看 channel 对应 subscriber 名单，往每个 subscriber 的缓冲区 buffer 中推送这条数据</li>
<li>各执行了 subscribe 指令的 subscriber 会处于阻塞监听缓冲区 buffer 的状态，随着新数据到达，subscriber 会获取到这笔数据</li>
</ul>
<p>基于这个流程，我们能看出来，pub&#x2F;sub 对于 channel 以及 subscribers 之间的实时映射关系存在强依赖. 因此在操作的执行顺序上，我们需要保证先执行 subscribe 指令，再执行 publish 执行，否则前几笔 publish 投递的数据就会因为不存在 subscriber 而被直接丢弃</p>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>pub&#x2F;sub模式最大的优点就是实现了发布&#x2F;订阅能力，然而其缺点也很明显：关于消息丢失的处理</p>
<ul>
<li><p>缺乏ack机制：</p>
<p>与List相同，没有ack意味着pub&#x2F;sub模式依然没有办法提醒发布者消息处理的成功与否，无法执行消息的重放</p>
</li>
<li><p>缺乏消息储存能力</p>
<p>Redis的pub&#x2F;sub模式相当于golang中的无缓冲型channel，仅仅是维护了channel和subscribers之间的映射关系，每当消息来临，不会停留在channel中，而是直接送往映射的buffer中，所以会出现以下问题：</p>
<ul>
<li>subscriber 宕机：倘若某个 subscriber 中途宕机，则会被踢出名单，在恢复前的这段时间内，到达的消息都会彻底与这个 subscriber 无缘</li>
<li>Redis 宕机：每条 publish 的消息都会第一时间分发到 subscriber 对应的内存缓冲区中，而这个缓冲区是完全基于内存实现的易失性存储，一旦 Redis 服务端宕机，缓冲区中的数据就完全丢失且不可恢复了；此外，pub&#x2F;sub 模式下的消息数据不属于 Redis 中的基本数据类型，因此 redis 中的持久化机制 rdb 和 aof 对于 pub&#x2F;sub 中的数据是完全不生效的，数据丢失的可能性大幅度提高</li>
<li>subscriber消息积压：由于消息数据会被放在 Redis 侧各 subscriber 的缓冲区 buffer 中，这部分空间是相对有限的，一旦某个 subscriber 因为消费能力弱，导致 buffer 中的的数据发生积压，此时 Redis 很可能会自动把 subscriber 踢除下线，于是这部分数据也丢失了</li>
</ul>
<p>对于最后这一点，可以在redis.conf文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60s</span><br></pre></td></tr></table></figure>

<p>对应的含义是，倘若某个 subscriber 的缓冲区 buffer 大小达到 32MB，则 subscriber 会被踢下线；倘若缓冲区内数据量在连续 60s 内达到 8MB 大小，subscriber 也会踢下线</p>
</li>
</ul>
<h2 id="Redis-Streams"><a href="#Redis-Streams" class="headerlink" title="Redis Streams"></a>Redis Streams</h2><h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><p>首先需要介绍一下几个核心的操作指令，所有指令都可以在<a target="_blank" rel="noopener" href="https://redis.io/commands/">官方文档</a>中找到：</p>
<ul>
<li><p>生产消息：</p>
<p>使用该指令可以向topic中投放一组键值对消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD my_streams_topic * key1 value1</span><br><span class="line">&quot;1710412272535-0&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>My_streams_topic：topic名称</li>
<li>*：表示该消息自动生成唯一标识id，基于时间戳+自增序列号生成</li>
<li>Key1、value1:输入的键值对</li>
</ul>
</li>
<li><p>消费消息：</p>
<p>使用该指令可以从对应的topic中获取消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread [BLOCK] [Time] streams my_streams_topic 0-0</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710412272535-0&quot;</span><br><span class="line">         2) 1) &quot;key1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>BLOCK：表示是否使用阻塞消费模式</li>
<li>Time：如果加入BLOCK参数，那么此处需要填写time表示阻塞等待时间，超过这个时间就会返回nil；设置为0表示不设置超时阈值</li>
<li>streams：表示从一个streams对象读取消息</li>
<li>my_streams_topic：topic名称</li>
<li>0-0：表示从头开始消费；这里如果填写的是某条消息的id的话，就会从这条消息之后开始消费</li>
</ul>
</li>
</ul>
<p>此外streams支持发布&#x2F;订阅模式，可以保证消息被多个消费者组访问</p>
<ul>
<li><p>创建消费者组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATE my_streams_topic my_group 0-0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<ul>
<li>my_streams_topic：topic 名称</li>
<li>my_group：消费者组名称</li>
<li>0-0：从头开始消费</li>
</ul>
</li>
<li><p>基于消费者组消费信息：</p>
<p>同一份数据在同一个消费者组下只会被消费到一次. 不同消费者组各自能获取到独立完整的消息数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP my_group consumer1 BLOCK 0 STREAMS my_streams_topic &gt;</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710412272535-0&quot;</span><br><span class="line">         2) 1) &quot;key1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">      2) 1) &quot;1710413025712-0&quot;</span><br><span class="line">         2) 1) &quot;key2&quot;</span><br><span class="line">            2) &quot;value2&quot;</span><br><span class="line">      3) 1) &quot;1710413031719-0&quot;</span><br><span class="line">         2) 1) &quot;key3&quot;</span><br><span class="line">            2) &quot;value3&quot;</span><br><span class="line">      4) 1) &quot;1710413036009-0&quot;</span><br><span class="line">         2) 1) &quot;key4&quot;</span><br><span class="line">            2) &quot;value4&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>my_group: 消费者组名称</li>
<li>Consumer1：消费者名称</li>
<li>my_streams_topic：topic 名称</li>
<li>BLOCK 0: 采用阻塞等待的模式，0 代表没有超时上限</li>
<li>&gt;：读最新的消息 (尚未分配给某个 consumer 的消息)</li>
</ul>
<p>此外还有一种消费模式，读取的是已经分配给当前消费者，但是还未经确认的旧消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP my_group consumer1 BLOCK 0 STREAMS my_streams_topic 0-0</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710413250364-0&quot;</span><br><span class="line">         2) 1) &quot;key5&quot;</span><br><span class="line">            2) &quot;value5&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>0-0：标识读取已分配给当前 consumer ，但是还没经过 xack 指令确认的消息</li>
</ul>
<p><strong>&gt; 与 0-0，两者之间的区别在于，“&gt;”读取新消息，“0-0”读取旧消息</strong></p>
</li>
<li><p>确认消息：</p>
<p>通过 xack 指令，携带上消费者组、topic 名称以及消息 id，能够完成对某条消息的确认操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XACK my_streams_topic my_group 1710413250364-0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<ul>
<li>my_streams_topic：topic 名称</li>
<li>my_group：消费者组名称</li>
<li>1710413250364-0：消息 id</li>
</ul>
</li>
</ul>
<h2 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><p>首先是最明显的优点：</p>
<ul>
<li><p>支持发布&#x2F;订阅模式</p>
<p>Redis Streams 引入了消费者组 group 的概念，因此是能够保证各个消费者组 consumer group 均能够获取到一份独立而完整的消息数据</p>
</li>
<li><p>数据可持久化</p>
<p>Redis 中的 streams 和 string、list 等数据类型一样，都能够通过 rdb( redis database)、aof( append only file) 的持久化机制进行落盘存储，能够在很大程度上降低数据丢失的概率</p>
</li>
<li><p>支持消费端 ack 机制</p>
<p>Redis Streams 中另一项非常重要的改进，是支持 consumer 的 ack 能力，consumer 在处理好某条消息后，能通过 xack 指令对该消息进行确认。这样对于没经过 ack 确认的消息，Redis Streams 还是为 consumer 保留了重新消费的能力</p>
</li>
<li><p>支持消息缓存</p>
<p>和 pub&#x2F;sub 模式不同的是，Redis Streams 中会实际开辟内存空间用于存储 Streams 中的数据，因此哪怕某个 consumer group 是在消息生产之后才完成注册操作，也能够进行消息溯源，从 topic 起点开始执行消息的消费操作</p>
<p>然而由于Redis是基于内存实现的存储，因此如果消息量过于庞大，可能会造成很大的资源压力甚至out of memory。因此，可以在XADD指令中加上maxlen，显式地设定topic中能缓存的数据长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD my_topic MAXLEN 10000 * key1 value1</span><br></pre></td></tr></table></figure>

<ul>
<li>最多缓存10000条数据</li>
</ul>
</li>
</ul>
<h1 id="整体对比"><a href="#整体对比" class="headerlink" title="整体对比"></a>整体对比</h1><p>现在对Redis实现MQ的各个方法做个比较：</p>
<table>
<thead>
<tr>
<th><strong>MQ 实现方案</strong></th>
<th><strong>发布&#x2F;订阅能力</strong></th>
<th><strong>消费端ACK机制</strong></th>
<th><strong>消息缓存能力</strong></th>
<th><strong>数据丢失风险</strong></th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>低</td>
</tr>
<tr>
<td>pub&#x2F;sub</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>高</td>
</tr>
<tr>
<td>Streams</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>低</td>
</tr>
</tbody></table>
<p>可以看到，在各项能力上 List 和 pub&#x2F;sub 互有千秋，而 Streams 可以说是兼具了各方面的优势，称得上是已经趋近于成熟的MQ实现方案</p>
<p>下面我们再进一步拿 Redis Streams 和业界专业的 MQ 组件进行对比</p>
<table>
<thead>
<tr>
<th><strong>MQ组件</strong></th>
<th><strong>消息存储介质</strong></th>
<th><strong>消息分区&#x2F;并发能力</strong></th>
<th><strong>数据丢失风险</strong></th>
<th><strong>运维成本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Redis Streams</td>
<td>内存</td>
<td>不支持</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>Kafka</td>
<td>磁盘</td>
<td>支持</td>
<td>理论上不存在</td>
<td>偏高</td>
</tr>
</tbody></table>
<p>由于Redis Streams在存储上需要使用内存，因此消息存储容量相对有限；且同一个 topic 的数据由于对应为同一个 key，因此会被分发到相同节点，无法实现数据的纵向分治，因此不具备类似于 kafka 纵向分区以提高并发度的能力</p>
<p>因此使用Redis作为MQ的主要优势就在于运维成本低，如果在实际的业务流程中，对于数据的精度没有特别高的要求，那么使用Redis Streams这种轻量化的MQ方案不失为一种好的选择</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="愚者大人的铁质卷烟盒"
      src="/images/NiJiKa.GIF">
  <p class="site-author-name" itemprop="name">愚者大人的铁质卷烟盒</p>
  <div class="site-description" itemprop="description">琐碎和思考的堆放处</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jinziguan123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jinziguan123" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18917950960@163.com" title="E-Mail → mailto:18917950960@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">愚者大人的铁质卷烟盒</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
