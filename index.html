<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="琐碎和思考的堆放处">
<meta property="og:type" content="website">
<meta property="og:title" content="CigaCase">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="CigaCase">
<meta property="og:description" content="琐碎和思考的堆放处">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="愚者大人的铁质卷烟盒">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CigaCase</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CigaCase</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/17/%E6%97%A0%E8%B6%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/17/%E6%97%A0%E8%B6%A3/" class="post-title-link" itemprop="url">无趣</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-17 19:56:54 / 修改时间：21:41:14" itemprop="dateCreated datePublished" datetime="2024-07-17T19:56:54+08:00">2024-07-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们这一代人，可能包括我们下一代人，缺乏想象力——你知道吗？很多还是学生的孩子都自杀了，我认为他们无法想象出一个充满乐趣的未来——说的直白一点，他们父母的样子应该为其未来提供动力，但他们的父母看起来并没有在享受乐趣。从根本上说，孩子们无法想象出成为大人的乐趣，与孩子沟通的大人通常是他们的父母和老师，或许在观察他们的时候，孩子们看不到未来会变得快乐的希望。我认为那并不是父母的过失，而是想象力的匮乏。</p>
</blockquote>
<p>这是1997年几原邦彦接受关于自己的作品《少女革命》的采访时说的一段话，巧的是今天早上上班途中我偶然看见了，巧的是今天mentor找我谈了谈关于日后工作的事，巧的是今天下班之后我的某位朋友给我分享了他那令我咋舌的加班情况，巧的是回到家与父母讨论关于自己日后的安排后发现自己与他们意见的分歧</p>
<p>于是不禁回想起了上午瞥过的这段话。尽管这只是几原邦彦从少女革命这部作品本身所衍生出来的一段感想，可结合今天的种种经历，实在让我没法对此产生一笑了之的想法</p>
<p>“那么你怎么考虑自己将来的发展呢？”</p>
<p>“不想去大厂上班，因为我讨厌加班和高压的氛围，一天八小时的工作已经是自己的极限。”</p>
<p>“那就待在现在的公司上班吧，至少不容易被裁。”</p>
<p>“我又觉得工资低，没有办法满足我想要的生活。”（事实上我连自己想要的生活究竟是什么样子都并没有一个明确的答案，只知道钱这种东西永远不嫌多）</p>
<p>“那么创业呢？”</p>
<p>“如果人的创造力果真是一种能够量化的存在的话，或许我在这方面的数值已经归零。”</p>
<p>“那就在现在这个公司继续呆着吧，好歹骑驴找马，你说是也不是。”</p>
<p>“嗯……大概是这个道理吧。”</p>
<p>于是我找到了答案，但这不是决策，而是妥协，是无奈之举，中庸的产物。当我思考自己日后会成为什么样的人，要做什么样的事，自己其实根本无从下手，依然没办法讲清楚如果自己继续这样每天像机械一样地上下班究竟能得到什么、是否成为了小时候幻想中长大后的自己，只不过劝说自己放下心里对于远低于互联网大厂的工资的芥蒂，用安逸和稳定聊以自慰，强迫自己接受打工一辈子也大概率碌碌无为地过完这一生的事实</p>
<p>我问朋友明明只是实习，明明五点半六点钟就能走，没有人强迫你加班，加了班也得不到其他好处，所谓的锻炼自己只不过是一个幌子，本质上只不过是根赛博螺丝钉，为什么还要加班呢？</p>
<p>他匆匆给我发了几句话，简单来说就是deadline的压迫辅以同事们的等待，最终调制出了名为愧疚的苦涩药剂让他不得不一口服下，并且在下班之后给我发了两段各自长达50秒含妈量极高的语音诉说自己加班两三个小时的愤怒——然后该上班接着上班，第二天该加班接着加班</p>
<p>多么无趣呀，你也好我也罢，似乎命中注定被世界束缚而无法脱身，又去哪里能够找到梦幻一般的未来呢？可我想无趣的不是世界而是人类本身。因为懒惰而选择平庸，因为愧疚而折磨自己，因为利益而欺骗他人，因为软弱而沉默不语，因为自卑而否定一切，因为傲慢而言辞无知。无论站在什么样的起点，有过什么样的经历，这世界上的数亿人类最终殊途同归成为了大致相同的货色，连带着从井底看到的整个世界都失去了色彩，可这并不是你我的过错——钢铁的森林用你我的血肉筑起坚不可摧的身体，用你我的精力当作木材点燃永不熄灭的炉火，用规训将每个不听指挥个体打成异端，用霓虹广告吸引着未经世事的新芽</p>
<p>多么无趣呀，不管是这看不到尽头的循环，还是如灰烬一般的你我</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/10/%E5%80%BE%E8%BD%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/10/%E5%80%BE%E8%BD%A7/" class="post-title-link" itemprop="url">倾轧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-10 20:56:21 / 修改时间：23:12:55" itemprop="dateCreated datePublished" datetime="2024-06-10T20:56:21+08:00">2024-06-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实这段话早在高中就应该已经有所头绪了，但出乎意料的是这样的想法被最近几年的安逸掩盖过去，直到最近两天才重新浮于心头。</p>
<p>事情的起因是一场不足为道的家庭矛盾，主角是我和父亲，导火索是我的一句语气中带着不耐烦的回应，结局是劈头盖脸的沉重的教训。尽管我一再强调认识到了自己的错误并且进行了反思，也无法平息他的怒气。</p>
<p>当然，我并非因此而怒不可遏，以至于恨不得用小作文来记录这些重量级的言语，我知道造成这场矛盾、这个局面的根本原因在于我自己；而促使我动手写下这段话的直接理由是：人类无论多么理性、多么有智慧，无论平时多么善于思考、张弛有度，其心理防线的崩塌也只不过是一瞬间的事情——于是愤怒接管大脑，无差别地对现实进行自我意识的扭曲篡改，以此作为武器来攻击对方。而对于东亚的家长来说，最不可忍耐的、罪不可赦的莫过于家庭中比自己地位低的人对自己的忤逆（我自认为我们家算是典型的东亚强权家庭，所以这里仅从「我自己的家庭」出发作分析，范围也只限定东亚家长，但我相信即便这个范围拓宽到全人类也不为过）</p>
<p>好了，写了这么多话，我到底想表达什么观点呢？典型东亚家庭建立的感情基础是倾轧——即，强权者从弱权者甚至无权者的服从获取快感，相对应的，如果强权者无法获得快感，或者其威信受到了挑战，那么大战便一触即发。这里的强权、弱权和无权的区分指的是经济控制权，而非话语权，因为「一般」来说，谁掌控了经济，谁就掌握了话语权。此外这里我本来想用“剥削”，因为这种现象的确是一种人类情感上的剥削，但这会造成歧义，所以我会用倾轧来指代这种现象（其实“倾轧”也有歧义，但是能看懂就行）</p>
<p>为什么我说这是典型东亚家庭建立的基础。首先是家庭中强权者的存在，这几乎是必然的，无论在生活中是否有表现出来、是否有刻意塑造自己的权威形象，在组建家庭的初期，家庭的经济重心一定会往某个人身上靠，这个人可以是父母双方的任何一人，而身为重心的这个人就会顺理成章成为强权者。这个角色的分配不是一蹴而就的，而是随着率先对对方展开倾轧的一方发动攻势，日积月累导致的。而后随着孩子——这个天生的无权者的诞生，强权、弱权的格局就会敲定下来。除非强权者做了极大的错事例如出轨、犯罪等越界行为，否则不会有什么变化。回到这一段的开头，为什么倾轧是典型东亚家庭建立的基础，因为你会发现，倾轧的出现是被动的，因为财富天平的倾斜是必然的，即使是前面提到的所谓“率先对对方展开倾轧的一方发动攻势”，在家庭初期也可能只是其下意识的举动——举个简单的例子。</p>
<blockquote>
<p>我现在和路人甲谈了恋爱，双方都需要情感的往来，甜甜蜜蜜恩恩爱爱，两个人相互从对方对自己的依赖中获得快感；此时由于金钱和社会地位还没有彻底成为两人关系的重要一环，两个人的身份地位几乎是平等的，没有到失去对方意味着极大变故的程度，所以还没有到“倾轧”的地步（特殊关系这里我们暂不讨论）。</p>
<p>后来我们结了婚组建了家庭，此时我们就需要考虑：现在咱俩结婚了，有夫妻共同财产了，那么谁来管钱？假设我的收入比路人甲要略高，那么为了平衡家庭地位，我们可能会选择让路人甲来管钱。此时，家庭经济的掌控权看似在路人甲身上，实则我们相互是独立的，即便没有对方，至少自己还有收入，倾轧的效果也就不明显。</p>
<p>后来有了孩子，由于我们无法兼顾工作和家庭，于是路人甲放弃了自己的工作成为了全职主妇。这个时候倾轧就显现出来了，在这个阶段我实质上掌握了经济的绝对主动权，虽然挣到的钱全部上交给路人甲，但是没有了我，这个家庭就会面临崩溃的威胁。</p>
<p>现在我们换一个世界线，在这个世界线中路人甲没有放弃工作，我们暂时把小孩交给爷爷奶奶或者外公外婆照顾。现在我们双方都有收入，但是钱还是交给路人甲来管，那么时间长了，路人甲掌管的钱越来越多，手上会掌握家里经济的绝对控制权，我为了不让家庭崩溃，只能在情感上听从路人甲，同样会出现倾轧。</p>
<p>现在我们再换一个世界线，在这个世界线中路人甲没有放弃工作，我们暂时把小孩交给爷爷奶奶或者外公外婆照顾，但是钱我们两个人自己管好自己的，这样似乎倾轧的可能性变得很小，但与此同时，我们双方都过着各自的生活，仿佛有一堵看不见的墙壁阻拦了我们二人，我们各自的收入足够养活自己，不必为了钱而麻烦对方；我们不需要为了生活而迁就对方，大不了我用自己的钱过自己想过的日子——那么婚姻也名存实亡。</p>
</blockquote>
<p>如何？尽管这几个例子有些过于简单和理想化，但足够说明为什么我认为倾轧的道理对于人类社会大部分都是成立的。但是在典型东亚的家庭环境下，一个三口之家的父亲&#x2F;母亲会在某一个时间点选择放弃工作，担任全职主夫&#x2F;主妇，几乎断掉了自身的经济来源，只能用「情感」来制衡对方，也就给了强权者在情感上剥削弱权者的绝好机会，那么这样来看，倾轧几乎从一个家庭的诞生之初就存在，其存在感也必然会在某一个时间点达到顶峰，所以说它是一个家庭的基础也的确不为过。</p>
<p>强权者享受着家庭中绝对的话语权，当弱权者和无权者向其观点发起了挑战，即便明知双方意见达成了一致没有争吵的必要，甚至自己意识到自己是理亏的一方，强权者也不会主动示弱——因为一旦示弱，那么在家庭中自己的地位就会受到实质上的威胁，而对于弱权者和无权者来说，这样的威胁能有一次就能有无数次，久而久之，强权者的地位破产，手头上仅剩经济控制权作为威胁来让弱权者和无权者服软：</p>
<blockquote>
<p>“我是你爹&#x2F;妈，你竟然敢顶我的嘴？！”</p>
<p>“日子过不过了，不过就离婚！”</p>
<p>“我挣钱多不容易，你怎么还好意思和我搞七搞八？！”</p>
</blockquote>
<p>身为人类，没有野兽般强健的身躯，于是诞生了氏族，用血缘将我们捆绑在一起</p>
<p>身为人类，无法像三体人那样直截了当获取对方内心的想法，于是阴谋算计让我们不得不对外设防，氏族的范围逐渐缩小，最终出现了现在的家庭</p>
<p>可尽管血脉相连，剥削却依然存在，压迫从未消失，只不过对象从国家财富到生产资料和剩余价值，最终变成了感情和教育。家庭这个社会的最小单位中没有生产资料的纠葛，但倾轧本身未必会比剥削好上多少</p>
<p>如果倾轧有存在的必要，那么在社会的结构发生极大变动之前，我们似乎注定需要忍受这样的压迫</p>
<p>如果倾轧没有存在的必要，那么家庭是否也就没有了存在的必要？随着性别对立、阶级矛盾的日益加剧，婚姻家庭在将来可能会慢慢淡出人们的视野，这个问题的答案也似乎已经有迹可循——当生产力足够发达，社会化抚养或许会打破当下普世的伦理观念，成为新的社会模式</p>
<p>可当我们没有了家庭，成了一座座孤岛，人类又能够依靠什么来和他人建立长久的联系，由此获得精神上的寄托？或许我们会愈发需要诗词歌赋音乐艺术这样的兴趣爱好来充实自己的内心，可仅靠这些外在的动力，真的足以让一个个体产生“自己已经在这个世界立足”的实感吗？这样一来，人类是否又要再一次将内心世界献给那些模糊不清的概念呢？</p>
<p>我好像能看到，在那不知远近的未来，宗教带着它的信徒卷土重来…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/16/%E4%B8%B4%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/16/%E4%B8%B4%E8%A1%8C/" class="post-title-link" itemprop="url">临行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-16 09:33:14 / 修改时间：09:33:44" itemprop="dateCreated datePublished" datetime="2024-05-16T09:33:14+08:00">2024-05-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大三最后一个学期的考试前一周<br>中午排了三刻钟的队才带回寝室的麦当劳<br>花上半个晚上的时间和室友一起玩的大乱斗<br>下楼倒垃圾时抬头从树叶间隙窥见皎洁的月<br>赶路时打趣的只言片语</p>
<p>从自己开始找实习、他们开始准备考研以来，已经很久没有度过这样无忧无虑纯粹享受快乐的夜晚了<br>没有作业，没有实验，没有考研，没有实习，仿佛单纯地从分针与秒针之间无限逼近的距离中扣出一小块，然后无限地拉长，又在下一个瞬间回归了正轨</p>
<p>常言道人生苦短，光影似箭<br>可往往只有如此这般肆意挥霍时间的片刻才能够成为支撑起一段人生经历的快照<br>如今我马上就不住在宿舍，这般玩乐的机会在将来也只会越来越少，一想到这里，纵使平时有再多的不满，此刻也都显得无关紧要<br>人们终究会如同行的旅伴一样分道扬镳，踏上各自的前程，也总要学会和过去一个阶段的自己做个告别，但往往时间如暗流般淌过，而自己却无法察觉；当不得不面对现实时，才发现为时已晚<br>我不知道将来的自己会成为什么样的人、结交什么样的人，在生活的重压下能否抽出如今夜般的片刻来和某人一道用欢笑声短暂地驱散愁绪<br>我只知道当下及过去这样仿佛永恒的热闹的日子，的确是马上就要结束了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/11/%E7%96%B2%E6%83%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/11/%E7%96%B2%E6%83%AB/" class="post-title-link" itemprop="url">疲惫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-11 22:36:24 / 修改时间：23:21:56" itemprop="dateCreated datePublished" datetime="2024-04-11T22:36:24+08:00">2024-04-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一个人急眼的时候，大多是被别人点出了自己不想承认的事实</p>
<p>如果说有什么是比「被大厂拒绝实习」更让人感到痛苦的，那莫过于「被小厂拒绝实习」了，前者姑且还能够用“世上大佬云集，我只是没有名列头部”这样的理由舔舐自己的伤口，后者几乎完全将自己虚伪的表皮剥了个一干二净。虽说「实际工作所需要用到的工具和知识，与学校传授的内容堪称云泥之别」这个事实我早就已经心安理得地接受了，但是最近接连不断受挫的笔试和面试让我不得不抱着失望的目光审视自己过去这两年半的学习经历</p>
<p>说实话，我其实打心底觉得自己是没什么学习计算机的天赋的，我很难像认识的一些大佬一样接连几个小时地coding并且乐此不疲，也很难想方设法地去创造有闪光点的idea然后用代码去实现——我并不是一个富有创造力的人，也没有坚持迎难而上的主观能动性。计算机是一个拥有「明确且理性的答案」的学科，因为机器总是正确的，为对不可知的事物抱有强烈恐惧的我很喜欢这一点，但也正因如此，我喜欢尽可能地使用已经存在于世界上的方式去理解、解决问题，而非另辟蹊径将自己的头脑风暴发挥到极致——后者对于coding来说往往更加重要，这实在是一件令人失望的事实</p>
<p>大一结束的时候我决定转到计科，一方面是对机械所涉及到的力学和材料实在提不起兴趣，另一方面是抱着对计算机的憧憬。说是为了「自身钱途」考虑也好，说是为了圆高中那个胎死腹中的coding梦也好，我义无反顾地冲进这片看不到边际的汪洋大海，以为自己能够闯出一片自己的小天地<br>然而事实是残酷的：我自认为在过去的两年半中并没有荒废自己的学业，始终尝试着学习新的技术，可当我立足于当下去回顾这段时间的经历，对自己的评价并没有比漫无目的地原地绕圈的无头苍蝇好多少，这就是另一件令人失望的事实——没有规划和明确目标的学习本质上是无用功，归根结底，与荒废两年半的时间殊途同归，在最终的效果上是一致的。也直到最近开始海投实习，我才对自己究竟应该做些什么、学些什么有一个大致的方向，但可惜已经太晚了：我那被分流拖垮的大一时光和身处迷茫四处撞墙的大二大三导致了如今一事无成的情景</p>
<p>ICPC的遗憾打铁，ASC的没有后文，以及寻找实习的失败，我想这大多都可以归咎于自己装模作样的假努力，不长也不短的coding生涯始终笼罩在失败的阴影下让我开始怀疑自己究竟是不是真的不太适合学计算机</p>
<p>可如果让我再回到大一做一次选择，我还是会头也不回地选择这个专业，我依然会回忆起初中那个被计算机和代码的力量震撼到的那个下午，和高中抱着向往却没有入坑的遗憾</p>
<p>可我没能够做到用未来的时光和努力来弥补过去的遗憾，如果前方终究只是一条用梦泡点缀着的看不到光亮道路，我究竟该如何说服自己在这条路上继续走下去呢……</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/25/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%EF%BC%9A%E4%BB%A5GMP%E4%B8%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/25/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%EF%BC%9A%E4%BB%A5GMP%E4%B8%BA%E4%BE%8B/" class="post-title-link" itemprop="url">进程、线程、协程：以GMP为例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-25 10:45:41 / 修改时间：13:31:19" itemprop="dateCreated datePublished" datetime="2024-03-25T10:45:41+08:00">2024-03-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GMP的原理与调度"><a href="#GMP的原理与调度" class="headerlink" title="GMP的原理与调度"></a>GMP的原理与调度</h1><h2 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h2><p>在早期的操作系统中，一个程序就是一个进程，只有当一个进程运行完，下一个进程才能够启动，一切都是串行的。这样的系统面临两个问题：</p>
<ol>
<li>执行流程单一</li>
<li>进程阻塞会导致CPU时间的浪费</li>
</ol>
<p>因此，后来OS加入了多进程并发：当一个进程阻塞，就会切换到其他就绪的进程，以避免浪费CPU时间</p>
<h2 id="线程和协程"><a href="#线程和协程" class="headerlink" title="线程和协程"></a>线程和协程</h2><p>多线程就是指一个进程中同时有多个线程正在执行</p>
<p>线程是一个基本的cpu执行单元，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，可以与同属于一个进程的其他线程共享进程所拥有的全部资源。引入线程之后，进程只作为除cpu以外系统资源的分配单元，线程则作为处理机的分配单元</p>
<p>而一个线程的实现又可以被划分为<strong>用户线程</strong>和<strong>内核线程</strong>，一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”(Linux 的 PCB 进程控制块)。因此，我们只需再做个分类，将内核态线程依然称为“线程”，而用户态线程就被称为“协程”</p>
<p>这也就涉及到了线程与协程之间的绑定关系：</p>
<ul>
<li><p>N:1 关系</p>
<p>N 个协程绑定 1 个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1 个进程的所有协程都绑定在 1 个线程上</p>
<blockquote>
<p>缺点：</p>
<ul>
<li>某个程序用不了硬件的多核加速能力</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了</li>
</ul>
</blockquote>
</li>
<li><p>1:1 关系</p>
<p>1 个协程绑定 1 个线程，这种最容易实现。协程的调度都由 CPU 完成了，不存在 N:1 缺点，</p>
<blockquote>
<p>缺点：</p>
<ul>
<li>协程的创建、删除和切换的代价都由 CPU 完成，有点略显昂贵了</li>
</ul>
</blockquote>
</li>
<li><p>M:N 关系</p>
<p>M 个协程绑定 1 个线程，是 N:1 和 1:1 类型的结合，克服了以上 2 种模型的缺点，但实现起来最为复杂</p>
</li>
</ul>
<p>协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go 为了提供更容易使用的并发方法，使用了 goroutine 和 channel。goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发</p>
<p>Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配</p>
<p>Goroutine 特点：</p>
<ul>
<li>占用内存更小（几 kb）</li>
<li>调度更灵活 (runtime 调度)</li>
</ul>
<h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><p>事实上goroutine的调度器因为开销、锁竞争、局部性等原因，曾经一度被废除过，而重新设计过后的就是现在的GMP模型</p>
<p>在新调度器中，出列 M (thread) 和 G (goroutine)，又引进了 P (processor处理器)</p>
<p>在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上，其中涉及到几个部分：</p>
<ul>
<li>全局队列（Global Queue）：存放等待运行的 G</li>
<li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列</li>
<li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个</li>
<li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去</li>
</ul>
<p>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行</p>
<h3 id="关于M和P的数量"><a href="#关于M和P的数量" class="headerlink" title="关于M和P的数量"></a>关于M和P的数量</h3><p>P 的数量：</p>
<ul>
<li>由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $​GOMAXPROCS 个 goroutine 在同时运行</li>
</ul>
<p>2、M 的数量:</p>
<ul>
<li>go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略</li>
<li>runtime&#x2F;debug 中的 SetMaxThreads 函数，设置 M 的最大数量</li>
<li>一个 M 阻塞了，会创建新的 M</li>
</ul>
<p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来</p>
<h3 id="关于M和P的创建时机"><a href="#关于M和P的创建时机" class="headerlink" title="关于M和P的创建时机"></a>关于M和P的创建时机</h3><p>P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P</p>
<p>2、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M</p>
<h2 id="调度器设计策略"><a href="#调度器设计策略" class="headerlink" title="调度器设计策略"></a>调度器设计策略</h2><p>为了减少线程的频繁创建和销毁，对于闲置的线程，GMP的策略是对其复用</p>
<ol>
<li><p>work stealing机制：</p>
<p>当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程</p>
</li>
<li><p>hand off机制：</p>
<p>当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行</p>
</li>
</ol>
<p>利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS &#x3D; 核数&#x2F;2，则最多利用了一半的 CPU 核进行并行</p>
<p>抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方</p>
<p>全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G</p>
<h2 id="go-func-的调用流程"><a href="#go-func-的调用流程" class="headerlink" title="go func()的调用流程"></a>go func()的调用流程</h2><ol>
<li>我们通过 go func () 来创建一个 goroutine</li>
<li>有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中</li>
<li>G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行</li>
<li>一个 M 调度 G 执行的过程是一个循环机制</li>
<li>当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P</li>
<li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中</li>
</ol>
<h3 id="特殊的M0和G0"><a href="#特殊的M0和G0" class="headerlink" title="特殊的M0和G0"></a>特殊的M0和G0</h3><ul>
<li><p>M0</p>
<p>M0是启动程序后的编号为 0 的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了</p>
</li>
<li><p>G0</p>
<p>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数，每个 M 都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/CMU15-445-2022Fall-Lecture-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/CMU15-445-2022Fall-Lecture-16/" class="post-title-link" itemprop="url">CMU15-445-2022Fall-Lecture-16</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-19 16:35:51 / 修改时间：16:36:31" itemprop="dateCreated datePublished" datetime="2024-03-19T16:35:51+08:00">2024-03-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-16-Two-Phase-Locking"><a href="#Lecture-16-Two-Phase-Locking" class="headerlink" title="Lecture 16: Two-Phase Locking"></a>Lecture 16: Two-Phase Locking</h1><p>本章主要介绍了数据库事务处理中的2-PL协议</p>
<p>上节课介绍了如何使用WW、WR、RW三种冲突来判断事物之间是否是串行化的，但是在现实中，这种方法是不切实际的，因为我们不可能提前预知所有事物到底什么时候到达，以及事务具体要做什么，而在现实生活中，事务有可能会源源不断地发送到数据库，这就意味着数据库每时每刻都需要将新的事务纳入串行化的判断范畴</p>
<p>因此需要一种协议来确保DBMS在不知道事务的具体内容、具体到达时间的情况下，依然能够作出正确的判断，2-PL协议就是一种通过合理地加锁来达到这种目的的协议</p>
<h1 id="Lock-Type"><a href="#Lock-Type" class="headerlink" title="Lock Type"></a>Lock Type</h1><p>首先需要再一次强调一下数据库中两种类型锁的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>Locks</th>
<th>Latches</th>
</tr>
</thead>
<tbody><tr>
<td>Separate</td>
<td>User transactions</td>
<td>Threads</td>
</tr>
<tr>
<td>Protect</td>
<td>Database Contents</td>
<td>In-Memory Data Structures</td>
</tr>
<tr>
<td>During</td>
<td>Entire Transactions</td>
<td>Critical Sections</td>
</tr>
<tr>
<td>Modes</td>
<td>Shared, Exclusive, Update, Intention</td>
<td>Read, Write</td>
</tr>
<tr>
<td>Handle deadlock by</td>
<td>Detection &amp; Resolution Waits-for, Timeout, Aborts</td>
<td>Avoidance Coding Discipline</td>
</tr>
<tr>
<td>Kept in</td>
<td>Lock Manager</td>
<td>Protected Data Structure</td>
</tr>
</tbody></table>
<p>本章关注的是Locks，其有两种基本类型：</p>
<ul>
<li>S-Lock：共享锁（读锁）</li>
<li>X-Lock：互斥锁（写锁）</li>
</ul>
<p>两者的兼容矩阵如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>S-LOCK (shared)</th>
<th>X-LOCK (exclusive)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>S-LOCK (shared)</strong></td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><strong>X-LOCK (exclusive)</strong></td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<p>从上节课我们可以知道，WW、WR、RW都可能导致事务冲突，因此只有RR的时候，两把锁是可以兼容的</p>
<p>DBMS有一个名为Lock Manager的模块，专门负责分配、回收事务的锁。每当事务申请加锁或者升级锁的时候，都需要向其发送请求，而Lock Manager内部还维护着一个Lock Table，记录每一个事务所持有的锁（在实验中以哈希表的形式呈现），Lock Manager会根据Lock Table上面的记录来判断是给该事务分配锁，还是拒绝请求，以此确保事务排列的正确性和并发性</p>
<h1 id="Two-Phase-Locking"><a href="#Two-Phase-Locking" class="headerlink" title="Two-Phase Locking"></a>Two-Phase Locking</h1><p>2-PL帮助数据库在运行过程中决定某个事务是否可以访问某条数据，并且 2PL 的正常工作并不需要提前知道所有事务的执行内容，仅仅依靠已知的信息即可</p>
<h2 id="Growing-amp-Shrinking"><a href="#Growing-amp-Shrinking" class="headerlink" title="Growing &amp; Shrinking"></a>Growing &amp; Shrinking</h2><p>这个协议定义了两个阶段：Growing 和 Shrinking</p>
<ul>
<li>在growing阶段，事务可以按需申请获取锁，Lock Manager可以决定分配与否</li>
<li>在shrinking阶段，事务就只能够释放锁，而不能够获取新的锁或者升级已有的锁,<strong>也就是说，一旦事务释放了锁，那么它就再也无法获得锁了</strong></li>
</ul>
<p>这样的协议保证了事物之间<strong>一定不会出现有向环路，也就是一定是可串行化的</strong>（具体证明可以参考[这篇文章](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59535337">Transaction management：两阶段锁（two-phase locking） - 知乎 (zhihu.com)</a>)）</p>
<h2 id="Cascading-Aborts"><a href="#Cascading-Aborts" class="headerlink" title="Cascading Aborts"></a>Cascading Aborts</h2><p>尽管2-PL能够确保事务之间的串行性，但其可能会引发一种新的问题：联级中止</p>
<p>如果T1产生了Abort，那么已经读取了T1写入数据的T2就变成了脏读，这种情况下，DBMS需要将有过脏读的事务也反馈为Abort，而这些中止可能进而使得其它正在进行的事务级联地中止，这个过程就是所谓的级联中止</p>
<h2 id="Strong-Strict-2-PL"><a href="#Strong-Strict-2-PL" class="headerlink" title="Strong Strict 2-PL"></a>Strong Strict 2-PL</h2><p>为了解决联级中止的问题，我们可以将2-PL进行改进，也被称为Rigorous 2-PL：</p>
<ul>
<li>growing阶段和2-PL相同</li>
<li>shrinking阶段，每一个事务<strong>只有在自身结束之后才能够释放所有的锁</strong>，无论最终该事务是提交还是中止</li>
</ul>
<p>通过比较Non-2PL、2PL和Rigorous-2PL，可以看出，三者的并发程度越来越低，但是安全性是越来越高的（其中2PL和Rigourous-2PL的安全性是一致的，但是2PL可能会引发联级中止）</p>
<h1 id="Deadlock-Detection-amp-Prevention"><a href="#Deadlock-Detection-amp-Prevention" class="headerlink" title="Deadlock Detection &amp; Prevention"></a>Deadlock Detection &amp; Prevention</h1><p>2PL协议无法解决死锁问题，和操作系统中常见的解决死锁问题的方法一样，可以从事后检测（Detection）和事前阻止（Prevention）来考虑</p>
<h2 id="Deadlock-Detection"><a href="#Deadlock-Detection" class="headerlink" title="Deadlock Detection"></a>Deadlock Detection</h2><p>DBMS会维护一张waits-for graph，用来记录多个事务之间的相互等待关系，一旦图中出现了环，那么DBMS就需要考虑如何去打破这个环</p>
<h3 id="Deadlock-Handling"><a href="#Deadlock-Handling" class="headerlink" title="Deadlock Handling"></a>Deadlock Handling</h3><p>当 DBMS 检测到死锁时，它会选择一个 “受害者” (事务)，将该事务回滚，打破环形依赖，而这个 “受害者” 将依靠配置或者应用层逻辑重试或中止。这里有两个设计决定：</p>
<ol>
<li>检测死锁的频率</li>
<li>如何选择合适的 “受害者”</li>
</ol>
<p>检测死锁的频率越高，陷入死锁的事务等待的时间越短，但消耗的 cpu 也就越多。所以这是个典型的 trade-off，通常有一个调优的参数供用户配置</p>
<p>选择 “受害者” 的指标可能有很多：事务持续时间、事务的进度、事务锁住的数据数量、级联事务的数量、事务曾经重启的次数等等。在选择完 “受害者” 后，DBMS 还有一个设计决定需要做：完全回滚还是回滚到足够消除环形依赖即可</p>
<h2 id="Deadlock-Prevention"><a href="#Deadlock-Prevention" class="headerlink" title="Deadlock Prevention"></a>Deadlock Prevention</h2><p>Deadlock prevention 是一种事前行为，采用这种方案的 DBMS 无需维护 waits-for graph，也不需要实现 detection 算法，而是在事务尝试获取其它事务持有的锁时直接决定是否需要将其中一个事务中止。</p>
<p>通常 prevention 会按照事务的年龄来赋予优先级，事务的时间戳越老，优先级越高。有两种 prevention 的策略： </p>
<ul>
<li>Old Waits for Young：如果 requesting txn 优先级比 holding txn 更高则等待后者释放锁；更低则自行中止</li>
<li>Young Waits for Old：如果 requesting txn 优先级比 holding txn 更高则后者自行中止释放锁，让前者获取锁，否则 requesting txn 等待 holding txn 释放锁</li>
</ul>
<p>无论是 Old Waits for Young 还是 Young Waits for Old，只要保证 prevention 的方向是一致的，就能阻止死锁发生，其原理类似哲学家就餐设定顺序的解决方案：先给哲学家排个序，遇到获取刀叉冲突时，顺序高的优先</p>
<h1 id="Lock-Granularity"><a href="#Lock-Granularity" class="headerlink" title="Lock Granularity"></a>Lock Granularity</h1><p>当事务在获取锁的时候，DBMS可以决定分配给它的锁的粒度（到底是给它锁住一整张表？还是一个tuple？还是一个page？），DBMS需要尽可能给事务分配最少的锁，并且在并行性和开销之间进行权衡（更少，但粒度更大的锁 vs. 更多，但粒度更细的锁）</p>
<h2 id="Intention-Locks"><a href="#Intention-Locks" class="headerlink" title="Intention Locks"></a>Intention Locks</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>意向锁是一种表级别的锁，用于表明事务将要对某个对象（表、页、行）加锁。它被用来表示一个事务在获取该对象的锁之前是否会先获取其他类型的锁</p>
<blockquote>
<p>来自百度百科的定义：</p>
<p>如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁</p>
</blockquote>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>那么为什么我们需要意向锁呢？举个例子：现在有事务A已经获取了表t的某一行的互斥锁，而此时表B想要获取这张表的表共享锁，由于两把锁互斥，所以B在试图对表t施加锁的时候必须保证：</p>
<ul>
<li>当前没有其他事务持有 users 表的排他锁</li>
<li>当前没有其他事务持有 users 表中任意一行的排他锁</li>
</ul>
<p>而为了确保第二个条件成立，B就需要检查表t的每一行进行判断。很明显效率非常低，而有了意向锁之后，情况就不一样了，我们只需要检查这张表的IS或者IX锁是否空闲，那么就能直接判断能够进行后续的加锁操作，类比来说，意向锁就是这张表所有锁的哨兵</p>
<h3 id="Lock-Types"><a href="#Lock-Types" class="headerlink" title="Lock Types"></a>Lock Types</h3><ul>
<li><p>Intention-Shared Lock</p>
<p>如果我们只需要读取表R的某些行，我们可以在这些行上加上S锁。对于整个表R, 表的任何行都可以被读取。这种情况下，可以给表R加上IS锁。从而，如果此时有另一个事务需要读取表R的某些行或是整个表R, 就能根据R上的IS锁直接做出判断，无需遍历表的每一行</p>
</li>
<li><p>Intention-Exclusive Lock</p>
<p>如果我们需要写表R的某些行，此时可以给表R加上IX锁以表达这个意思。例如，表R加上IX锁后，就不能申请R上的S锁，因为IX锁表明某个事务正在修改表R的某些行</p>
</li>
<li><p>Shared+Intention-Exclusive Lock</p>
<p>共享意向排它锁，是S锁和IX锁的结合，适用于以下场景：如果需要修改表中的某些行，但需要读取整个表，这时候就可以给整张表加上SIX锁。可以看到它与IX锁的区别：加入SIX锁后，不能修改表的其它行，因为需要读整张表。</p>
<p>在MySQL中，并没有SIX锁；但在Oracle、SQL Server中有这种锁，此类数据库有更为复杂的树状组织</p>
</li>
</ul>
<h3 id="Compatibility-Matrix"><a href="#Compatibility-Matrix" class="headerlink" title="Compatibility Matrix"></a>Compatibility Matrix</h3><p>这里给出意向锁、读写锁之间的兼容矩阵，竖为事务T1已经持有的锁，横为T2想要申请的锁：</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>SIX</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IS</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><strong>IX</strong></td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>SIX</strong></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="Locking-Protocol"><a href="#Locking-Protocol" class="headerlink" title="Locking Protocol"></a>Locking Protocol</h2><p>对于一个事务，其需要在数据库层次结构的最高一级获取合适的锁：</p>
<ul>
<li>如果想要获取一个结点的S或者IS锁，事务必须至少获取其双亲结点的IS锁</li>
<li>如果想要获取一个结点的X、IX或者SIX锁，则必须至少获取其双亲结点的IX锁</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/16/CMU15-445-2022Fall-Lecture-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/16/CMU15-445-2022Fall-Lecture-15/" class="post-title-link" itemprop="url">CMU15-445-2022Fall-Lecture-15</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-16 19:50:06 / 修改时间：19:50:23" itemprop="dateCreated datePublished" datetime="2024-03-16T19:50:06+08:00">2024-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-15-Concurrency-Control-Theory"><a href="#Lecture-15-Concurrency-Control-Theory" class="headerlink" title="Lecture 15: Concurrency Control Theory"></a>Lecture 15: Concurrency Control Theory</h1><p>主要介绍了并发控制的原理</p>
<h1 id="Transaction-Managment"><a href="#Transaction-Managment" class="headerlink" title="Transaction Managment"></a>Transaction Managment</h1><p>首先是一些常见的数据库事务上会出现的并发问题：</p>
<p>比如对于以下一系列操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Read(A)</span><br><span class="line">Check(A &gt; 25)</span><br><span class="line">Pay(25)</span><br><span class="line">A = A - 25</span><br><span class="line">Write(A)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果执行到A &#x3D; A - 25的时候，突然发生了断电，那么很有可能银行就收不到钱（这个其实和恢复系统有关系）</li>
<li>如果某个人同时执行了两个相同的该操作，则如果他们同时从数据库中读取了A&#x3D;100，最终A会变成75（即少扣了25）</li>
</ul>
<p>最基础最笨拙的解决这些问题的方式就是让数据库将所有的事务排成一个队列依次执行，只有当前一个事务执行完毕、数据写会，再执行下一个事务，但是这样就会丧失数据库的并发性，还会占用大量的存储（因为我们需要把整个数据库文件进行复制）</p>
<p>因此我们需要数据库支持并发控制，并且在此基础上要保证数据的正确性和公平性</p>
<h1 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h1><p>在正式开始之前，需要明确一下事务的定义。从正式一点的定义上来说，数据库是由一组组固定的命名对象A、B、C组成的，而事务就是对这些对象的一系列处理（比如说读写、插入、删除）</p>
<p>以Sql语言为例，事务的起点会显式地用BEGIN来表示，而结束一般由成功的提交（COMMIT）或者报错（ABORT），如果事务提交，数据库会保存事务所做的所有修改（或者引发报错）；而如果事务报错，那么所有修改都将不复存在，数据库会进行回滚操作</p>
<h1 id="Correctness-Criteria：ACID"><a href="#Correctness-Criteria：ACID" class="headerlink" title="Correctness Criteria：ACID"></a>Correctness Criteria：ACID</h1><p>事务的正确性标准被称为ACID</p>
<ul>
<li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败</li>
<li>一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态</li>
<li>隔离性（Isolation）：多个事务并发执行就像事务单独执行一样并不会相互影响</li>
<li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</li>
</ul>
<h2 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h2><p>事务只有两种可能的输出：提交和报错，要么完成所有的修改，要么所有的修改都不执行</p>
<p>那么该如何保证原子性：</p>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>日志技术几乎在所有的DBMS中都会被使用到，其中有UndoLog（回滚未提交的操作）和RedoLog（执行已经提交的操作）</p>
<p>DBMS在日志中按照顺序记录了事务所作出的所有修改，然后Undo所有报错事务已经执行了的操作</p>
<h3 id="Shadow-Paging"><a href="#Shadow-Paging" class="headerlink" title="Shadow Paging"></a>Shadow Paging</h3><p>在事务执行之前，DBMS首先复制相关的page，让事务修改其中的数据，当且仅当事务正确提交之后，这些page才会对外可见</p>
<h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p>如果 DBMS 在事务开始之前是 consistent，那么在事务执行完毕后也应当是 consistent</p>
<p>比如对于一个银行所使用的数据库，至少钱的数值不能小于100，如果a有90块钱，他想转100给b，此时，事务提交之前符合数据库的规则，但是在提交之后就不符合了，那么此时事务就不能够提交，这就是所谓的一致性</p>
<ul>
<li><p>数据库一致性：数据库中的数据是对现实世界中的模拟，并且满足约束的规则</p>
</li>
<li><p>事务一致性：事务执行前后数据库均满足一致性</p>
</li>
</ul>
<h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p>用户提交事务，不同事务执行过程应当互相隔离，互不影响，每个事务都认为只有自己在执行</p>
<h3 id="并发控制协议"><a href="#并发控制协议" class="headerlink" title="并发控制协议"></a>并发控制协议</h3><p>为了达到并发执行事务的目的，我们需要并发控制协议，包含两种锁</p>
<ul>
<li>乐观锁：假设事物之间的冲突是罕见的，当冲突发生之后再进行处理</li>
<li>悲观锁：事务执行时获取需要的锁，这样不会导致冲突的发生</li>
</ul>
<h3 id="事务并发顺序的正确性"><a href="#事务并发顺序的正确性" class="headerlink" title="事务并发顺序的正确性"></a>事务并发顺序的正确性</h3><p>为了保证结果的正确性，并发执行的顺序必须等同于某种串行的顺序</p>
<ul>
<li><strong>Serial Schedule</strong>：不同事务之间没有重叠，串行执行</li>
<li><strong>Equivalent Schedules</strong>：对于任意数据库起始状态，若两个调度分别执行所到达的数据库最终状态相同，则称这两个调度等价</li>
<li><strong>Serializable Schedule</strong>：如果一个 schedule 与事务之间的某种 serial execution 的效果一致，则称该 schedule 为 serializable schedule</li>
</ul>
<h3 id="事务冲突"><a href="#事务冲突" class="headerlink" title="事务冲突"></a>事务冲突</h3><p>两个不同的事务指向了同一个对象，如果其中一个对对象有写操作，则会产生冲突</p>
<ul>
<li>读写冲突：事务先A读取某行数据、事务B后修改该行数据，和事务B先修改某行事务、事务A后读该行记录两种schedule。事务A读到的结果不同。这种冲突可能会导致Unrepeatable Read（不可重复读，两次读取的数据可能不一样）和Dirty Read（脏读，一个事务读取了另一个事务还没有提交的数据）</li>
<li>写读冲突：读未提交（脏读）</li>
<li>写写冲突：Lost Update（更新丢失，一个事务将另一个事务的未提交的数据覆盖）</li>
</ul>
<h3 id="冲突串行化"><a href="#冲突串行化" class="headerlink" title="冲突串行化"></a>冲突串行化</h3><p>冲突的串行化执行可以通过一定的转换为某种串行化的结果</p>
<ul>
<li>两个 schedules 在 transactions 中有相同的 actions，且每组 conflicting actions 按照相同顺序排列，则称它们为 conflict equivalent</li>
<li>一个 schedule S 如果与某个 serial schedule 是 conflict equivalent，则称 S 是 conflict serializable</li>
<li>如果通过交换不同 transactions 中连续的 non-conflicting operations 可以将 S 转化成 serial schedule，则称 S 是 conflict serializable</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/14/%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/14/%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">如何用Redis实现消息队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-14 15:30:20 / 修改时间：22:11:44" itemprop="dateCreated datePublished" datetime="2024-03-14T15:30:20+08:00">2024-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是消息队列（MQ）"><a href="#什么是消息队列（MQ）" class="headerlink" title="什么是消息队列（MQ）"></a>什么是消息队列（MQ）</h1><p>顾名思义，将消息以队列的形式缓存，生产者（producer）和消费者（consumer）分别使用队列的两个端口进行消息的收发</p>
<h2 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h2><p>消息队列有两个核心能力：解耦和削峰</p>
<ul>
<li><p>解耦：</p>
<p>如果没有消息队列，那么在一次业务流程中，上游的http或者rpc发出请求之后，下游的消费者需要马上进行反馈，否则整个流程就会一直阻塞，这即浪费时间，又浪费CPU性能</p>
<p>因此我们需要一个能够持久化存放请求的容器，这就是消息队列的解耦——将生产者和消费者的应用进行解耦</p>
</li>
<li><p>削峰</p>
<p>如果在某一时刻，生产者给消费者生成了大量的请求，而消费者无法一次性全部消费，那么会产生消息的丢失</p>
<p>而有了消息队列，就可以分批次处理数量过多的请求</p>
</li>
</ul>
<h2 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h2><p>作为消息队列组件，需要满足一些要求：</p>
<ul>
<li><p>消息不丢失</p>
<p>很好理解，毕竟如果消息易失，那么有没有消息队列就都没太大区别了，这一方面可以分为三个部分来看待：</p>
<ul>
<li>生产者将消息投递到MQ的时候不出现丢失</li>
<li>消息存放在MQ时不丢失</li>
<li>消费者从MQ消费消息时不出现丢失</li>
</ul>
<p>针对第二点，各个MQ组件基本都是基于数据落盘+数据备份的方式来完成的</p>
<p>而对于第一第三点，则是通过两个交互环节中的ack机制保证的，譬如生产者向MQ中投递消息，如果没有收到MQ的ack返回确认，那么生产者就应当一直投递这个消息给MQ；另一方面，消费者也需要避免接收重复的消息，所以对于下游的消费者，同样需要具备消息幂等去重的能力</p>
</li>
<li><p>支持消息存储</p>
<p>就像前面提到的，MQ至少需要支持一定规模的数据的存放，而且这种存放需要持久性，能够让消费者自由选择时间进行消费操作</p>
</li>
</ul>
<h2 id="流程类型"><a href="#流程类型" class="headerlink" title="流程类型"></a>流程类型</h2><p>根据消费者的消费流程，MQ可以被分为两种类型：</p>
<ul>
<li><p>Push型：</p>
<p>指当生产者将消息投递到MQ时，由MQ主动将消息以推送的方式发送给各个订阅了的消费者</p>
</li>
<li><p>Pull型：</p>
<p>当MQ中存在消息时，由消费者主动执行拉取消息的操作来获取消息</p>
</li>
</ul>
<p>两种类型各有优劣，实际操作中需要按需取舍</p>
<h1 id="如何用Redis实现消息队列"><a href="#如何用Redis实现消息队列" class="headerlink" title="如何用Redis实现消息队列"></a>如何用Redis实现消息队列</h1><p>Redis虽然是一种非关系型数据库，但是其部分数据结构是能够支持实现消息队列组件的</p>
<h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p>首先需要指出可能存在的一些问题</p>
<ul>
<li><p>存储昂贵</p>
<p>由于Redis是基于内存实现的缓存中间件，所以存储消息容量的限制比较大</p>
</li>
<li><p>数据丢失</p>
<ul>
<li><p>由于Redis是基于内存实现的缓存中间件，所以不可避免地会产生丢失数据的风险（比如断电和宕机），虽然有rdb&#x2F;aof这种持久化机制，但是无法做到百分百安全</p>
</li>
<li><p>此外，Redis走的是ap高可用流派，数据的主从复制流程是异步的，主从切换时数据存在弱一致的问题</p>
</li>
</ul>
</li>
</ul>
<h2 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h2><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>一种比较容易想到的思路就是使用Redis的List结构，这是一个双向链表，天然契合MQ的队列模型，只需要使用LPUSH和RPOP进行消息的投递和读取即可</p>
<p>这种方法的缺点也是显而易见的：如果生产者生产消息的速度赶不上消费者的消费速度，那么消费者使用RPOP拉取消息的时候就会立刻返回空值nil，也就是说，需要消费者不断轮询地访问，这种高频的自旋对于CPU是一种无用的损耗；另一方面，如果让消费者每次轮询之后休眠一段时间，那么可能会导致消息处理不及时，也是我们不希望看到的情况</p>
<p>最理想的方案是：在List中有数据到达时，消费者马上能够意识到，并且处理数据，此外始终保持睡眠状态，也就是阻塞态</p>
<p>因此，我们可以使用Redis中的BRPOP指令来代替RPOP，即可弥补上述的缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP my_topic 0</span><br></pre></td></tr></table></figure>

<p>其中topic后面的数字代表阻塞等待时长，达到此阈值仍未获取数据时会返回nil；如果设置为 0 ，则代表没有这个超时限制</p>
<h3 id="局限性分析"><a href="#局限性分析" class="headerlink" title="局限性分析"></a>局限性分析</h3><p>尽管解决了阻塞问题，List仍然不能算是一个合格的消息队列组件，原因如下：</p>
<ul>
<li><p>无法支持发布&#x2F;订阅模式</p>
<p>显然List的消费者和生产者是一对一的，因为数据在POP出去之后就不复存在，只此一份，如果我们有多个消费者，每个都需要消费者所生产的数据，那么List就束手无策了</p>
</li>
<li><p>无法支持消费端ack机制</p>
<p>当消费者出现了宕机等意外，没有一种有效的手段告诉MQ消息处理失败的反馈，在这种情况下，一旦数据POP，就真的完全丢失了</p>
</li>
</ul>
<h2 id="Redis-pub-x2F-sub"><a href="#Redis-pub-x2F-sub" class="headerlink" title="Redis pub&#x2F;sub"></a>Redis pub&#x2F;sub</h2><p>为了解决无法支持发布&#x2F;订阅模式的问题，Redis提供了pub&#x2F;sub机制，全称为publisher&#x2F;subscriber</p>
<h3 id="具体方法-1"><a href="#具体方法-1" class="headerlink" title="具体方法"></a>具体方法</h3><p>pub&#x2F;sub模式会在两者之间建立一个用于实时通信的信道channel，在传递消息时，会根据channel查找到所有建立订阅关系的subscriber，一一传送消息</p>
<p>操作指令为：</p>
<blockquote>
<p>发布者：publish topic_name message</p>
<p>比如：publish my_new_message 今天天气怎么样</p>
<p>订阅者：subscribe topic_name</p>
<p>订阅者会使用阻塞模式进行监听，解决了List方法中的CPU浪费问题</p>
</blockquote>
<p>这里解释一下背后的原理：</p>
<ul>
<li>首先，消费方 subscriber 通过 subscribe 指令建立和指定 channel 之间的订阅关系. 这时在 redis 中会维护好 channel 和对应 subscriber 列表的映射关系，并在内存中为每个在线活跃的 subscriber 分配好一个缓冲区 buffer，用以承载后续到来的消息数据</li>
<li>接下来随着 publisher 执行 publish 指令，往对应 channel 中投递消息后，此时 redis 会实时查看 channel 对应 subscriber 名单，往每个 subscriber 的缓冲区 buffer 中推送这条数据</li>
<li>各执行了 subscribe 指令的 subscriber 会处于阻塞监听缓冲区 buffer 的状态，随着新数据到达，subscriber 会获取到这笔数据</li>
</ul>
<p>基于这个流程，我们能看出来，pub&#x2F;sub 对于 channel 以及 subscribers 之间的实时映射关系存在强依赖. 因此在操作的执行顺序上，我们需要保证先执行 subscribe 指令，再执行 publish 执行，否则前几笔 publish 投递的数据就会因为不存在 subscriber 而被直接丢弃</p>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>pub&#x2F;sub模式最大的优点就是实现了发布&#x2F;订阅能力，然而其缺点也很明显：关于消息丢失的处理</p>
<ul>
<li><p>缺乏ack机制：</p>
<p>与List相同，没有ack意味着pub&#x2F;sub模式依然没有办法提醒发布者消息处理的成功与否，无法执行消息的重放</p>
</li>
<li><p>缺乏消息储存能力</p>
<p>Redis的pub&#x2F;sub模式相当于golang中的无缓冲型channel，仅仅是维护了channel和subscribers之间的映射关系，每当消息来临，不会停留在channel中，而是直接送往映射的buffer中，所以会出现以下问题：</p>
<ul>
<li>subscriber 宕机：倘若某个 subscriber 中途宕机，则会被踢出名单，在恢复前的这段时间内，到达的消息都会彻底与这个 subscriber 无缘</li>
<li>Redis 宕机：每条 publish 的消息都会第一时间分发到 subscriber 对应的内存缓冲区中，而这个缓冲区是完全基于内存实现的易失性存储，一旦 Redis 服务端宕机，缓冲区中的数据就完全丢失且不可恢复了；此外，pub&#x2F;sub 模式下的消息数据不属于 Redis 中的基本数据类型，因此 redis 中的持久化机制 rdb 和 aof 对于 pub&#x2F;sub 中的数据是完全不生效的，数据丢失的可能性大幅度提高</li>
<li>subscriber消息积压：由于消息数据会被放在 Redis 侧各 subscriber 的缓冲区 buffer 中，这部分空间是相对有限的，一旦某个 subscriber 因为消费能力弱，导致 buffer 中的的数据发生积压，此时 Redis 很可能会自动把 subscriber 踢除下线，于是这部分数据也丢失了</li>
</ul>
<p>对于最后这一点，可以在redis.conf文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60s</span><br></pre></td></tr></table></figure>

<p>对应的含义是，倘若某个 subscriber 的缓冲区 buffer 大小达到 32MB，则 subscriber 会被踢下线；倘若缓冲区内数据量在连续 60s 内达到 8MB 大小，subscriber 也会踢下线</p>
</li>
</ul>
<h2 id="Redis-Streams"><a href="#Redis-Streams" class="headerlink" title="Redis Streams"></a>Redis Streams</h2><h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><p>首先需要介绍一下几个核心的操作指令，所有指令都可以在<a target="_blank" rel="noopener" href="https://redis.io/commands/">官方文档</a>中找到：</p>
<ul>
<li><p>生产消息：</p>
<p>使用该指令可以向topic中投放一组键值对消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD my_streams_topic * key1 value1</span><br><span class="line">&quot;1710412272535-0&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>My_streams_topic：topic名称</li>
<li>*：表示该消息自动生成唯一标识id，基于时间戳+自增序列号生成</li>
<li>Key1、value1:输入的键值对</li>
</ul>
</li>
<li><p>消费消息：</p>
<p>使用该指令可以从对应的topic中获取消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread [BLOCK] [Time] streams my_streams_topic 0-0</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710412272535-0&quot;</span><br><span class="line">         2) 1) &quot;key1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>BLOCK：表示是否使用阻塞消费模式</li>
<li>Time：如果加入BLOCK参数，那么此处需要填写time表示阻塞等待时间，超过这个时间就会返回nil；设置为0表示不设置超时阈值</li>
<li>streams：表示从一个streams对象读取消息</li>
<li>my_streams_topic：topic名称</li>
<li>0-0：表示从头开始消费；这里如果填写的是某条消息的id的话，就会从这条消息之后开始消费</li>
</ul>
</li>
</ul>
<p>此外streams支持发布&#x2F;订阅模式，可以保证消息被多个消费者组访问</p>
<ul>
<li><p>创建消费者组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATE my_streams_topic my_group 0-0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<ul>
<li>my_streams_topic：topic 名称</li>
<li>my_group：消费者组名称</li>
<li>0-0：从头开始消费</li>
</ul>
</li>
<li><p>基于消费者组消费信息：</p>
<p>同一份数据在同一个消费者组下只会被消费到一次. 不同消费者组各自能获取到独立完整的消息数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP my_group consumer1 BLOCK 0 STREAMS my_streams_topic &gt;</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710412272535-0&quot;</span><br><span class="line">         2) 1) &quot;key1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">      2) 1) &quot;1710413025712-0&quot;</span><br><span class="line">         2) 1) &quot;key2&quot;</span><br><span class="line">            2) &quot;value2&quot;</span><br><span class="line">      3) 1) &quot;1710413031719-0&quot;</span><br><span class="line">         2) 1) &quot;key3&quot;</span><br><span class="line">            2) &quot;value3&quot;</span><br><span class="line">      4) 1) &quot;1710413036009-0&quot;</span><br><span class="line">         2) 1) &quot;key4&quot;</span><br><span class="line">            2) &quot;value4&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>my_group: 消费者组名称</li>
<li>Consumer1：消费者名称</li>
<li>my_streams_topic：topic 名称</li>
<li>BLOCK 0: 采用阻塞等待的模式，0 代表没有超时上限</li>
<li>&gt;：读最新的消息 (尚未分配给某个 consumer 的消息)</li>
</ul>
<p>此外还有一种消费模式，读取的是已经分配给当前消费者，但是还未经确认的旧消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP my_group consumer1 BLOCK 0 STREAMS my_streams_topic 0-0</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710413250364-0&quot;</span><br><span class="line">         2) 1) &quot;key5&quot;</span><br><span class="line">            2) &quot;value5&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>0-0：标识读取已分配给当前 consumer ，但是还没经过 xack 指令确认的消息</li>
</ul>
<p><strong>&gt; 与 0-0，两者之间的区别在于，“&gt;”读取新消息，“0-0”读取旧消息</strong></p>
</li>
<li><p>确认消息：</p>
<p>通过 xack 指令，携带上消费者组、topic 名称以及消息 id，能够完成对某条消息的确认操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XACK my_streams_topic my_group 1710413250364-0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<ul>
<li>my_streams_topic：topic 名称</li>
<li>my_group：消费者组名称</li>
<li>1710413250364-0：消息 id</li>
</ul>
</li>
</ul>
<h2 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><p>首先是最明显的优点：</p>
<ul>
<li><p>支持发布&#x2F;订阅模式</p>
<p>Redis Streams 引入了消费者组 group 的概念，因此是能够保证各个消费者组 consumer group 均能够获取到一份独立而完整的消息数据</p>
</li>
<li><p>数据可持久化</p>
<p>Redis 中的 streams 和 string、list 等数据类型一样，都能够通过 rdb( redis database)、aof( append only file) 的持久化机制进行落盘存储，能够在很大程度上降低数据丢失的概率</p>
</li>
<li><p>支持消费端 ack 机制</p>
<p>Redis Streams 中另一项非常重要的改进，是支持 consumer 的 ack 能力，consumer 在处理好某条消息后，能通过 xack 指令对该消息进行确认。这样对于没经过 ack 确认的消息，Redis Streams 还是为 consumer 保留了重新消费的能力</p>
</li>
<li><p>支持消息缓存</p>
<p>和 pub&#x2F;sub 模式不同的是，Redis Streams 中会实际开辟内存空间用于存储 Streams 中的数据，因此哪怕某个 consumer group 是在消息生产之后才完成注册操作，也能够进行消息溯源，从 topic 起点开始执行消息的消费操作</p>
<p>然而由于Redis是基于内存实现的存储，因此如果消息量过于庞大，可能会造成很大的资源压力甚至out of memory。因此，可以在XADD指令中加上maxlen，显式地设定topic中能缓存的数据长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD my_topic MAXLEN 10000 * key1 value1</span><br></pre></td></tr></table></figure>

<ul>
<li>最多缓存10000条数据</li>
</ul>
</li>
</ul>
<h1 id="整体对比"><a href="#整体对比" class="headerlink" title="整体对比"></a>整体对比</h1><p>现在对Redis实现MQ的各个方法做个比较：</p>
<table>
<thead>
<tr>
<th><strong>MQ 实现方案</strong></th>
<th><strong>发布&#x2F;订阅能力</strong></th>
<th><strong>消费端ACK机制</strong></th>
<th><strong>消息缓存能力</strong></th>
<th><strong>数据丢失风险</strong></th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>低</td>
</tr>
<tr>
<td>pub&#x2F;sub</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>高</td>
</tr>
<tr>
<td>Streams</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>低</td>
</tr>
</tbody></table>
<p>可以看到，在各项能力上 List 和 pub&#x2F;sub 互有千秋，而 Streams 可以说是兼具了各方面的优势，称得上是已经趋近于成熟的MQ实现方案</p>
<p>下面我们再进一步拿 Redis Streams 和业界专业的 MQ 组件进行对比</p>
<table>
<thead>
<tr>
<th><strong>MQ组件</strong></th>
<th><strong>消息存储介质</strong></th>
<th><strong>消息分区&#x2F;并发能力</strong></th>
<th><strong>数据丢失风险</strong></th>
<th><strong>运维成本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Redis Streams</td>
<td>内存</td>
<td>不支持</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>Kafka</td>
<td>磁盘</td>
<td>支持</td>
<td>理论上不存在</td>
<td>偏高</td>
</tr>
</tbody></table>
<p>由于Redis Streams在存储上需要使用内存，因此消息存储容量相对有限；且同一个 topic 的数据由于对应为同一个 key，因此会被分发到相同节点，无法实现数据的纵向分治，因此不具备类似于 kafka 纵向分区以提高并发度的能力</p>
<p>因此使用Redis作为MQ的主要优势就在于运维成本低，如果在实际的业务流程中，对于数据的精度没有特别高的要求，那么使用Redis Streams这种轻量化的MQ方案不失为一种好的选择</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/29/CMU15-445-2022Fall-Lecture-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/29/CMU15-445-2022Fall-Lecture-14/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-29 12:22:46 / 修改时间：12:25:04" itemprop="dateCreated datePublished" datetime="2024-02-29T12:22:46+08:00">2024-02-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-14-Query-Planning-amp-Optimization"><a href="#Lecture-14-Query-Planning-amp-Optimization" class="headerlink" title="Lecture 14: Query Planning &amp; Optimization"></a>Lecture 14: Query Planning &amp; Optimization</h1><p>主要讲了查询的规划以及优化</p>
<p>SQL查询在不同的规划下会有显著的性能上的差异，在先前介绍Join的那一章课已经提到过了</p>
<h1 id="Query-Optimization-Techniques"><a href="#Query-Optimization-Techniques" class="headerlink" title="Query Optimization Techniques"></a>Query Optimization Techniques</h1><p>需要注意的是，决定优化的方式、规模与执行查询一样是需要占用时间的，所以查询的优化不在于要做到极致（Query Optimization是一个NP-Hard问题），而是在可能的几个计划之中选取折中的一个</p>
<ul>
<li><p>Heuristics&#x2F;Rules：</p>
<ul>
<li><p>Rewrite the query to remove stupid&#x2F;inefficient things</p>
</li>
<li><p>Does not require a cost model</p>
</li>
</ul>
</li>
<li><p>Cost-based Search</p>
<ul>
<li>Use a cost model to evaluate multiple equivalent plans and pick the one with the lowest cost</li>
</ul>
</li>
</ul>
<h2 id="Logical-VS-Physical-Plans"><a href="#Logical-VS-Physical-Plans" class="headerlink" title="Logical VS. Physical Plans"></a>Logical VS. Physical Plans</h2><p>其实优化查询无非两个步骤：在逻辑上对操作对象进行编排（比如是Join(A,B)还是Join(B,A)，是否要下移谓词等等）、要选择用哪种方式来优化（比如对于nested loop join，是否要更换为nested index join，sort+limit是否要更换为topn算法等等），这就是所谓的逻辑计划与物理计划</p>
<h2 id="Heuristics-x2F-Rules"><a href="#Heuristics-x2F-Rules" class="headerlink" title="Heuristics&#x2F;Rules"></a>Heuristics&#x2F;Rules</h2><p>如果两个关系代数表达式 (Relational Algebra Expressions) 如果能产生相同的 tuple 集合，我们就称二者等价。DBMS 可以通过一些 Heuristics&#x2F;Rules 来将关系几何表达式转化成成本更低的等价表达式，从而达到查询优化的目的。这些规则通常试用于所有查询，如：</p>
<ul>
<li>Predicate Pushdown</li>
<li>Projections Pushdown</li>
</ul>
<h3 id="Predicate-Pushdown"><a href="#Predicate-Pushdown" class="headerlink" title="Predicate Pushdown"></a>Predicate Pushdown</h3><p>Predicate 通常有很高的选择性，可以过滤掉许多无用的数据。将 Predicate 推到查询计划的底部，可以在查询开始时就更多地过滤数据</p>
<p>核心思想如下：</p>
<ul>
<li>越早过滤越多数据越好</li>
<li>重排 predicates，使得选择性大的排前面</li>
<li>将复杂的 predicate 拆分，然后往下压，如 <code>X=Y AND Y=3</code> 可以修改成 <code>X=3 AND Y=3</code></li>
</ul>
<h3 id="Replace-Cartesian-Product"><a href="#Replace-Cartesian-Product" class="headerlink" title="Replace Cartesian Product"></a>Replace Cartesian Product</h3><p>将笛卡尔积替换成Join，不多赘述</p>
<h3 id="Projections-Pushdown"><a href="#Projections-Pushdown" class="headerlink" title="Projections Pushdown"></a>Projections Pushdown</h3><p>在行存储数据库中，越早过滤掉不用的字段越好，因此将 Projections 操作往查询计划底部推也能够缩小中间结果占用的空间大小</p>
<p><strong>需要注意的是这种方法对于列存储数据库是不管用的</strong></p>
<h2 id="Cost-based-Search"><a href="#Cost-based-Search" class="headerlink" title="Cost-based Search"></a>Cost-based Search</h2><p>除了 Predicates 和 Projections 以外，许多操作没有通用的规则，如 Join：Join 操作既符合交换律又符合结合律，等价关系代数表达式数量庞大，这时候就需要一些成本估算技术，将过滤性大的表作为 Outer Table，小的作为 Inner Table，从而达到查询优化的目的</p>
<p>由于需要遍历各种类型的plan来决定最终的选择，所以这里可以简单划分成三种类型的plan：</p>
<ul>
<li>Single relation</li>
<li>Multiple relations</li>
<li>Nested sub-queries</li>
</ul>
<h3 id="Single-relation-Query-Planning"><a href="#Single-relation-Query-Planning" class="headerlink" title="Single relation Query Planning"></a>Single relation Query Planning</h3><p>对于这类查找，只需要用简单的启发式方法譬如顺序扫描、二分搜索、索引扫描等就够用了</p>
<p>具体来说就是将查询拆分成若干个小块，为每一块都生成一个逻辑运算符，为每一个逻辑运算符都生成一组物理运算符，然后依次迭代构建一棵left-deep join tree（就是类似于哈夫曼树一样的结构，两个节点由join作为父节点），这样可以最小化工作量</p>
<p>这里直接去看课上那个Artist、Album、Appears的例子更加直观，整个搜索的过程就是在不断地[枚举、计算代价]</p>
<h3 id="Multi-relation-Query-Planning"><a href="#Multi-relation-Query-Planning" class="headerlink" title="Multi-relation Query Planning"></a>Multi-relation Query Planning</h3><p>又分为自顶向下与自底向上两种优化方式，这里重点讲了自顶向下的思路</p>
<blockquote>
<p> 比如一个操作的目标是<code>A join B join C</code>，这是我们的目标，也是优化的根节点。接下来需要考虑有哪些方法可以得到这个根节点，比如可以选择<code>Hash_Join(A join B, C)</code>或者<code>SM_Join(A join B, C)</code>两者之间选择一个代价更小的（这里假设hash join代价更小），然后继续决策有哪些方法可以得到hash join这个节点</p>
</blockquote>
<h3 id="Nested-Sub-Queries"><a href="#Nested-Sub-Queries" class="headerlink" title="Nested Sub-Queries"></a>Nested Sub-Queries</h3><p>有的时候一个查询的嵌套太深，如果对于每一个嵌套都分别优化，而没有一个整体的优化方向的话，最终会导致计划十分低效。因此可以考虑将一个嵌套查询扁平化，或者至少减少其嵌套层数，尽可能水平展开</p>
<p>这就延伸出了两种方法：</p>
<ul>
<li>重写查询，降低语句之间的关联性或者将其扁平化</li>
<li>分解嵌套查询，将其结果保存在临时的表中</li>
</ul>
<h4 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h4><p>直接举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select name from sailors as s</span><br><span class="line">	where exists(</span><br><span class="line">		select * from reservers as r</span><br><span class="line">  		where s.sid = r.sid</span><br><span class="line">  		and r.day = &#x27;2022.1.1&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以被改写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name from sailors as s, reservers as r</span><br><span class="line">	where s.sid = r.sid </span><br><span class="line">		and r.day = &#x27;2022.1.1&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Decomposing-Queries"><a href="#Decomposing-Queries" class="headerlink" title="Decomposing Queries"></a>Decomposing Queries</h4><p>同样举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT S.sid, MIN(R.day)</span><br><span class="line"> 	FROM sailors S, reserves R, boats B</span><br><span class="line">		WHERE S.sid = R.sid</span><br><span class="line"> 			AND R.bid = B.bid</span><br><span class="line"> 			AND B.color = &#x27;red&#x27;</span><br><span class="line"> 			AND S.rating = (SELECT MAX(S2.rating)</span><br><span class="line"> 		FROM sailors S2)</span><br><span class="line">	GROUP BY S.sid</span><br><span class="line">		HAVING COUNT(*) &gt; 1</span><br></pre></td></tr></table></figure>

<p>可以改写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(rating) FROM sailors</span><br><span class="line"></span><br><span class="line">SELECT S.sid, MIN(R.day)</span><br><span class="line"> 	FROM sailors S, reserves R, boats B</span><br><span class="line">		WHERE S.sid = R.sid</span><br><span class="line"> 			AND R.bid = B.bid</span><br><span class="line"> 			AND B.color = &#x27;red&#x27;</span><br><span class="line"> 			AND S.rating = (SELECT MAX(S2.rating)</span><br><span class="line"> 		FROM sailors S2)</span><br><span class="line">	GROUP BY S.sid</span><br><span class="line">		HAVING COUNT(*) &gt; 1</span><br></pre></td></tr></table></figure>

<p>毕竟<code>(SELECT MAX(S2.rating)</code>对于整个查询来说只是一个常量</p>
<h3 id="Cost-Estimation"><a href="#Cost-Estimation" class="headerlink" title="Cost Estimation"></a>Cost Estimation</h3><p>一个查询需要花费多长时间，取决于许多因素 </p>
<ul>
<li>CPU: Small cost; tough to estimate</li>
<li>Disk: #block transfers</li>
<li>Memory: Amount of DRAM used</li>
<li>Network: #messages</li>
</ul>
<p>但本质上取决于：<strong>整个查询过程需要读入和写出多少 tuples</strong></p>
<p>因此 DBMS 需要保存每个 table 的一些统计信息，如 attributes、indexes 等信息，有助于估计查询成本。值得一提的是，不同的 DBMS 的搜集、更新统计信息的策略不同</p>
<h3 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h3><p>对于任意table R，DBMS都保存了关于R的一些相关信息比如：</p>
<ul>
<li>$$N_{R}$$：R中tuple的数量</li>
<li>$$V(A, R)$$：R中A属性的不同取值的个数</li>
<li>$$A_{max}, A_{min}$$：A属性的最大值和最小值</li>
</ul>
<p>利用上面这些数据可以得到R中A属性的每一个值所对应的平均记录个数<br>$$<br>SC(A, R) &#x3D;N_R &#x2F; V(A, R)<br>$$<br>利用以上信息，就可以针对不同的predicate，预估不同的selectivity：</p>
<ul>
<li>Equality</li>
<li>Range</li>
<li>Negation</li>
<li>Conjunction</li>
<li>Disjunction</li>
</ul>
<h4 id="Equality-Predicate"><a href="#Equality-Predicate" class="headerlink" title="Equality Predicate"></a>Equality Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from people where age = 2</span><br></pre></td></tr></table></figure>

<p>假设people中有5个人，所有的age一共有5个取值，则$$N_R$$&#x3D;5，$$V(age, people)$$&#x3D;5：<br>$$<br>sel(A &#x3D; constant) &#x3D; SC(P) &#x2F; V(A, R) &#x3D; \frac{1}{5}<br>$$</p>
<h4 id="Range-Predicate"><a href="#Range-Predicate" class="headerlink" title="Range Predicate"></a>Range Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from people where age &gt;= 2</span><br></pre></td></tr></table></figure>

<p>则可以利用最大值最小值来估计：<br>$$<br>sel(A &gt;&#x3D; a) &#x3D; (A_{max} - a) &#x2F; (A_{max} - A_{min})<br>$$</p>
<h4 id="Negation-Predicate"><a href="#Negation-Predicate" class="headerlink" title="Negation Predicate"></a>Negation Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from people where age != 2</span><br></pre></td></tr></table></figure>

<p>其实就是Equality Predicate取个补集<br>$$<br>sel(not P) &#x3D; 1 - sel(P) &#x3D; 1 - SC(age &#x3D; 2) &#x3D; \frac{4}{5}<br>$$</p>
<h4 id="Conjunc-Predicate"><a href="#Conjunc-Predicate" class="headerlink" title="Conjunc Predicate"></a>Conjunc Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from people </span><br><span class="line">	where age = 2</span><br><span class="line">		and name like &#x27;A%&#x27;</span><br></pre></td></tr></table></figure>

<p>如果两个predicate是相互独立的话<br>$$<br>sel(P1 \bigwedge P2) &#x3D; sel(P1) \times sel(P2)<br>$$</p>
<h4 id="Disjunction-Predicate"><a href="#Disjunction-Predicate" class="headerlink" title="Disjunction Predicate"></a>Disjunction Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from people </span><br><span class="line">	where age = 2</span><br><span class="line">		or name like &#x27;A%&#x27;</span><br></pre></td></tr></table></figure>

<p>如果两个predicate相互独立，则有：<br>$$<br>sel(P1 \bigvee P2) &#x3D; sel(P1) + sel(P2) - sel(P1 \bigwedge P2) &#x3D; sel(P1) + sel(P2) - sel(P1) \times sel(P2)<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-12-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-12-13/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 12.13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:49:20 / 修改时间：13:00:25" itemprop="dateCreated datePublished" datetime="2024-02-28T12:49:20+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-12-13-Query-Execution"><a href="#Lecture-12-13-Query-Execution" class="headerlink" title="Lecture 12,13: Query Execution"></a>Lecture 12,13: Query Execution</h1><p>主要讲了SQL语句查询执行的相关问题</p>
<h1 id="Processing-Model"><a href="#Processing-Model" class="headerlink" title="Processing Model"></a>Processing Model</h1><p>首先是处理模型，定义了数据库中执行查询计划的三种模式，分别是：</p>
<ul>
<li>Iterator Model</li>
<li>Materialization Model</li>
<li>vectorization Model</li>
</ul>
<h2 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h2><p>又被称为Volcano Model或者Pipeline Model</p>
<ul>
<li><p>Iterator Model一共有三种基本的接口：Next()、Open()、Close()</p>
</li>
<li><p>该计算将关系代数中的每一种操作都抽象为一个operator，将整个SQL语句构造成一个operator树，这样一来，在进行查询的时候会从树顶向下不断调用next函数，而数据则会被自底向上拉取</p>
</li>
<li><p>迭代模型的优点：</p>
<ul>
<li>简单，每个operator可以单独实现逻辑，达到模块化处理，因此市面上有很多数据库都使用了迭代模型比如：SQLite、MongoDB、Impala、DB2、SQLServer、Greenplum、PostgreSQL、Oracle、MySQL</li>
</ul>
</li>
<li><p>迭代模型的缺点：</p>
<ul>
<li>查询树调用的Next接口次数太多，而且每次调用都指返回一条数据，使得CPU执行效率很低</li>
<li>Join、Subqueries、Order by等操作经常会阻塞</li>
</ul>
</li>
</ul>
<h2 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h2><p>物化模型优化了迭代模型的缺点：对于每一个operator，一次性处理所有的输入，处理完之后将所有结果一次性输出</p>
<p>伪代码看上去和火山模型大差不差，区别只在于每一个operator都会将结果放到一个out列表中，最后进行输出</p>
<ul>
<li>物化模型对于OLTP负载更加友好，因为每一个查询所涉及到的数据范围都是较小的，并且调用的函数更少</li>
<li>因此从另一方面来说，物化模型不适用于OLAP负载（因为OLAP涉及到的中间数据太多）</li>
</ul>
<h2 id="Vectorization-Model"><a href="#Vectorization-Model" class="headerlink" title="Vectorization Model"></a>Vectorization Model</h2><p>向量化模型与火山模型类似，对于每一种operator都要实现一种Next()函数，区别在于，向量化模型返回的是一批tuple，而不是火山模型中的一个tuple，可以简单理解成火山模型与物化模型两者的结合</p>
<p>该模型适用于OLAP数据库，使得中间的结果不需要溢出到磁盘，同时也能够减少Next函数的调用次数</p>
<h1 id="Access-Methods"><a href="#Access-Methods" class="headerlink" title="Access Methods"></a>Access Methods</h1><p>在执行查找的时候，DBMS需要一定的手段去访问叶子结点处的数据</p>
<p>一共可以分为三种方法</p>
<h2 id="Sequential-Scan"><a href="#Sequential-Scan" class="headerlink" title="Sequential Scan"></a>Sequential Scan</h2><p>最容易想到的就是顺序扫描：对于表中的每一个page，DBMS都从缓冲池中对其进行检索，并在此基础上遍历每一个tuple来决定是否要将其作为数据进行返回</p>
<ul>
<li>DBMS会保存一个游标（cursor），用来标记其上次访问的page&#x2F;slot</li>
</ul>
<h3 id="Sequential-Scan-Optimization"><a href="#Sequential-Scan-Optimization" class="headerlink" title="Sequential Scan : Optimization"></a>Sequential Scan : Optimization</h3><p>尽管顺序扫描是一种比较笨拙的方法，但可能也是我们唯一的选择</p>
<p>然而顺序扫描是可以进行优化的，我们在之前的课中已经接触过一些了，比如：</p>
<ul>
<li>Pre-Fetching（Lecture 6）</li>
<li>Buffer Pool Bypass（Lecture 6）</li>
<li>Parallelization（Lecture 13）</li>
<li>Heap Clustering（Lecture 8）</li>
<li>Late Materialization（Lecture 11）</li>
</ul>
<p>这节课讲了一个新的方法，Data Skipping</p>
<h4 id="Data-Skipping"><a href="#Data-Skipping" class="headerlink" title="Data Skipping"></a>Data Skipping</h4><p>有两种方法可以实现数据跳过组件：</p>
<ol>
<li><p>Approximate Queries（Lossy）</p>
<p>近似查询会首先对整张表做一个抽样，形成一个表的子集，对这个子集执行查询，这样能够得到一个近似的结果</p>
<p>近似查询是易失性的，这里的易失性应该是指会丢失一些本来应到能够找到的数据</p>
</li>
<li><p>Zone Map（Lossless）</p>
<p>这里重点介绍的方法就是Zone Map法，简单来说就是对于查询涉及到的每一个page，都实现处理出一些聚合属性，比如这个page上的MAX、MIN、AVG、SUM、COUNT，这样在查询到来的时候就能够直接进行比较，判断是否值得花时间遍历这个page，达到加速的效果</p>
<blockquote>
<p>比如现在我们有如下数据，我们要执行<code>select * from table where val &gt; 600</code>，DBMS拿到了查询指令和Zone Map进行比较，发现这个page的MAX值为400，显然整个page的数据都是我们不需要的，那么直接跳过这个page即可</p>
</blockquote>
</li>
</ol>
<h2 id="Index-Scan"><a href="#Index-Scan" class="headerlink" title="Index Scan"></a>Index Scan</h2><p>由DBMS来选择一个index来查找tuple（13章会详细解释DBMS根据哪几个方面的来选择index）</p>
<ul>
<li>索引扫描又分为单索引扫描和多索引扫描（Multi-Index Scan），两者的区别和特点从名字就可以看出来，需要知道的是，多索引扫描会根据查询条件，在多个索引上查询结果并且将结果集合做一个并集或者交集</li>
</ul>
<h1 id="Modification-Queries"><a href="#Modification-Queries" class="headerlink" title="Modification Queries"></a>Modification Queries</h1><p>负责修改数据库中的表以及相关索引的操作称为修改查询，这些查询的输出可以是数据记录的id，也可以是tuple（比如returning）</p>
<p>这里首先介绍了Halloween Problem（万圣节难题）：</p>
<p>譬如在火山模型的数据库中执行更新操作<code>update people set salary = salary + 100 where salary &lt; 1100</code>的时候，会首先根据index，调用Next（）查找出来目标tuple，删除、重新赋值、插入，由此完成更新</p>
<p>然而如果有一个tuple为：（Andy，999），在被更新之后会变成（andy，1099），此时这个tuple的物理位置已经改变，很有可能会被插入到原本位置之后，并且依然满足salary &lt; 1100的条件，所以会被第二次进行更新，变为（Andy，1199），这并不符合我们更新操作的目的</p>
<p>解决办法就是：跟踪所有修改过的记录id</p>
<h1 id="Expression-Evaluation"><a href="#Expression-Evaluation" class="headerlink" title="Expression Evaluation"></a>Expression Evaluation</h1><p>对于Where子句，DBMS会将其表示为一棵表达式树（expression tree），树中的不同结点代表不同的表达式类型例如：比较、析取、连接、算术运算符、常值、元祖属性引用等</p>
<p>还介绍了Prepare子句，类似于函数的功能</p>
<p>这一部分感觉就是普通的介绍，没有做很深入的讲解，看看就行</p>
<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>迄今为止我们所讨论的内容几乎都是基于数据流的角度来看待查询处理模型的，控制流以隐式的形式藏在一系列的查询操作中</p>
<p>而有了scheduler（调度器），我们就可以显式地明确控制流了</p>
<blockquote>
<p>以下是个人理解：</p>
<p>面向数据流是一件很复杂的事情，因为你没有办法非常细致地划分数据。比如人脑是没有办法清晰地认知：这一团数据是从哪里来的、要对它做什么、要把它发到哪里去之类的问题</p>
<p>但是面向控制流就会让上述的事情变得很简单明了，是一种抽象程度更高的方法，此外可能对于分布式存储的系统更加友好？因为可以将每一个控制任务push或者pull到远程主机做处理然后再传输回来，比单纯发送数据的方式封装程度更高？</p>
</blockquote>
<hr>
<h1 id="Parallel-x2F-Distributed"><a href="#Parallel-x2F-Distributed" class="headerlink" title="Parallel &#x2F; Distributed"></a>Parallel &#x2F; Distributed</h1><p>首先需要区分并行数据库和分布式数据库：</p>
<ul>
<li><p>首先需要明确的是，对于用户而言，两者是一样的，即对于某个查询返回某种结果，区别在于其内部设计</p>
</li>
<li><p>Parallel DBMSs：</p>
<ul>
<li>结点资源在物理上离得很近</li>
<li>结点资源通过高速互联进行通信</li>
<li>通信开销小并且是可靠的</li>
</ul>
</li>
<li><p>Distributed DBMSs：</p>
<ul>
<li>结点资源之间的物理位置相距远</li>
<li>结点资源通过低速互联进行通信</li>
<li>无法忽视结点之间的通信开销</li>
</ul>
</li>
</ul>
<h1 id="Process-Model"><a href="#Process-Model" class="headerlink" title="Process Model"></a>Process Model</h1><p>过程模型定义了系统将为何种架构以处理并发的请求&#x2F;查询，其中，Worker负责执行一个单独的任务并且返回结果，是DBMS中的一个组件</p>
<p>而模型的不同点就在于Worker的形式</p>
<h2 id="Process-per-Worker"><a href="#Process-per-Worker" class="headerlink" title="Process per Worker"></a>Process per Worker</h2><p>第一种形式是进程模型：给每一个Worker都分配一个进程，由OS负责调度，对于一个查询中的每一个operator，都交给一个Worker来负责执行</p>
<p>在线程的思想流行之前诞生的很多数据库都是用了这种模型</p>
<p>优点是：其中一个进程的崩溃并不会影响整个系统的崩溃</p>
<p>缺点是：极度依赖OS的调度，DBMS没有办法做到自行调度工作</p>
<h2 id="Thread-per-Worker"><a href="#Thread-per-Worker" class="headerlink" title="Thread per Worker"></a>Thread per Worker</h2><p>第二种是线程模型：以线程的形式管理每一个Worker，是如今常用的数据库并行处理模型，DBMS能够主动控制线程的调度，调度算法能够更加灵活</p>
<p>线程相对于进程的区别，即为线程模型相对于进程模型的优点和缺点——减少了进程带来的上下文切换、相比创建&#x2F;销毁一个进程，创建&#x2F;销毁一个线程的开销更小、不用管理公共内存；与此同时，一个线程的崩溃也会导致整个系统的崩溃</p>
<blockquote>
<p>关于Scheduling</p>
<p>对于每一个查询计划，DBMS都要决定执行的时间、地点和方式</p>
<p>需要考虑这个查询需要用到多少个Worker？需要用多少个CPU？这个查询需要在哪个CPU上处理？输出要保存在哪里？等等问题</p>
<p>因此DBMS知道的内容（比如上下文相关的信息）总是要比OS多一些</p>
</blockquote>
<h2 id="Embedded-DBMS"><a href="#Embedded-DBMS" class="headerlink" title="Embedded DBMS"></a>Embedded DBMS</h2><p>最后一种方式是嵌入式，DBMS与应用程序运行在同一地址空间，由应用程序来负责线程和调度（这一部分没怎么看懂）</p>
<h1 id="Inter-VS-Intra-Query-Parallelism"><a href="#Inter-VS-Intra-Query-Parallelism" class="headerlink" title="Inter- VS. Intra-Query Parallelism"></a>Inter- VS. Intra-Query Parallelism</h1><p>这里提出了两种并行化的思想的大概内容，姑且将其翻译为查询内并行性和查询间并行性</p>
<h2 id="Inter-Query"><a href="#Inter-Query" class="headerlink" title="Inter-Query"></a>Inter-Query</h2><p>查询内并行性通过允许多个查询同时进行从而提高整体性能</p>
<p>如果查询都是只读的，那么没有必要显式地协调查询与查询之间的先后，必要时，buffer pool可以处理大部分共享</p>
<p>然而如果有多个查询在同时更新数据库，那么将会很难保持正确性，这个问题会在Lecture 15讨论事务相关内容的时候提及</p>
<h2 id="Intra-Query"><a href="#Intra-Query" class="headerlink" title="Intra-Query"></a>Intra-Query</h2><p>通过并行执行运算符来提高单个查询的性能，在组织操作符的时候可以参考生产者&#x2F;消费者模型</p>
<p>每一个operator都有一个并行化的版本</p>
<p>这样可以让多个线程访问集中式的数据结构，也或者使用分区来分工合作</p>
<p>其中操作又可以被划分为横向并行和纵向并行</p>
<h3 id="Horizontal"><a href="#Horizontal" class="headerlink" title="Horizontal"></a>Horizontal</h3><p>横向并行，也可以称为操作内并行，将运算符分解为独立的片段，这些片段在不同的数据子集中执行相同的功能</p>
<p>DBMS在查询计划中插入一个exchange操作符，用来合并&#x2F;拆分多个子操作符&#x2F;父操作符的结果</p>
<p>即把一个操作分配给多个Worker，每个Worker都执行一部分，最终用exchange算子对结果进行合并</p>
<h4 id="Exchange-Operator"><a href="#Exchange-Operator" class="headerlink" title="Exchange Operator"></a>Exchange Operator</h4><p>exchange算子有三种类型：</p>
<ul>
<li><p>Gather：</p>
<p>从多个Worker处得到结果，进行合并之后作为一个单独的输出传递给上游</p>
</li>
<li><p>Distribute：</p>
<p>将一个单独的输入分裂成多个输出传递给上游</p>
</li>
<li><p>Repartition：</p>
<p>将多个输入重新分组成多个输出传递给上游</p>
</li>
</ul>
<h3 id="Vertical"><a href="#Vertical" class="headerlink" title="Vertical"></a>Vertical</h3><p>纵向并行，思想类似于CPU的流水线，在运行一个操作的同时，另一个操作也在准备运行，一旦操作1处理完了一道数据就马上发给下一个操作2，因此不会出现类似于物化模型那样一次性传递一个数组的数据的情况</p>
<h2 id="Bushy-Parallelism"><a href="#Bushy-Parallelism" class="headerlink" title="Bushy Parallelism"></a>Bushy Parallelism</h2><p>Inter和Intra-Parallelism的结合，上下游之间的不同部分都可以被划分成一个个独立的部分交给一个或几个Worker来处理</p>
<h1 id="I-x2F-O-Parallelism"><a href="#I-x2F-O-Parallelism" class="headerlink" title="I&#x2F;O Parallelism"></a>I&#x2F;O Parallelism</h1><p>前面从过程模型的角度，介绍了基于并行查询的操作并行性。这里介绍了I&#x2F;O并行，是一种更加底层的并行方式</p>
<p>对于单设备来说，I&#x2F;O始终是DBMS的瓶颈，如果能够把I&#x2F;O任务分配到多个设备中并行处理，那么就能够一定程度上突破这个瓶颈</p>
<p>相关的方法有很多，这里主要介绍了两种：Multi-Disk Parallelism和Database Partitioning</p>
<h2 id="Multi-Disk-Parallelism"><a href="#Multi-Disk-Parallelism" class="headerlink" title="Multi-Disk Parallelism"></a>Multi-Disk Parallelism</h2><p>即数据库文件分布在多个磁盘进行存储</p>
<p>多磁盘并行主要考虑三方面因素：Performance、Durability、Capacity</p>
<ul>
<li><p>如果是基于硬件实现的多磁盘并行化：</p>
<p>硬件控制器需要能够支持管理多个设备：例如现在有1～6号page，3个磁盘，那么控制器需要将page按照顺序分配给每个磁盘；或者将每一个page都复制3份到不同的磁盘上</p>
</li>
<li><p>如果是基于软件实现的多磁盘并行化：</p>
<p>需要在文件&#x2F;对象的级别上使用擦除码，相较于传统的基于硬件实现，更加高效灵活（这一部分没怎么听懂）</p>
</li>
</ul>
<p>无论基于哪种方法实现，数据交换的过程对于DBMS都是透明的</p>
<h2 id="Database-Partitioning"><a href="#Database-Partitioning" class="headerlink" title="Database Partitioning"></a>Database Partitioning</h2><p>将数据库本身拆分成多个不相交的子集，进行分布式存储，这对于应用层而言是透明的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="愚者大人的铁质卷烟盒"
      src="/images/NiJiKa.GIF">
  <p class="site-author-name" itemprop="name">愚者大人的铁质卷烟盒</p>
  <div class="site-description" itemprop="description">琐碎和思考的堆放处</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jinziguan123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jinziguan123" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18917950960@163.com" title="E-Mail → mailto:18917950960@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">愚者大人的铁质卷烟盒</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
