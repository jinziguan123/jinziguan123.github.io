<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="琐碎和思考的堆放处">
<meta property="og:type" content="website">
<meta property="og:title" content="CigaCase">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="CigaCase">
<meta property="og:description" content="琐碎和思考的堆放处">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="愚者大人的铁质卷烟盒">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CigaCase</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CigaCase</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-12-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-12-13/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 12.13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:49:20 / 修改时间：13:00:25" itemprop="dateCreated datePublished" datetime="2024-02-28T12:49:20+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-12-13-Query-Execution"><a href="#Lecture-12-13-Query-Execution" class="headerlink" title="Lecture 12,13: Query Execution"></a>Lecture 12,13: Query Execution</h1><p>主要讲了SQL语句查询执行的相关问题</p>
<h1 id="Processing-Model"><a href="#Processing-Model" class="headerlink" title="Processing Model"></a>Processing Model</h1><p>首先是处理模型，定义了数据库中执行查询计划的三种模式，分别是：</p>
<ul>
<li>Iterator Model</li>
<li>Materialization Model</li>
<li>vectorization Model</li>
</ul>
<h2 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h2><p>又被称为Volcano Model或者Pipeline Model</p>
<ul>
<li><p>Iterator Model一共有三种基本的接口：Next()、Open()、Close()</p>
</li>
<li><p>该计算将关系代数中的每一种操作都抽象为一个operator，将整个SQL语句构造成一个operator树，这样一来，在进行查询的时候会从树顶向下不断调用next函数，而数据则会被自底向上拉取</p>
</li>
<li><p>迭代模型的优点：</p>
<ul>
<li>简单，每个operator可以单独实现逻辑，达到模块化处理，因此市面上有很多数据库都使用了迭代模型比如：SQLite、MongoDB、Impala、DB2、SQLServer、Greenplum、PostgreSQL、Oracle、MySQL</li>
</ul>
</li>
<li><p>迭代模型的缺点：</p>
<ul>
<li>查询树调用的Next接口次数太多，而且每次调用都指返回一条数据，使得CPU执行效率很低</li>
<li>Join、Subqueries、Order by等操作经常会阻塞</li>
</ul>
</li>
</ul>
<h2 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h2><p>物化模型优化了迭代模型的缺点：对于每一个operator，一次性处理所有的输入，处理完之后将所有结果一次性输出</p>
<p>伪代码看上去和火山模型大差不差，区别只在于每一个operator都会将结果放到一个out列表中，最后进行输出</p>
<ul>
<li>物化模型对于OLTP负载更加友好，因为每一个查询所涉及到的数据范围都是较小的，并且调用的函数更少</li>
<li>因此从另一方面来说，物化模型不适用于OLAP负载（因为OLAP涉及到的中间数据太多）</li>
</ul>
<h2 id="Vectorization-Model"><a href="#Vectorization-Model" class="headerlink" title="Vectorization Model"></a>Vectorization Model</h2><p>向量化模型与火山模型类似，对于每一种operator都要实现一种Next()函数，区别在于，向量化模型返回的是一批tuple，而不是火山模型中的一个tuple，可以简单理解成火山模型与物化模型两者的结合</p>
<p>该模型适用于OLAP数据库，使得中间的结果不需要溢出到磁盘，同时也能够减少Next函数的调用次数</p>
<h1 id="Access-Methods"><a href="#Access-Methods" class="headerlink" title="Access Methods"></a>Access Methods</h1><p>在执行查找的时候，DBMS需要一定的手段去访问叶子结点处的数据</p>
<p>一共可以分为三种方法</p>
<h2 id="Sequential-Scan"><a href="#Sequential-Scan" class="headerlink" title="Sequential Scan"></a>Sequential Scan</h2><p>最容易想到的就是顺序扫描：对于表中的每一个page，DBMS都从缓冲池中对其进行检索，并在此基础上遍历每一个tuple来决定是否要将其作为数据进行返回</p>
<ul>
<li>DBMS会保存一个游标（cursor），用来标记其上次访问的page&#x2F;slot</li>
</ul>
<h3 id="Sequential-Scan-Optimization"><a href="#Sequential-Scan-Optimization" class="headerlink" title="Sequential Scan : Optimization"></a>Sequential Scan : Optimization</h3><p>尽管顺序扫描是一种比较笨拙的方法，但可能也是我们唯一的选择</p>
<p>然而顺序扫描是可以进行优化的，我们在之前的课中已经接触过一些了，比如：</p>
<ul>
<li>Pre-Fetching（Lecture 6）</li>
<li>Buffer Pool Bypass（Lecture 6）</li>
<li>Parallelization（Lecture 13）</li>
<li>Heap Clustering（Lecture 8）</li>
<li>Late Materialization（Lecture 11）</li>
</ul>
<p>这节课讲了一个新的方法，Data Skipping</p>
<h4 id="Data-Skipping"><a href="#Data-Skipping" class="headerlink" title="Data Skipping"></a>Data Skipping</h4><p>有两种方法可以实现数据跳过组件：</p>
<ol>
<li><p>Approximate Queries（Lossy）</p>
<p>近似查询会首先对整张表做一个抽样，形成一个表的子集，对这个子集执行查询，这样能够得到一个近似的结果</p>
<p>近似查询是易失性的，这里的易失性应该是指会丢失一些本来应到能够找到的数据</p>
</li>
<li><p>Zone Map（Lossless）</p>
<p>这里重点介绍的方法就是Zone Map法，简单来说就是对于查询涉及到的每一个page，都实现处理出一些聚合属性，比如这个page上的MAX、MIN、AVG、SUM、COUNT，这样在查询到来的时候就能够直接进行比较，判断是否值得花时间遍历这个page，达到加速的效果</p>
<blockquote>
<p>比如现在我们有如下数据，我们要执行<code>select * from table where val &gt; 600</code>，DBMS拿到了查询指令和Zone Map进行比较，发现这个page的MAX值为400，显然整个page的数据都是我们不需要的，那么直接跳过这个page即可</p>
</blockquote>
</li>
</ol>
<h2 id="Index-Scan"><a href="#Index-Scan" class="headerlink" title="Index Scan"></a>Index Scan</h2><p>由DBMS来选择一个index来查找tuple（13章会详细解释DBMS根据哪几个方面的来选择index）</p>
<ul>
<li>索引扫描又分为单索引扫描和多索引扫描（Multi-Index Scan），两者的区别和特点从名字就可以看出来，需要知道的是，多索引扫描会根据查询条件，在多个索引上查询结果并且将结果集合做一个并集或者交集</li>
</ul>
<h1 id="Modification-Queries"><a href="#Modification-Queries" class="headerlink" title="Modification Queries"></a>Modification Queries</h1><p>负责修改数据库中的表以及相关索引的操作称为修改查询，这些查询的输出可以是数据记录的id，也可以是tuple（比如returning）</p>
<p>这里首先介绍了Halloween Problem（万圣节难题）：</p>
<p>譬如在火山模型的数据库中执行更新操作<code>update people set salary = salary + 100 where salary &lt; 1100</code>的时候，会首先根据index，调用Next（）查找出来目标tuple，删除、重新赋值、插入，由此完成更新</p>
<p>然而如果有一个tuple为：（Andy，999），在被更新之后会变成（andy，1099），此时这个tuple的物理位置已经改变，很有可能会被插入到原本位置之后，并且依然满足salary &lt; 1100的条件，所以会被第二次进行更新，变为（Andy，1199），这并不符合我们更新操作的目的</p>
<p>解决办法就是：跟踪所有修改过的记录id</p>
<h1 id="Expression-Evaluation"><a href="#Expression-Evaluation" class="headerlink" title="Expression Evaluation"></a>Expression Evaluation</h1><p>对于Where子句，DBMS会将其表示为一棵表达式树（expression tree），树中的不同结点代表不同的表达式类型例如：比较、析取、连接、算术运算符、常值、元祖属性引用等</p>
<p>还介绍了Prepare子句，类似于函数的功能</p>
<p>这一部分感觉就是普通的介绍，没有做很深入的讲解，看看就行</p>
<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>迄今为止我们所讨论的内容几乎都是基于数据流的角度来看待查询处理模型的，控制流以隐式的形式藏在一系列的查询操作中</p>
<p>而有了scheduler（调度器），我们就可以显式地明确控制流了</p>
<blockquote>
<p>以下是个人理解：</p>
<p>面向数据流是一件很复杂的事情，因为你没有办法非常细致地划分数据。比如人脑是没有办法清晰地认知：这一团数据是从哪里来的、要对它做什么、要把它发到哪里去之类的问题</p>
<p>但是面向控制流就会让上述的事情变得很简单明了，是一种抽象程度更高的方法，此外可能对于分布式存储的系统更加友好？因为可以将每一个控制任务push或者pull到远程主机做处理然后再传输回来，比单纯发送数据的方式封装程度更高？</p>
</blockquote>
<hr>
<h1 id="Parallel-x2F-Distributed"><a href="#Parallel-x2F-Distributed" class="headerlink" title="Parallel &#x2F; Distributed"></a>Parallel &#x2F; Distributed</h1><p>首先需要区分并行数据库和分布式数据库：</p>
<ul>
<li><p>首先需要明确的是，对于用户而言，两者是一样的，即对于某个查询返回某种结果，区别在于其内部设计</p>
</li>
<li><p>Parallel DBMSs：</p>
<ul>
<li>结点资源在物理上离得很近</li>
<li>结点资源通过高速互联进行通信</li>
<li>通信开销小并且是可靠的</li>
</ul>
</li>
<li><p>Distributed DBMSs：</p>
<ul>
<li>结点资源之间的物理位置相距远</li>
<li>结点资源通过低速互联进行通信</li>
<li>无法忽视结点之间的通信开销</li>
</ul>
</li>
</ul>
<h1 id="Process-Model"><a href="#Process-Model" class="headerlink" title="Process Model"></a>Process Model</h1><p>过程模型定义了系统将为何种架构以处理并发的请求&#x2F;查询，其中，Worker负责执行一个单独的任务并且返回结果，是DBMS中的一个组件</p>
<p>而模型的不同点就在于Worker的形式</p>
<h2 id="Process-per-Worker"><a href="#Process-per-Worker" class="headerlink" title="Process per Worker"></a>Process per Worker</h2><p>第一种形式是进程模型：给每一个Worker都分配一个进程，由OS负责调度，对于一个查询中的每一个operator，都交给一个Worker来负责执行</p>
<p>在线程的思想流行之前诞生的很多数据库都是用了这种模型</p>
<p>优点是：其中一个进程的崩溃并不会影响整个系统的崩溃</p>
<p>缺点是：极度依赖OS的调度，DBMS没有办法做到自行调度工作</p>
<h2 id="Thread-per-Worker"><a href="#Thread-per-Worker" class="headerlink" title="Thread per Worker"></a>Thread per Worker</h2><p>第二种是线程模型：以线程的形式管理每一个Worker，是如今常用的数据库并行处理模型，DBMS能够主动控制线程的调度，调度算法能够更加灵活</p>
<p>线程相对于进程的区别，即为线程模型相对于进程模型的优点和缺点——减少了进程带来的上下文切换、相比创建&#x2F;销毁一个进程，创建&#x2F;销毁一个线程的开销更小、不用管理公共内存；与此同时，一个线程的崩溃也会导致整个系统的崩溃</p>
<blockquote>
<p>关于Scheduling</p>
<p>对于每一个查询计划，DBMS都要决定执行的时间、地点和方式</p>
<p>需要考虑这个查询需要用到多少个Worker？需要用多少个CPU？这个查询需要在哪个CPU上处理？输出要保存在哪里？等等问题</p>
<p>因此DBMS知道的内容（比如上下文相关的信息）总是要比OS多一些</p>
</blockquote>
<h2 id="Embedded-DBMS"><a href="#Embedded-DBMS" class="headerlink" title="Embedded DBMS"></a>Embedded DBMS</h2><p>最后一种方式是嵌入式，DBMS与应用程序运行在同一地址空间，由应用程序来负责线程和调度（这一部分没怎么看懂）</p>
<h1 id="Inter-VS-Intra-Query-Parallelism"><a href="#Inter-VS-Intra-Query-Parallelism" class="headerlink" title="Inter- VS. Intra-Query Parallelism"></a>Inter- VS. Intra-Query Parallelism</h1><p>这里提出了两种并行化的思想的大概内容，姑且将其翻译为查询内并行性和查询间并行性</p>
<h2 id="Inter-Query"><a href="#Inter-Query" class="headerlink" title="Inter-Query"></a>Inter-Query</h2><p>查询内并行性通过允许多个查询同时进行从而提高整体性能</p>
<p>如果查询都是只读的，那么没有必要显式地协调查询与查询之间的先后，必要时，buffer pool可以处理大部分共享</p>
<p>然而如果有多个查询在同时更新数据库，那么将会很难保持正确性，这个问题会在Lecture 15讨论事务相关内容的时候提及</p>
<h2 id="Intra-Query"><a href="#Intra-Query" class="headerlink" title="Intra-Query"></a>Intra-Query</h2><p>通过并行执行运算符来提高单个查询的性能，在组织操作符的时候可以参考生产者&#x2F;消费者模型</p>
<p>每一个operator都有一个并行化的版本</p>
<p>这样可以让多个线程访问集中式的数据结构，也或者使用分区来分工合作</p>
<p>其中操作又可以被划分为横向并行和纵向并行</p>
<h3 id="Horizontal"><a href="#Horizontal" class="headerlink" title="Horizontal"></a>Horizontal</h3><p>横向并行，也可以称为操作内并行，将运算符分解为独立的片段，这些片段在不同的数据子集中执行相同的功能</p>
<p>DBMS在查询计划中插入一个exchange操作符，用来合并&#x2F;拆分多个子操作符&#x2F;父操作符的结果</p>
<p>即把一个操作分配给多个Worker，每个Worker都执行一部分，最终用exchange算子对结果进行合并</p>
<h4 id="Exchange-Operator"><a href="#Exchange-Operator" class="headerlink" title="Exchange Operator"></a>Exchange Operator</h4><p>exchange算子有三种类型：</p>
<ul>
<li><p>Gather：</p>
<p>从多个Worker处得到结果，进行合并之后作为一个单独的输出传递给上游</p>
</li>
<li><p>Distribute：</p>
<p>将一个单独的输入分裂成多个输出传递给上游</p>
</li>
<li><p>Repartition：</p>
<p>将多个输入重新分组成多个输出传递给上游</p>
</li>
</ul>
<h3 id="Vertical"><a href="#Vertical" class="headerlink" title="Vertical"></a>Vertical</h3><p>纵向并行，思想类似于CPU的流水线，在运行一个操作的同时，另一个操作也在准备运行，一旦操作1处理完了一道数据就马上发给下一个操作2，因此不会出现类似于物化模型那样一次性传递一个数组的数据的情况</p>
<h2 id="Bushy-Parallelism"><a href="#Bushy-Parallelism" class="headerlink" title="Bushy Parallelism"></a>Bushy Parallelism</h2><p>Inter和Intra-Parallelism的结合，上下游之间的不同部分都可以被划分成一个个独立的部分交给一个或几个Worker来处理</p>
<h1 id="I-x2F-O-Parallelism"><a href="#I-x2F-O-Parallelism" class="headerlink" title="I&#x2F;O Parallelism"></a>I&#x2F;O Parallelism</h1><p>前面从过程模型的角度，介绍了基于并行查询的操作并行性。这里介绍了I&#x2F;O并行，是一种更加底层的并行方式</p>
<p>对于单设备来说，I&#x2F;O始终是DBMS的瓶颈，如果能够把I&#x2F;O任务分配到多个设备中并行处理，那么就能够一定程度上突破这个瓶颈</p>
<p>相关的方法有很多，这里主要介绍了两种：Multi-Disk Parallelism和Database Partitioning</p>
<h2 id="Multi-Disk-Parallelism"><a href="#Multi-Disk-Parallelism" class="headerlink" title="Multi-Disk Parallelism"></a>Multi-Disk Parallelism</h2><p>即数据库文件分布在多个磁盘进行存储</p>
<p>多磁盘并行主要考虑三方面因素：Performance、Durability、Capacity</p>
<ul>
<li><p>如果是基于硬件实现的多磁盘并行化：</p>
<p>硬件控制器需要能够支持管理多个设备：例如现在有1～6号page，3个磁盘，那么控制器需要将page按照顺序分配给每个磁盘；或者将每一个page都复制3份到不同的磁盘上</p>
</li>
<li><p>如果是基于软件实现的多磁盘并行化：</p>
<p>需要在文件&#x2F;对象的级别上使用擦除码，相较于传统的基于硬件实现，更加高效灵活（这一部分没怎么听懂）</p>
</li>
</ul>
<p>无论基于哪种方法实现，数据交换的过程对于DBMS都是透明的</p>
<h2 id="Database-Partitioning"><a href="#Database-Partitioning" class="headerlink" title="Database Partitioning"></a>Database Partitioning</h2><p>将数据库本身拆分成多个不相交的子集，进行分布式存储，这对于应用层而言是透明的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-11/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:49:07 / 修改时间：13:00:21" itemprop="dateCreated datePublished" datetime="2024-02-28T12:49:07+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-11-Join-Algorithms"><a href="#Lecture-11-Join-Algorithms" class="headerlink" title="Lecture 11: Join Algorithms"></a>Lecture 11: Join Algorithms</h1><p>本章介绍了join算法的思想和实现</p>
<h1 id="Join-Operator"><a href="#Join-Operator" class="headerlink" title="Join Operator"></a>Join Operator</h1><ul>
<li><p>首先是join在底层是如何实现的：这里有两种方式</p>
<p>例如对于MySql语句：<code>select R.id, S.date from R join S on R.id = S.id where S.value &gt; 100</code></p>
<ul>
<li><p>Early Materialization：</p>
<p>这种方法一开始就将所有我们需要用到的具体数据都读取好放入内存，详细一点来讲就是把R.id和S.data直接作为新的tuple插入表中，这样一来，该查询的所有后续操作都不用再回到磁盘中读取数据</p>
</li>
<li><p>Late Materialization：</p>
<p>与前者相对的，滞后具象方法在一开始只会将匹配到的tuple的Record IDS放入表中，等到上层的操作需要获取数据的时候再去磁盘中拿。这种方法对于列存储的DBMS比较友好，因为最终除了我们需要的数据以外，我们不会读取到任何无关的数据</p>
</li>
</ul>
</li>
</ul>
<h1 id="Join-vs-Cross-Product"><a href="#Join-vs-Cross-Product" class="headerlink" title="Join vs. Cross-Product"></a>Join vs. Cross-Product</h1><p>这里需要进行一下连接操作与笛卡尔积之间的比较：</p>
<p>相对而言笛卡尔积是一种更加低效的方法，因为对于两张大小分别为m和n的表，一次笛卡尔积操作需要用两个for循环来遍历两张表，最终获得一张m*n大小的输出表</p>
<blockquote>
<p>例如<code>select * from s cross join e</code>就是一个笛卡尔积操作，最终输出的结果一来没有规律可言，而来耗费时间更长</p>
<p>而<code>select * from s join e on s.id = e.id</code>是一个join操作，输出结果明显会更小更快</p>
</blockquote>
<h1 id="Join-Algorithms"><a href="#Join-Algorithms" class="headerlink" title="Join Algorithms"></a>Join Algorithms</h1><h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h2><h3 id="Naive-Nested-Loop-Join"><a href="#Naive-Nested-Loop-Join" class="headerlink" title="Naive Nested Loop Join"></a>Naive Nested Loop Join</h3><ul>
<li><p>这是最简单的join算法，遍历两个表中的所有tuple，如果两两匹配，则输出</p>
</li>
<li><p>显然这是一个糟糕的算法，如果R表有M个page、m个tuple，S表有N个page、n个tuple，则对于一次join，开销将会是$$M + (m \times N)$$</p>
<blockquote>
<p>例如R有1000页，100000个tuple；S有500页，40000个tuple</p>
<p>那么做一次join的IO次数为：$$1000 + (100000 \times 500) &#x3D; 50001000$$次</p>
<p>如果一次IO要0.1ms，那么join一次就要将近1.3小时</p>
<p>即使使用大小比较小的S表作为outer loop的主体，最终也要近乎1.1小时</p>
</blockquote>
</li>
</ul>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested Loop Join"></a>Block Nested Loop Join</h3><p>朴素的循环算法没有充分利用缓冲池，由此引出了块嵌套循环</p>
<ul>
<li><p>假设我们缓冲区大小为B，则我们使用B-2个缓冲区用来装载外表（即外侧遍历的表），用一个缓冲区装载内表，最后一个缓冲区用来输出，写成伪代码如下：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each page pR(Belong to R) <span class="keyword">in</span> <span class="built_in">range</span>(B-<span class="number">2</span>):</span><br><span class="line">	<span class="keyword">for</span> each page pS(Belong to S) <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> each <span class="built_in">tuple</span> r <span class="keyword">in</span> pR:</span><br><span class="line">		    <span class="keyword">for</span> each <span class="built_in">tuple</span> s <span class="keyword">in</span> pS:</span><br><span class="line">  		        <span class="keyword">if</span> r matches s then emit</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>这个算法的IO复杂度为$$M + \lceil M &#x2F; (B-2) \rceil \times N$$</p>
<blockquote>
<p><strong>如果外循环可以完全装入内存：</strong></p>
<p>加入一次IO要0.1ms，那么总时长只要0.15秒</p>
</blockquote>
</li>
</ul>
<h3 id="Index-Nested-Join-Loop"><a href="#Index-Nested-Join-Loop" class="headerlink" title="Index Nested Join Loop"></a>Index Nested Join Loop</h3><p>上述两种算法，性能瓶颈在于：对于外循环中的每一个tuple，都需要遍历一次内循环中的tuple来进行判断，因此我们可以使用索引进行优化</p>
<ul>
<li>具体做法为：在关系S的连接属性上建立索引，对于R中的每一个元组，根据索引找到对应的S中元组进行连接</li>
<li>假设在索引上查找的代价为C，则IO复杂度为：$$M + m \times C$$</li>
</ul>
<h2 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort-Merge Join"></a>Sort-Merge Join</h2><p>如果我们手上的两张表都是有序的，那么join工作就会简单很多；如果他们不是有序的，那就可以考虑使用上节课讲到的排序算法让他们变得有序</p>
<ul>
<li><p>具体流程如下：</p>
<ul>
<li><p>Phase #1: Sort</p>
<ul>
<li><p>对两张表以join所使用到的key作为关键字进行排序</p>
</li>
<li><p>如果内存放不下这么多page，则需要使用外部排序</p>
</li>
</ul>
</li>
<li><p>Phase #2: Merge</p>
<ul>
<li>对两张排好序的表进行配对，这样外循环的元素就不用每次都遍历一遍内循环的元素了</li>
<li>可能会需要根据join的类型进行回溯，这里具体</li>
</ul>
<blockquote>
<p>比如表R：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Andy</td>
</tr>
<tr>
<td>200</td>
<td>GZA</td>
</tr>
<tr>
<td>200</td>
<td>GZA</td>
</tr>
</tbody></table>
<p>表S：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>value</th>
<th>cdate</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>2222</td>
<td>10&#x2F;4&#x2F;2023</td>
</tr>
<tr>
<td>100</td>
<td>9999</td>
<td>10&#x2F;4&#x2F;2023</td>
</tr>
<tr>
<td>200</td>
<td>8888</td>
<td>10&#x2F;4&#x2F;2023</td>
</tr>
<tr>
<td>400</td>
<td>7777</td>
<td>10&#x2F;4&#x2F;2023</td>
</tr>
</tbody></table>
<p>当R表遍历到第二行，而S表遍历到第三行时，会输出这组tuple，S表的指针会向下移动到第四行，此时发现R表中仍然有id&#x3D;200的tuple存在，则需要进行回溯，将指针退回第三行</p>
</blockquote>
</li>
</ul>
</li>
<li><p>IO开销如下：</p>
<blockquote>
<p>Sort Cost(R) : $$2M \times (1 + \lceil log_{B-1}{\lceil M &#x2F; B \rceil} \rceil)$$</p>
<p>Sort Cost(S) : $$2N \times (1 + \lceil log_{B-1}{\lceil N &#x2F; B \rceil} \rceil)$$</p>
<p>Merge Cost : $$M + N$$</p>
<p>-&gt;Total Cost : Sort + Merge</p>
<p>例如R有1000页，100000个tuple；S有500页，40000个tuple</p>
<p>则一共需要IO次数7500次，如果每次IO需要0.1ms，则一共需要0.75s</p>
</blockquote>
</li>
<li><p>排序join算法的最坏情况为：如果两张表的所有tuple都一模一样，那么回溯的次数将会大大增加，开销会来到$$(M \times N) + (sort cost)$$</p>
</li>
</ul>
<h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><ul>
<li><p>哈希join算法也有两个阶段：</p>
<ul>
<li><p>Phase #1: Build</p>
<p>首先使用哈希函数h1扫描外层表来获取一张哈希表，其中哈希方式可以任选，只不过在实际应用中，线性探查法是效果最好的</p>
</li>
<li><p>Phase #2: Probe</p>
<p>扫描内层表并且使用哈希函数h1来跳转并且寻找匹配的tuple</p>
</li>
</ul>
</li>
</ul>
<h3 id="Hash-Table-Contents"><a href="#Hash-Table-Contents" class="headerlink" title="Hash Table Contents"></a>Hash Table Contents</h3><p>对于一张哈希表，我们不仅仅要记录哈希值，还要记录对应的key，以防发生冲突时形成错误的match</p>
<p>此外，有些DBMS还会记录下来tuple的value，这取决于其使用的策略是一开始所提到的Early Materialization 还是Later Materialization</p>
<h3 id="Optimization-Probe-Filter"><a href="#Optimization-Probe-Filter" class="headerlink" title="Optimization : Probe Filter"></a>Optimization : Probe Filter</h3><p>对于Hash Join的一种常见的优化方式是使用Bloom Filter。这是一种概率性的数据结构，存放在CPU的cache中，Bloom Filter会在创建哈希表的时候判断：这个key是否存在于内层表中，他可能会将不存在误判为存在，但不会将存在的key误判为不存在</p>
<p>这样一来，当我们想要进入哈希表进行查找的时候，我们可以首先访问一下Bloom Filter，可以加快join的速度</p>
<h3 id="Partition-Hash-Join"><a href="#Partition-Hash-Join" class="headerlink" title="Partition Hash Join"></a>Partition Hash Join</h3><ul>
<li><p>有的时候哈希表没有办法装进内存，这个时候我们可以使用聚类哈希join，大概意思就是在build之前就先对输入的relation进行分类，然后针对每一个partition进行前面提到的hash join算法</p>
</li>
<li><p>Recursive Partition: 关于这一部分其实有点没太看懂，好像是说要用两个哈希函数来对两个表分别进行递归聚类，然后看tuple是否匹配（？）</p>
</li>
<li><p>IO开销如下：</p>
<blockquote>
<p>如果我们不使用递归聚类，那么</p>
<p>Partition Phase: $$2(M+N)$$次IO</p>
<p>Probe Phase: $$M+N$$次IO</p>
</blockquote>
</li>
</ul>
<h4 id="Optimization-Hybrid-Hash-Join"><a href="#Optimization-Hybrid-Hash-Join" class="headerlink" title="Optimization : Hybrid Hash Join"></a>Optimization : Hybrid Hash Join</h4><p>如果一个表中的key是skewed的（大概意思就是这个key在这个表中非常多），那么DBMS会将这个partition视作热点分区，将其保存在内存而非写回磁盘</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-10/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:48:49 / 修改时间：13:00:10" itemprop="dateCreated datePublished" datetime="2024-02-28T12:48:49+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-10-Sorting-amp-Aggregation-Algorithms"><a href="#Lecture-10-Sorting-amp-Aggregation-Algorithms" class="headerlink" title="Lecture 10: Sorting &amp; Aggregation Algorithms"></a>Lecture 10: Sorting &amp; Aggregation Algorithms</h1><p>本章主要介绍了几种排序与聚合算法的思想</p>
<h1 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h1><p>在关系型数据库中，tuple之间并没有特定的顺序关系，因此在进行诸如group by, distinct, partition by, order by, join之类的操作时，需要对tuple进行排序<br>如果内存足够放下这些数据，那么使用qsort进行排序即可；然而内存未必能够放下这么多的tuple，因此在这种情况下需要使用external sorting，能够根据需要将排序溢出到磁盘，并且倾向于顺序I&#x2F;O</p>
<h2 id="Top-N-Heap-Sorting"><a href="#Top-N-Heap-Sorting" class="headerlink" title="Top-N Heap Sorting"></a>Top-N Heap Sorting</h2><ul>
<li>如果一个查询包含一个带有limit的order by，则DBMS只需要查找到前N个元素即可，也就是使用Top-N Heap Sort。理想情况是将前N个元素放入内存，这样DBMS只需要维护一个优先队列即可</li>
</ul>
<blockquote>
<p>例如我们有以下查询：<code>select * from enrolled order by sid fetch first 4 rows with ties</code>，我们需要输出学号前四小的学生信息，如果学号相同，则并列输出。排序方法如下：</p>
<ul>
<li>首先创建大小为4的堆</li>
<li>遍历数据，如果堆未满，则直接放入堆；否则，如果fetch指向的数据已经在堆中，则将堆的大小扩大到两倍（因为要求with ties）并且放入堆；如果该数据不在堆中，则判断是否是我们需要的数据：如果是，则将堆首的相同元素全部pop，放入堆；如果不是，则跳过该fetch</li>
</ul>
</blockquote>
<h2 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h2><h3 id="Two-way-Merge-Sort"><a href="#Two-way-Merge-Sort" class="headerlink" title="Two-way Merge Sort"></a>Two-way Merge Sort</h3><ul>
<li>最基本的两路归并排序：在排序阶段从磁盘中读取page到内存，排序结束后写回磁盘；在合并阶段，他使用三个缓冲页——从磁盘中读取两个page到其中两个frame，并且将其合并到第三个frame，每当第三个frame被填满，就会将其写回磁盘，并且替换成一个空的page。其中每一组排好序的page被称为一个run，每一次遍历称为一个pass</li>
<li>如果参与排序的page数量为N，则该算法一共进行了$$1+\lceil\log_2N\rceil$$次遍历，总IO成本为$$2N\times (pass nums)$$</li>
</ul>
<h3 id="General（K-way）-Merge-Sort"><a href="#General（K-way）-Merge-Sort" class="headerlink" title="General（K-way） Merge Sort"></a>General（K-way） Merge Sort</h3><ul>
<li><p>该算法的一般版本允许DBMS使用三个以上的缓冲页</p>
<p>B表示缓冲页总数，在排序阶段，一次可以读取B个page，并且将$$\lceil \frac{N}{B} \rceil$$个排好序的run写回磁盘；在合并阶段，可以在每个通道中合并最多B-1个runs，将结果放入最后一个缓冲页并且写回磁盘</p>
</li>
<li><p>在一般的版本中，一共需要遍历$$1 + \lceil log_{B-1} \lceil \frac{N}{B} \rceil  \rceil$$次排序，总IO开销依然是$$2N\times (pass nums)$$</p>
</li>
</ul>
<h3 id="Double-Buffering-Optimization"><a href="#Double-Buffering-Optimization" class="headerlink" title="Double Buffering Optimization"></a>Double Buffering Optimization</h3><ul>
<li>优化思想是：假设我们从原本有的4个缓冲页扩大到了8个，那么如果还是按照原本3+1的思路进行串行的归并排序和写回，就会浪费一部分的IO请求等待时间。双缓冲优化使用多线程，组成两个3+1：当第一组缓冲区正在进行归并排序的时候，第二组缓冲区已经开始从磁盘中预读取page到frame中，这样一旦第一组IO结束，即可马上开始下一组IO的运算</li>
</ul>
<h3 id="Using-B-Tree"><a href="#Using-B-Tree" class="headerlink" title="Using B+ Tree"></a>Using B+ Tree</h3><ul>
<li>对于DBMS，可以使用聚类B+索引来帮助排序，因为在B+树的叶子结点中，所有数据的存储都是有序的，IO的访问也都是顺序的，可以有效减小计算开销，这比外部归并排序要来的高效</li>
<li>反之，如果是非聚类的B+索引，那么使用它就不是一个很好的选择（因为数据不连续），几乎所有访问都要从磁盘中读取而非buffer pool</li>
</ul>
<h1 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h1><p>在执行聚合运算的时候，往往是将一个或者多个tuple的值折叠成一个标量值，例如<code>select distinct cid from enrolled where grade in (&#39;B&#39;,&#39;C) order by cid</code></p>
<p>总体来说有两种实现聚合的方法：(1)排序，(2)散列</p>
<h2 id="Sorting-1"><a href="#Sorting-1" class="headerlink" title="Sorting"></a>Sorting</h2><ul>
<li>DBMS首先根据group by语句对tuple进行排序，如果buffer pool够用，则直接使用qsort，否则使用外部归并算法。然后DBMS会对排好序的数据进行顺序扫描来计算聚合</li>
<li>在执行排序聚合，重要是要对查询操作进行排序，以效率最大化。例如：如果查询需要一个过滤器，最好先执行过滤器，然后对过滤后的数据进行排序，以减少数据量</li>
</ul>
<h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><ul>
<li><p>由于在计算聚合的时候，散列的计算成本总是要比排序低得多，所以DBMS在扫描表的时候会填充一个临时的哈希表（ephemeral hash table），对于每一条记录，都会检查哈希表中是否已经有该条目，并且进行适当的修改。如果哈希表太大，DBMS就会将其溢出到磁盘上（？）。完成这个任务有两个阶段：</p>
<ul>
<li><p>Phase #1 - Partition：</p>
<p>使用哈希函数h1，根据目标的hash key将tuple分割到不同的磁盘分区，这样所有匹配的tuple都会被分配到同一片区域，然后DBMS会通过输出缓冲区将分区溢出到磁盘上</p>
</li>
<li><p>Phase #2 - ReHash：</p>
<p>对于磁盘上的每一个分区，将其page读入内存，并且根据第二个哈希函数h2，建立一个哈希表，由此把所有匹配的tuple都聚集到一起。如果hash表太小了以至于无法容纳所有数据，那么可以考虑将当前分区重新进行分割，或者混杂其他基于排序或者基于散列的算法</p>
</li>
</ul>
</li>
<li><p>在ReHash阶段，DBMS可以将需要输出的聚合存储为（GroupByKey -&gt; RunningValue）的配对，RunningValue的内容取决于聚合函数</p>
<blockquote>
<p>例如如果我们想要输出<code>select cid, AVG(gpa) from enrolled</code>，可以将AVG存储为(COUNT,SUM)的形式</p>
</blockquote>
</li>
<li><p>而对于一个新插入的tuple</p>
<ul>
<li>如果它能够找到一个匹配的GroupByKey，则适当更新RunningValue</li>
<li>否则插入一个新的(GroupByKey -&gt; RunningValue)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-9/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 9</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:48:06 / 修改时间：13:00:12" itemprop="dateCreated datePublished" datetime="2024-02-28T12:48:06+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-9-Index-Concurrency-Control"><a href="#Lecture-9-Index-Concurrency-Control" class="headerlink" title="Lecture 9: Index Concurrency Control"></a>Lecture 9: Index Concurrency Control</h1><p>本章主要介绍了数据库中几种闩锁的概念和简单的实现（非代码）</p>
<h1 id="Locks-vs-Latches"><a href="#Locks-vs-Latches" class="headerlink" title="Locks vs. Latches"></a>Locks vs. Latches</h1><ul>
<li>lock<ol>
<li>保护当前事务的索引内容不会受到其他事务的影响</li>
<li>lock在整个事务的执行期间都会被持有</li>
<li>DBMS需要在发生冲突的时候回滚变更</li>
</ol>
</li>
<li>latch<ol>
<li>保护索引内部数据不会被其他线程影响</li>
<li>仅在线程对索引进行某个操作的时刻被持有（一般持有时间很短）</li>
<li>DBMS不需要对数据的更新进行回滚</li>
<li>latch有两种mode，分别为Read Mode和Write Mode，其中Read Mode可以同时被多个线程持有，但Write Mode不行</li>
</ol>
</li>
</ul>
<h1 id="Latch-Implementation"><a href="#Latch-Implementation" class="headerlink" title="Latch Implementation"></a>Latch Implementation</h1><h2 id="Blocking-OS-Mutex"><a href="#Blocking-OS-Mutex" class="headerlink" title="Blocking OS Mutex"></a>Blocking OS Mutex</h2><ul>
<li>依赖OS内置的互斥机制，由<strong>用户空间的自旋latch</strong>以及<strong>OS的互斥锁</strong>组成。当DBMS无法获得用户空间的latch时，会试图进入内核态并获取更加昂贵的mutex，如果还是无法获取，则会被阻塞</li>
<li>OS mutex在DBMS中不是一个好的选择，因为会被OS介入，而且开销比较大<ul>
<li>例子：std::mutex  </li>
<li>优点：使用简单</li>
<li>缺点：消耗大，不可扩展</li>
</ul>
</li>
</ul>
<h2 id="Test-and-Set-Spin-Latch-TAS"><a href="#Test-and-Set-Spin-Latch-TAS" class="headerlink" title="Test-and-Set Spin Latch(TAS)"></a>Test-and-Set Spin Latch(TAS)</h2><ul>
<li>自旋锁比mutex更有效，因为DBMS可以控制自旋锁在无法获取latch的情况下的下一步动作：比如可以继续尝试获取或者允许OS取消调度<ul>
<li>例子：std::atomic&lt;T&gt;</li>
<li>优点：上锁更高效，一个<code>std::atomic_flag latch</code>指令即可上锁</li>
<li>缺点：没有扩展性，对于cache和OS并不友好</li>
</ul>
</li>
</ul>
<h2 id="Reader-Writer-Latches"><a href="#Reader-Writer-Latches" class="headerlink" title="Reader-Writer Latches"></a>Reader-Writer Latches</h2><ul>
<li>mutex和自旋锁并不区分读写（对于数据库而言是不好的），DBMS需要一种可以支持并发读取的方法，这样如果程序有大量读取的需求就可以获得更好的效果</li>
<li>读写锁允许latch以read或者write的mode进行等待，可以跟踪有多少线程持有该latch，以及有多少线程在等待获取latch。对于read锁，我们可以定义其在任何情况下都可以获得这把latch，也可以指定其只有在等待write的线程为空的时候才能获取；对于write锁，则需要等待read锁被全部释放<ul>
<li>例子：std::shared_mutex</li>
<li>优点：能够并发读取</li>
<li>缺点：必须要额外维护两个队列：read线程和write线程以防止饥饿现象，内存开销会更大</li>
</ul>
</li>
</ul>
<h1 id="Hash-Table-Latching"><a href="#Hash-Table-Latching" class="headerlink" title="Hash Table Latching"></a>Hash Table Latching</h1><ul>
<li>由于Hash数据结构本身的特性，所有线程在访问的时候都是按照顺序自上而下的，每次也都只会访问一个slot，因此不会出现死锁现象</li>
<li>按照粒度的大小，Hash Table Latching可以被分成两种：<ul>
<li>Page Latches：每个Page都用一把大锁锁住，每个线程在访问Page之前获取一个Read或者Write锁，这样的做法会降低程序的并发性，但是由于线程访问每个slot的速度很快，因为只需要一把锁即可实现</li>
<li>Slot Latches：Page中的每个slot都有自己的锁，所以读写线程可以同时访问一个Page的不同slot，提高了并发度，但同时也增加了存储和计算开销</li>
</ul>
</li>
</ul>
<h1 id="B-Tree-Latching"><a href="#B-Tree-Latching" class="headerlink" title="B+ Tree Latching"></a>B+ Tree Latching</h1><ul>
<li>B+树的锁主要为了防止以下问题：<ul>
<li>不同线程同时修改同一个结点</li>
<li>当一个线程对结点进行插入&#x2F;删除，导致结点出现了split&#x2F;merge现象时，另一个线程正在遍历树</li>
</ul>
</li>
<li>Latch Crabbing&#x2F;Couping Protocol（锁存耦合协议）允许多个线程并发访问B+树，具体规则如下：<ul>
<li>获取父节点锁</li>
<li>获取子结点锁</li>
<li>如果子结点被认为是安全的（不会发生split、merge、再分配），则释放父节点的锁</li>
</ul>
</li>
<li>Basic Latch Crabbing Protocol<ul>
<li>Search：从根结点开始向下，获取子结点锁-&gt;释放父节点锁，重复此步骤</li>
<li>Insert&#x2F;Delete：从根结点向下按需获取x个结点的latch，一旦孩子结点被锁住了，检查是否安全，如果安全，则释放所有祖先的锁</li>
<li>释放锁的顺序在逻辑上不重要，然而在现实中越靠近根结点的锁需要更先释放，否则会造成性能的下降</li>
</ul>
</li>
<li>Better Latch Crabbing Protocol：<ul>
<li>在改进的算法中，每一个线程都会默认到达目标结点的路径是安全的，并且以不断抓去Read锁的形式来到达，最终检验是否安全。如果不安全，则停止操作，重新开始，只不过重新遍历会抓去Write锁</li>
<li>Search：与朴素的算法一致</li>
<li><strong>Insert&#x2F;Delete</strong>：跟Search一样，不断获取和释放READ latch。最后在叶子结点上设置WRITE latch。如果叶子不安全，则重来，这次用基本算法的思路</li>
</ul>
</li>
<li>Leaf Node Scan<ul>
<li>前两种算法都是自上而下的，线程无法获取更上一层的锁存器，因此不会出现死锁现象</li>
<li>然而扫描叶子结点的时候很容易出现死锁，当两个线程以相反的方向遍历到了相邻的叶子结点，就会出现死锁，而Index Latch本身并不支持死锁的检测和预防</li>
<li>因为，唯一能够解决这个问题的方式就是通过code discipline，叶子结点的兄弟结点的锁存器必须遵循“no wait”原则。B+树必须面对锁存器获取失败的情况，一般会选择终止操作，重新启动</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-6/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:45:09 / 修改时间：13:00:48" itemprop="dateCreated datePublished" datetime="2024-02-28T12:45:09+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Letcure-6-Memory-Management"><a href="#Letcure-6-Memory-Management" class="headerlink" title="Letcure 6: Memory Management"></a>Letcure 6: Memory Management</h1><p>本章主要介绍了数据库中内存管理的相关内容，主要引入了缓冲池的概念</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>DBMS的任务就是管理内存以及从磁盘写入写出数据。数据库如果希望对磁盘上的数据进行处理，则必须首先将数据移动到内存中</p>
<p>因此我们需要设计一个DBMS，满足以下几个要求：</p>
<ul>
<li>其能够处理的数据量超出内存的大小</li>
<li>最小化磁盘上执行查询所带来的低效率问题</li>
<li>使得所有的操作看起来都像是在磁盘上进行的一样</li>
</ul>
<p>这个问题可以从时间上和空间上两个方面来考虑：</p>
<ul>
<li><strong>空间上</strong>：我们需要将Page写在磁盘的哪一个部分？这是为了保证数据的空间局部性</li>
<li><strong>时间上</strong>：我们应该何时进行Page的写入写出？这是为了尽可能减少从磁盘上读取数据的停顿次数</li>
</ul>
<h1 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><ul>
<li>执行引擎在请求Page的时候会先去buffer pool查询，如果没有，则buffer pool会执行替换算法将目标Page换入其中。此时脏页会被写会磁盘，而非脏页会被直接舍弃。可以参考cache在计算机硬件中的作用</li>
<li>缓冲池是一个从磁盘上读取数据的内存区域，该内存区域被组织称一个个固定大小的页面阵列，被称为frame。每个frame保存的都是磁盘中的一个Page，因此为了方便调度，我们需要Page Table（页表）。</li>
<li>页表是一个Hash表，用来跟踪处于buffer pool中的Page，我们可以通过页表以及上面的page_id来确认此Page是否还在buffer pool中。当然页表还会记录一些元数据<ul>
<li>Dirty Flag：标志位，表示这个Page是否被改写过，这是为了保证数据持久化</li>
<li>Pin Count：正在引用或者正在访问该Page的线程的数量，如果这个meta data非零，那么我们当下就不应该将这个Page驱逐出buffer pool</li>
</ul>
</li>
</ul>
<h1 id="Lock-vs-Latch"><a href="#Lock-vs-Latch" class="headerlink" title="Lock vs. Latch"></a>Lock vs. Latch</h1><p>由于我们并不希望我们在移动Page的时候被其他线程干扰（比如修改这个Page上的数据），所以我们需要对Page进行上锁操作</p>
<p>这涉及到了数据库中Lock和Latch的一些区别：</p>
<ul>
<li>lock<ol>
<li>保护当前事务的索引内容不会受到其他事务的影响</li>
<li>lock在整个事务的执行期间都会被持有</li>
<li>DBMS需要在发生冲突的时候回滚变更</li>
</ol>
</li>
<li>latch<ol>
<li>保护索引内部数据不会被其他线程影响</li>
<li>仅在线程对索引进行某个操作的时刻被持有（一般持有时间很短）</li>
<li>DBMS不需要对数据的更新进行回滚</li>
<li>latch有两种mode，分别为Read Mode和Write Mode，其中Read Mode可以同时被多个线程持有，但Write Mode不行</li>
</ol>
</li>
</ul>
<h1 id="Page-Table-vs-Page-Directory"><a href="#Page-Table-vs-Page-Directory" class="headerlink" title="Page Table vs. Page Directory"></a>Page Table vs. Page Directory</h1><p>这里需要辨析两个概念，页表和页目录虽然看上去很像，但本质上有很大区别：</p>
<ul>
<li>Page Table：内存中的一个哈希表，并不需要持久化，即哪怕丢弃了，只需要重新建立一个就行</li>
<li>Page Directory：从page_id到数据库文件中页面位置的映射，对于页目录的所有改变都必须要记录到磁盘上，以允许DBMS在重启之后能够发现，否则会破坏数据的一致性</li>
</ul>
<h1 id="Allocation-Policies"><a href="#Allocation-Policies" class="headerlink" title="Allocation Policies"></a>Allocation Policies</h1><p>数据库中的内存是根据两个策略来分配给buffer pool的</p>
<ul>
<li>Global Policies：<br>全局策略处理DBMS应该作出的决定，以有利于正在执行的整个工作负载<br>他考虑到所有活动的事务，以找到分配内存的最佳策略</li>
<li>Local Policies：<br>本地策略作出的决定会使得单个查询或事务的执行更快<br>本地策略将框架分配给特定的事务而不考虑事务的并发行为</li>
</ul>
<h1 id="Buffer-Pool-Optimization"><a href="#Buffer-Pool-Optimization" class="headerlink" title="Buffer Pool Optimization"></a>Buffer Pool Optimization</h1><p>有许多方法可以来优化buffer pool</p>
<h2 id="Multiple-Buffer-Pool"><a href="#Multiple-Buffer-Pool" class="headerlink" title="Multiple Buffer Pool"></a>Multiple Buffer Pool</h2><p>我们可以分配多块内存区域以支持多个Buffer Pool，每个区域可以有自己的页表，并且自己一套page id和frame的映射关系，这样可以更好地运用局部策略，并且根据不同的类型来分配page的置换策略（例如index或者table data），这样也能减少访问缓存池的不同线程之间对于页表锁的争夺</p>
<p>有两种办法来将Page映射到不同的buffer pool中：</p>
<ul>
<li>Objects IDs：<br>对象ID涉及扩展记录标识(extending the record IDs)，使其具有一个对象标识符(object identifier)。然后，通过对象标识符，可以维持一个从对象到特定缓冲池的映射关系。</li>
<li>Hashing：<br>哈希也是老生常谈的方法了，不展开</li>
</ul>
<h2 id="Pre-Fetching"><a href="#Pre-Fetching" class="headerlink" title="Pre-Fetching"></a>Pre-Fetching</h2><p>DBMS也可以通过基于查询计划的预取页面来进行优化。然后，当第一组页面被处理时，第二组页面可以被预取到缓冲池中。<strong>这种方法是DBMS在连续访问许多页面时常用的</strong></p>
<h2 id="Scan-Sharing"><a href="#Scan-Sharing" class="headerlink" title="Scan Sharing"></a>Scan Sharing</h2><p>查询游标可以有效减少对于数据的访问</p>
<blockquote>
<p>Q1:select sum(val) from A<br>Q2:select avg(val) from A limit 100<br>对于以上两个查询，如果Q1在执行到一半的时候，Q2加入了进来，那么就可以将Q2定位到Q1此时的游标位置，当游标遍历结束之后，Q2再针对前面没有被查询到的数据进行访问</p>
</blockquote>
<h2 id="Buffer-Pool-Bypass"><a href="#Buffer-Pool-Bypass" class="headerlink" title="Buffer Pool Bypass"></a>Buffer Pool Bypass</h2><p>对于需要线性读取大量数据的查询操作，可以选择不将获取的页面存储在buffer pool中，可以随意丢弃</p>
<p>此外，对于中间数据（类似于join和sorting），也可以这么做</p>
<h1 id="Buffer-Replacement-Policies"><a href="#Buffer-Replacement-Policies" class="headerlink" title="Buffer Replacement Policies"></a>Buffer Replacement Policies</h1><p>buffer pool在写入新页而没有空间时，需要执行evict操作给新页腾位子<br>替换策略的目标是准确性、正确性、并发性、和元数据的开销</p>
<h2 id="Least-Recently-Used（LRU）"><a href="#Least-Recently-Used（LRU）" class="headerlink" title="Least Recently Used（LRU）"></a>Least Recently Used（LRU）</h2><p>对于缓存池中每个page维护一个时间戳，时间戳记录着每个page最后被访问的时刻。当DBMS需要驱逐（evict）一个page时，选择时间戳最早的page执行驱逐。一般来说我们可以让page按照时间戳排序（优先级队列）以减少搜索的时间。</p>
<h2 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h2><p>CLOCK策略是LRU的一个近似值，不需要每页有单独的时间戳。在CLOCK策略中，每个页面被赋予一个参考位。当一个页面被访问时，设置为1<br>为了形象地说明这一点，可以用 “时钟指针 (clock hand)”将页面组织在一个圆形的缓冲区中。在清扫时检查一个页面的位是否被设置为1，如果是，则设置为0，如果不是，则驱逐它。通过这种方式，时钟指针在驱逐之间记住了位置</p>
<h2 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h2><p>无论是LRU还是Clock，都会受到sequential flooding的影响：在进行顺序访问的时候，DBMS会不断把连续的page读入内存，但这些正在使用的page是我们最不想要的（因为我们不过是为了查找到自己想要的page，迫不得已才把之前的page读入buffer pool）<br>有三种方法可以解决LRU和Clock的缺点：</p>
<ul>
<li>LRU-K：<br>frame组成的链表被分为两个区域：young list和old list，当old list中的page被再一次访问到，则将其放入young list的头部；而新加入buffer pool的页面会被放入old list的头部<br>它跟踪最后K个引用的历史作为时间戳，并计算出后续访问的间隔。这个历史记录被用来预测一个页面下次被访问的时间</li>
<li>Localization per Query<br>DBMS跟踪每一个查询的访问情况，在每个查询的基础上选择哪些页面要被驱逐。这使得每次查询对缓冲池的污染最小化</li>
<li>Priority Hints<br>优先级提示允许事务根据查询执行过程中每个页面的上下文，告诉缓冲池页面是否重要</li>
</ul>
<h1 id="Dirty-Page"><a href="#Dirty-Page" class="headerlink" title="Dirty Page"></a>Dirty Page</h1><p>DBMS有两种办法来处理有脏位的页面：</p>
<ul>
<li>Fast Path：直接丢弃掉buffer pool中任何非脏页</li>
<li>Slow Path：将脏页写回磁盘</li>
</ul>
<p>避免不必要的页面写回的方法是<strong>后台写入</strong><br>通过后台写入，DBMS可以周期性地通过页表来写回脏页到磁盘上<br>当一个脏页被后台写入，DBMS可以要么将这个page驱逐出去，或者保持其在buffer pool中的位置但是重置其dirty flag</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-3-4-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-3-4-5/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 3.4.5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:44:50 / 修改时间：12:59:22" itemprop="dateCreated datePublished" datetime="2024-02-28T12:44:50+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-3-4-5-Database-Storage-amp-Storage-Model"><a href="#Lecture-3-4-5-Database-Storage-amp-Storage-Model" class="headerlink" title="Lecture 3,4,5: Database Storage &amp; Storage Model"></a>Lecture 3,4,5: Database Storage &amp; Storage Model</h1><p>本章主要介绍了数据库的存储方式以及几种常见的存储模型</p>
<h1 id="Disk-Oriented-DBMS"><a href="#Disk-Oriented-DBMS" class="headerlink" title="Disk_Oriented DBMS"></a>Disk_Oriented DBMS</h1><ul>
<li>数据库保存在磁盘上，按照页（page）作为单元进行划分，第一页为目录页，如果想要对数据库进行操作，则首先需要将数据库中的page调度到内存中<ul>
<li>通过一个保存在内存中的缓冲池（buffer pool）来管理数据在磁盘和内存之间的移动</li>
<li>DBMS有一个负责查询的执行引擎，缓冲池将page带入内存，并且给执行引擎返回一个指向该page的指针，以确保在执行引擎在对该page进行操作的时候，此page的确存在于该位置</li>
</ul>
</li>
</ul>
<h1 id="DBMS-vs-OS"><a href="#DBMS-vs-OS" class="headerlink" title="DBMS vs OS"></a>DBMS vs OS</h1><p>DBMS的一个高级设计目标就是：创造一个容量远大于内存的数据库，与此同时并不希望过于频繁地访问数据库，因为访问磁盘的代价很大<br>这就类似于操作系统中的虚拟内存，保证磁盘中的地址空间能够映射到内存中<br>提起磁盘和内存之间数据的迁移，很容易想起mmap，的确曾经有很多DBMS选择使用mmap来执行，然而实际上是会造成一些问题的</p>
<ol>
<li>DBMS并不知道哪些page在内存中，而mmap在遇到page fault时会阻塞进程</li>
<li>OS可以在任何时刻写回脏页，然而OS并不知道哪些page需要在其他page之前写回磁盘，这会造成并发控制方面出现问题<br>尽管有办法解决这方面的问题，但是从性能和安全性两方面考虑，并不建议由操作系统来完成这一任务<br>因此根据Andy所言，由DBMS自己来实现数据的控制是一个更好的选择</li>
</ol>
<h1 id="DataBase-Storage"><a href="#DataBase-Storage" class="headerlink" title="DataBase Storage"></a>DataBase Storage</h1><h2 id="File-Storage"><a href="#File-Storage" class="headerlink" title="File Storage"></a>File Storage</h2><p>DBMS使用自己独有的编码形式将数据库作为单个文件或者多层次文件保存在磁盘中，OS对此一无所知<br>DBMS的存储管理器负责管理数据库的文件，它会将这些文件作为一个page的集合，并且追踪哪些数据被读写、这些page有多少可用空间</p>
<h2 id="DataBase-Page"><a href="#DataBase-Page" class="headerlink" title="DataBase Page"></a>DataBase Page</h2><p>DBMS将数据库文件中固定大小的数据块称为页（page），可以参考OS中的虚拟内存，页面可以包含不同的数据结构（tuple、indexes、log等）<br>在大多数DBMS中，一个page会被要求只能存储一种类型的数据</p>
<blockquote>
<p>例如page1只能存储tuple，page2只能存储日志<br>所以，每个page都会被赋予⼀个唯⼀的内部标识符，系统会生成属于page的ID。之后，就会有一个indirection层。indirection层允许将⼀个page ID映射到某个物理位置，即某个文件中的某个位置（类似于一个字典映射，其实就是记录⼀个相对位置，方便文件整体移动后，只要知道整体文件的初始位置，我依然可以通过该相对位置（即page ID）找到某个文件某个位置的数据所对应的page）。这样的话，就可以支持磁盘的压缩或者使用另一块磁盘而不改变page ID。</p>
</blockquote>
<h2 id="DataBase-Heap"><a href="#DataBase-Heap" class="headerlink" title="DataBase Heap"></a>DataBase Heap</h2><p>关于page之间是如何进行存储的——<br>堆文件组织是是一个无序的页面集合，是从磁盘上查找我们想要的page地址的一种方法<br>DBMS可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面ID：</p>
<blockquote>
<ol>
<li>Linked List：<br>是一种顺序存储（顺序存储并不意味着有序），这是一种很容易想到的存储方式，然而弊端也是显然的：链表的查询时间复杂度为O（n），效率远不及hash</li>
<li>Page Directory：<br>可以类比书的目录，每次查询只需要从page directory中获取目标page的偏移量即可，然而弊端在于：必须时刻保证目录与实际page信息的同步。如果往某个page中写入数据，此时page满了，但系统也崩溃了，那么目录中的信息是相对滞后的，在重启系统之后需要有对应策略来重新扫描以维护信息的一致性；如果数据量很大，在极端条件下可能始终无法统一</li>
</ol>
</blockquote>
<h2 id="Page-Layout"><a href="#Page-Layout" class="headerlink" title="Page Layout"></a>Page Layout</h2><p>关于page中的信息是如何存放的——<br>每一个page都有一个页头（header）来存放该page的，譬如页面大小、DBMS版本号之类的相关信息，这些信息被称为元数据（meta data）<br>一般来说数据在page中有2种常见的存储方式：tuple-oriented和log-structured</p>
<ol>
<li>tuple storage<br>一种朴素的思想就是将tuple以数组的方式存放，同时header记录page的信息，但这是一个strawman idea：因为当我们删除其中的一个tuple时，会产生内部碎片，导致文件的不连续；如果tuple的长度是不定长的话，这个问题会更加显著。同时tuple的查找也只能够顺序遍历，所以并不推荐</li>
<li>slotted storage<br>page中除了header以外还有两种数据结构，一种是slot，一种是tuple<br>其中slot从header之后顺序存储，每个slot都保存了对应的tuple在该page中的偏移量；而tuple本身是从page的末尾开始从后往前循序存储。虽然必然会出现一定的内部碎片，然而这是为了处理变长tuple不得不做出的牺牲，当然有些数据库支持对于内部碎片的再整理<br>对于slotted storage，一个tuple的查询需要其所在的page_id和slot_id</li>
<li>log-structured storage<br>slotted storage依然有很多问题没有能够解决：例如删除tuple的时候会留下空隙、必须从磁盘中读取整个page来获取其中的一个tuple、随机读取的效率很低<br>由此诞生了log-structured storage，这是一种只允许创建新数据而不允许覆盖已有数据的存储方式，DBMS中只会存放日志记录<ul>
<li>将数据库如何被修改的记录存储到文件中（放入和删除）。每条日志包含tuples的唯一标识符</li>
<li>要读取一条记录，DBMS会从最新的到最旧的逆向扫描日志文件，并 “重新创建 “这个 tuple。</li>
<li>写的快，读的可能慢。磁盘写入是连续的，现有的页面是不可改变的，这导致了随机磁盘I&#x2F;O的减少。</li>
<li>在append-only的存储上工作得很好，因为DBMS不能回溯并更新数据。</li>
<li>为了避免长时间的读取，DBMS可以有索引来允许它跳到日志中的特定位置。它还可以定期地压缩日志。（如果它有一个tuple，然后对其进行了更新，它可以将其压缩到只插入更新的tuple）</li>
<li>由于不再需要时间信息，数据库可以将日志压缩到一个按id排序的表中。这些被称为分类字符串表（SSTables），它们可以使tuple搜索非常快。</li>
<li>紧凑化的问题是，DBMS最终会出现写入放大的情况。（它一次又一次地重写相同的数据）</li>
</ul>
</li>
</ol>
<h2 id="Tuple-Layout"><a href="#Tuple-Layout" class="headerlink" title="Tuple Layout"></a>Tuple Layout</h2><p>关于tuple的具体结构——<br>其实通过sql的创建table的句式就可以观察出来，tuple本质上是一个字节的序列，DBMS的工作就是将字节的序列翻译成不同的属性和值</p>
<ul>
<li>Tuple Header：包含了tuple的元数据<ul>
<li>DBMS的并发控制协议的可见性信息。关于哪个事务创建&#x2F;修改了该元组</li>
<li>NULL值的位图</li>
</ul>
</li>
<li>Tuple Data：数据的实际属性<ul>
<li>属性通常按照你创建表时指定的顺序存储</li>
<li>大多数DBMS不允许一个tuple超过一个页面的大小</li>
</ul>
</li>
<li>Unique Identifier<ul>
<li>数据库中的每个tuple都被分配一个唯一的标识符</li>
<li>一般是：page_id + （offset or slow）</li>
</ul>
</li>
</ul>
<h1 id="Storage-Model"><a href="#Storage-Model" class="headerlink" title="Storage Model"></a>Storage Model</h1><p>数据库并没有规定应该按照哪一种模型来保存数据，然而在实际操作中，storage model的影响是很大的</p>
<h2 id="OLTP（On-line-Transaction-Processing）"><a href="#OLTP（On-line-Transaction-Processing）" class="headerlink" title="OLTP（On-line Transaction Processing）"></a>OLTP（On-line Transaction Processing）</h2><p>意思是从外界拿到数据后，只会将其放入数据库中进行简单的查询或者更新，一个具体的例子就是网购的购物车，将购物车中的东西删除、或者新增东西到购物车里，tuple的改变是很小的</p>
<h2 id="OLAP（On-line-Analytical-Processing）"><a href="#OLAP（On-line-Analytical-Processing）" class="headerlink" title="OLAP（On-line Analytical Processing）"></a>OLAP（On-line Analytical Processing）</h2><p>从数据库中的到数据后不会修改原有的数据，而是希望能够从数据中挖掘出更加深入的信息，例如数据挖掘、数据分析之类的工作，某种意义上OLAP是只读的，并且join的操作很多</p>
<p>以上两种不同的数据库使用方式就导致诞生了各种数据的存储模型：</p>
<ol>
<li>N-ary Storage Model（NSM）<br>简单来说就是一个tuple会保存表中的所有属性，例如（姓名，性别，生日，年龄）作为一个tuple<br>这是一种典型的row storage，并且利好OLTP：因为内容都是顺序排列的，存储粒度足够小，我们可以只关心自己想要的数据<br>但是对于OLAP而言，NSM是灾难性的，显然我们的查询会涉及到很多我们并不想要的数据</li>
<li>Decomposition Storage Model（DSM）<br>这是一种典型的列存储模型，他将每一个tuple按照属性进行拆分存储，例如姓名作为一个tuple，性别作为第二个tuple……<br>对于列存储而言，每次查询可以只读取某几个属性的值，这对于OLAP是有利的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/14/%E5%8F%9B%E9%80%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/14/%E5%8F%9B%E9%80%86/" class="post-title-link" itemprop="url">叛逆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-14 00:08:30" itemprop="dateCreated datePublished" datetime="2024-01-14T00:08:30+08:00">2024-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-28 13:00:43" itemprop="dateModified" datetime="2024-02-28T13:00:43+08:00">2024-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>“你的叛逆期似乎比其他的小孩来得更晚一些，我不知道这是好是坏”</p>
<p>在某一次与父亲的饭间闲聊产生了激烈的观念冲突后，他对我如是说道。</p>
<p>我知道他口中的“叛逆期”并不针对他们，应该说，即使真的针对他们，他们也只认为是我成长途中自我意识的觉醒，不以为然，更不至于为我感到担忧——我听得出来，我也心知肚明，我所叛逆的对象要比“父母”庞大的多，也难相处的多</p>
<p>自从升入大三，我便开始经常翘课，并不是因为我贪图玩乐，而是因为我认为“没必要”：既然这个老师上课不讲课，那我不如找资料自学，既然我要自学，那我也没必要去他的课堂。同样的，既然我不想卷绩点，那么平时的实验也就没必要做到完美，差不多糊弄糊弄拿个平时分就足够。每当母亲唠叨期末考试的结果，我都嗤之以鼻——因为对我来说，这东西无论是高是低，最终脑回路导向的结果都是“没必要”的</p>
<p>上述所说的讲课跑火车的老师也好，比夏天吸血的雌蚊子的存在更不合理的教学大纲也好，都是客观上存在的事实，直到现在我依然觉得自己的做法是有理可据的，是在特定环境下作出的自救行为。事实上翘课的那段时间我也的确没有荒废，拿来学自己想学的东西，相信着自己能够全凭自己一步步向自己所期望的目标挪动，却又始终放不下我所认为的“没必要”的学校的教学课程</p>
<p>我为自己想要实践却饱受阻挠的生活而痛苦，为身不由己无法从已经被预先定死的框架中彻底脱身而烦恼</p>
<p>所以我选择了最辛苦的方式：鱼和熊掌我全都要，毕竟再怎么说，至少我不想挂科</p>
<p>这就是我的叛逆，认为被形式束缚住的生活是错误的，认为向不合理的事情妥协应当是被禁止的，激进到想要对所有对我指手画脚的人漏出獠牙，推翻循规蹈矩愚昧至极的一切</p>
<p>即使无法甩开像臭虫一般令人讨厌的条条框框也无所谓，幻想着只要我足够强大，就能建立属于自己的秩序，做自己的独裁者</p>
<p>超级幼稚超级天真超级不切实际</p>
<p>人在年轻的时候总是一股冲劲蛮不讲理，从脚心诞生的一瞬间就开始野蛮生长，来不及等待中枢神经的控制就能直上脑门，用殉道者的姿态看待自己，用自毁心态丈量世界，觉得自己总是对的，藏在丹田里的小宇宙总有一天能改变这个垃圾一样的世界</p>
<p>用自己为是的眼光看待周遭而不听劝阻，就叫叛逆</p>
<p>当然叛逆期总会结束的</p>
<p>当我真的用了两个学期的时间去尝试兼顾自己想要的生活和当下的规矩，终于发现，似乎处理得没有想象中那么得心应手，我依然在煎熬，只不过原因从平时作业的拖累这一条，又加上了自己缓慢的学习进度以及对未来愈发强烈的迷茫</p>
<p>我从来不怀疑自己的努力，我只是终于开始怀疑自己的叛逆——赌气一般的行为，是否真的给自己带来了什么东西？取舍之间，结果的确匹配得了长久以来的预期吗？</p>
<p>叛逆期在人生的这个阶段到来，究竟是好是坏，我不知道，父亲不知道，谁都不知道</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/14/%E8%BF%BD%E6%82%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/14/%E8%BF%BD%E6%82%BC/" class="post-title-link" itemprop="url">追悼</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-14 21:53:07" itemprop="dateCreated datePublished" datetime="2023-11-14T21:53:07+08:00">2023-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-15 01:17:16" itemprop="dateModified" datetime="2023-11-15T01:17:16+08:00">2023-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>灵堂的大小比想象中更小，黑白色调的压迫感让人喘不过气，抽泣声比哀乐更抢先一步涌入耳蜗，枯萎的浅黄菊花是一片黑色孝布中唯一显眼的色彩<br>死者是娘家的某位亲戚，在生死线上挣扎了许久之后撒手人寰，他是家里的老幺，众兄弟姐妹没有想到亲生弟弟会由自己亲手送走<br>沉默、低语、泪水，身处如此环境之中，很难催生出悲伤以外的情绪</p>
<p>自我出生以来，身边的绝大部分至亲，不说身体健康，顶多也只是小病不断大病没有的程度，所以说来惭愧，我深知自己的这种想法有些猎奇甚至十分冒犯，但我在追悼会开始之前的确是有些兴奋——这是我人生中第一次参加追悼会，第一次亲眼见到逝者</p>
<p>仪式流程就和普通的追悼会一样：奏哀乐，念悼词，绕场一周告别遗体<br>受到众人情绪的感染，很难不鼻尖泛酸，眼眶微红，但也仅限于此。我并非铁石心肠，恰恰相反是一个很情绪化的人，只不过今天我尽量让自己仿佛置身事外，不参与其中<br>我也的确做的不错——逝者的仪容、盖住遗体的鲜花、棺材里他最喜欢戴的帽子、沉默的人、流泪的人、情绪激动的人、号啕大哭的人，我都一一看过，记在了这里</p>
<p>终于到了最后的时刻，侍者慢慢合上棺材盖，渲染着悲伤氛围的分贝达到了顶峰</p>
<blockquote>
<p>“他还那么年轻……”——有人已经无法控制自己的声带<br>“让我再看他最后一眼”——有人歇斯底里抓着棺材板<br>“我们就送你到这里了……”——有人嘶哑着念叨着告别的言语</p>
</blockquote>
<p>逝者的儿子接过不知从哪里递过来的锤子和四个钉子<br>一下<br>一下<br>一下<br>一下<br>……<br>敲打铁钉的声音盖过人群的哽咽，抹消光线再一次照进棺材的机会，以及生者再次见到他的机会</p>
<p>至此，结束</p>
<p>尽管我一再憋住悲伤，努力当一个无情的摄像机，但我似乎高估了自己的心理防线<br>之前也提过，我是一个情绪化的人，这里又不得不再加一句：<br>我是一个很傲慢的人<br>我天真地以为，在网络上看过这么多的生离死别之后，自己多多少少会有所防备<br>所以不曾设想过，自己不切实际的傲慢在现实的冲击之下会有多么脆弱</p>
<p>在钉棺材板的时候，我的情绪管理就已经小小地失控了，恐惧教唆着泪水逃出眼眶，前赴后继<br>在将来某个必将到来的时间，我也会拿起锤子，敲下钉子，亲手埋葬我最重视的人<br>我在害怕，害怕父母的死去，害怕重要之人的离开<br>那会是多久之后？二十年？十年？几个月？几周？还是明天？没有人能够保证<br>在那一天到来之前，我会变得足够坚强吗？坚强到能够坦然接受他们的离开，坚强到能够不在敲下钉子的时候因悲伤而脱力？<br>我会变得足够优秀吗？优秀到让他们不用担心自己的后事，优秀到能够不留遗憾地送别他们？<br>我要送别多少人，体验多少次今天体验过的恐惧，才能不再恐惧呢？<br>到时候我会没有出息地说出诸如“对不起，要是再多点时间就好了”之类的话吗？<br>我把死亡想得太过温柔，把离别想得太过轻松，以至于忽略了它们将伴随我的一生<br>在敲击声不断的督促下我终于明白：</p>
<blockquote>
<p>关于死亡，关于离别，我尚且什么都不明白，而在我什么都没有准备好的时候，丧钟已经悄悄响起</p>
</blockquote>
<p>快点长大吧，趁着一切为时未晚</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/06/%E9%9B%BE%E9%83%BD%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/%E9%9B%BE%E9%83%BD%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">雾都小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-06 20:10:28" itemprop="dateCreated datePublished" datetime="2023-08-06T20:10:28+08:00">2023-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-28 13:00:35" itemprop="dateModified" datetime="2024-02-28T13:00:35+08:00">2024-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">游记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>昨晚到家匆匆忙忙，飞机误点加上打车软件的背刺，回到家已经是半夜一两点的事情了。今早又不紧不慢地睡到十点左右起床清空行李箱，出去吃顿饭剪个头发，半个下午也就没了，回到家又要做题，吃完晚饭再和父亲唠两句，等到真的空下来了，也已经是夜里了</p>
<p>一下子从旅行的状态里回来，一时间还真有点不习惯，而既然现在自己已经闲了下来，那么也是时候写一下姗姗来迟的游记了</p>
<p>我这个人很少旅行，倒也不是不喜欢，只是单纯地很懒：懒得赶路，懒得做攻略，懒得离开能够给我带来足够安全感的独属于自己的房间<br>我去过的地方虽然不算多，却也不算少得可怜——当然绝大多数都是江浙沪包邮地区，类似于台州、南京、苏州之类的小地方<br>虽说我最近几年也出去到某个地方游山玩水过，但直到最近我才意识到：当我准备从大脑的某个角落里搜寻出自己曾经在这些那些地方的所见所闻所感，将其清洁一下，端上名为回忆的货架重新贩卖时，这商品却已经破损不堪，程度之深以至于我甚至没有办法从记忆的碎片中提取出一点旅途中无关紧要的琐事细细品味，只能够任凭抽象的诸如“那片海滩”、“那座山”来强迫自己抢回几片尚未被时间偷走的拼图<br>怕是要怪罪我年纪轻轻就有了少年痴呆的迹象，又或是要归咎于自己不解风情不善于用文字和照片记录下人生仅此一次的风景，总之，过去那几段国内也好国外也罢，我本以为能够给将来的自己留下深刻印象的旅途，如今看来却是完美地没能够完成它的历史使命</p>
<p>旅行的意义在于：能够在为期几天的时间里逃离一成不变的日子、能够在已经被日常晒成灰黑的视网膜上重新泼上色彩、能够见识远在习以为常的世界之外更加遥远的世界<br>我知道像我曾经走马观花的旅行不过是一种浪费，手机里长时间打开的游戏更是对时间的辜负，长此以往，旅行就失去了乐趣，而失去了乐趣的娱乐活动，其本身的价值也就一落千丈<br>我不希望自己事到如今依旧犯下和数年前一样的错误，所以这次的雾都之旅，我尽可能地自己去想、去规划、去见证，不仅仅是把视线放在热门的景点，更多的是关注重庆整座城市的犄角旮旯和不经意间的一瞥。我感到自己的灵魂终于没有再被沪上的安逸所束缚，江南的温柔如水也终究还是被川渝的火辣所替代——何尝不是一种比单纯的打卡式旅游更加能够放松和充实自己的手段</p>
<p>坐拥8万平方公里，3千万常住人口的雾都并不吝啬它的气魄，也同样不在乎外来者的存在。走在洪崖洞和解放碑附近的街道上，熙攘的人群淹没小小的个体，找不到自己的锚点；而环顾四周，无处不充斥着年轻人的气息，又仿佛看到了身为他们其中一份子的自己的位置<br>重庆这座城，无论横着走还是竖着走，无论上坡路还是下坡路，都令人胆战心惊——每当抬头，眼眸中倒映着的是看不到尽头的高楼；每当远眺，又觉得自己已经走了相当长的路聊以慰藉，不知不觉又陷入了名为征服的好胜心之中<br>不比上海灯红酒绿纸醉金迷的诱惑，重庆的魅力在于，你明明知道与眼前的荣华富贵相隔一条街道的地方就是几乎空无一人的老旧广场，你明明当下这人头攒动的名胜附近有着格格不入的烂尾楼，你明明知道山顶有着最美丽的鸟瞰视角而上山的路很远走起来很累，你明明知道重庆会不加掩饰地把光鲜与破败揉在一起粗暴地展现在你面前，却仍愿意迈开步子被它吞没，短暂地成为它的一部分，揭下它的面纱<br>最后在登上飞机之前向这座距离家乡一千五百多公里的城市道别，我心中长期以来心里莫名的包袱才终于放下：</p>
<blockquote>
<p><em>或许在过去的数年间的旅途中，我从未真正离开过上海</em><br><em>但至少这一次除外</em></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/02/%E4%B8%AD%E5%9B%BD%E4%BA%BA%E8%A2%AB%E5%BD%A2%E5%BC%8F%E4%B8%BB%E4%B9%89PUA%E7%9A%84%E4%B8%80%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/02/%E4%B8%AD%E5%9B%BD%E4%BA%BA%E8%A2%AB%E5%BD%A2%E5%BC%8F%E4%B8%BB%E4%B9%89PUA%E7%9A%84%E4%B8%80%E7%94%9F/" class="post-title-link" itemprop="url">中国人被形式主义PUA的一生</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-02 15:35:38" itemprop="dateCreated datePublished" datetime="2023-07-02T15:35:38+08:00">2023-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-07 23:18:39" itemprop="dateModified" datetime="2023-07-07T23:18:39+08:00">2023-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当我在室外集合，撑着把伞也阻止不了自己半个身子的衣服都被打个湿透的时候；当我坐在体育馆里，听着他们鼓动我们喊出足够刷新羞耻心下限的口号的时候；当我为了所谓“仪式”的排练，在座位上不断站起来又坐下的时候<br>我惊奇地发现自己其实已经没有感到愤怒的动力了</p>
<blockquote>
<p>“军训是人生中重要的一课，训过一次就能受益良久……”<br>“我代表xxx，向xxx宣战”<br>“不要害怕吃苦，吃苦是福……”</p>
</blockquote>
<p>诸如此类的话，过去的我能从脑子里面一秒调出来三句反驳的句子，能从几个方面来据理力争，莫名的灼热能从胃里翻涌到脑袋，再途径咽喉直达嘴巴一吐为快<br>但我现在觉得没必要了<br>哪怕他们不开口，我也知道他们会说些什么<br>哪怕他们光坐着，我也知道这个会场在接下来的一两个小时会发生什么<br>重复度高达99%的事件一遍又一遍地重演，追根溯源甚至连脚后跟落下连带溅起的尘埃都那么相似，连通知公告字里行间的臭味都高度一致，在我人生过去的十九年里以不同的面貌、不同的声音、不同的视角演出相同的戏码，奏着相同的乐曲，导向相同的结局<br>所以没有必要浪费精力去听、去骂、去愤怒<br>名为形式主义的糟粕在过去，在现在，也会在未来</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="愚者大人的铁质卷烟盒"
      src="/images/NiJiKa.GIF">
  <p class="site-author-name" itemprop="name">愚者大人的铁质卷烟盒</p>
  <div class="site-description" itemprop="description">琐碎和思考的堆放处</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jinziguan123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jinziguan123" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18917950960@163.com" title="E-Mail → mailto:18917950960@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">愚者大人的铁质卷烟盒</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
