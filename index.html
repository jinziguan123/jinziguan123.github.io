<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="琐碎和思考的堆放处">
<meta property="og:type" content="website">
<meta property="og:title" content="CigaCase">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="CigaCase">
<meta property="og:description" content="琐碎和思考的堆放处">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="愚者大人的铁质卷烟盒">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CigaCase</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CigaCase</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/14/%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/14/%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">如何用Redis实现消息队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-14 15:30:20 / 修改时间：22:11:44" itemprop="dateCreated datePublished" datetime="2024-03-14T15:30:20+08:00">2024-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是消息队列（MQ）"><a href="#什么是消息队列（MQ）" class="headerlink" title="什么是消息队列（MQ）"></a>什么是消息队列（MQ）</h1><p>顾名思义，将消息以队列的形式缓存，生产者（producer）和消费者（consumer）分别使用队列的两个端口进行消息的收发</p>
<h2 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h2><p>消息队列有两个核心能力：解耦和削峰</p>
<ul>
<li><p>解耦：</p>
<p>如果没有消息队列，那么在一次业务流程中，上游的http或者rpc发出请求之后，下游的消费者需要马上进行反馈，否则整个流程就会一直阻塞，这即浪费时间，又浪费CPU性能</p>
<p>因此我们需要一个能够持久化存放请求的容器，这就是消息队列的解耦——将生产者和消费者的应用进行解耦</p>
</li>
<li><p>削峰</p>
<p>如果在某一时刻，生产者给消费者生成了大量的请求，而消费者无法一次性全部消费，那么会产生消息的丢失</p>
<p>而有了消息队列，就可以分批次处理数量过多的请求</p>
</li>
</ul>
<h2 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h2><p>作为消息队列组件，需要满足一些要求：</p>
<ul>
<li><p>消息不丢失</p>
<p>很好理解，毕竟如果消息易失，那么有没有消息队列就都没太大区别了，这一方面可以分为三个部分来看待：</p>
<ul>
<li>生产者将消息投递到MQ的时候不出现丢失</li>
<li>消息存放在MQ时不丢失</li>
<li>消费者从MQ消费消息时不出现丢失</li>
</ul>
<p>针对第二点，各个MQ组件基本都是基于数据落盘+数据备份的方式来完成的</p>
<p>而对于第一第三点，则是通过两个交互环节中的ack机制保证的，譬如生产者向MQ中投递消息，如果没有收到MQ的ack返回确认，那么生产者就应当一直投递这个消息给MQ；另一方面，消费者也需要避免接收重复的消息，所以对于下游的消费者，同样需要具备消息幂等去重的能力</p>
</li>
<li><p>支持消息存储</p>
<p>就像前面提到的，MQ至少需要支持一定规模的数据的存放，而且这种存放需要持久性，能够让消费者自由选择时间进行消费操作</p>
</li>
</ul>
<h2 id="流程类型"><a href="#流程类型" class="headerlink" title="流程类型"></a>流程类型</h2><p>根据消费者的消费流程，MQ可以被分为两种类型：</p>
<ul>
<li><p>Push型：</p>
<p>指当生产者将消息投递到MQ时，由MQ主动将消息以推送的方式发送给各个订阅了的消费者</p>
</li>
<li><p>Pull型：</p>
<p>当MQ中存在消息时，由消费者主动执行拉取消息的操作来获取消息</p>
</li>
</ul>
<p>两种类型各有优劣，实际操作中需要按需取舍</p>
<h1 id="如何用Redis实现消息队列"><a href="#如何用Redis实现消息队列" class="headerlink" title="如何用Redis实现消息队列"></a>如何用Redis实现消息队列</h1><p>Redis虽然是一种非关系型数据库，但是其部分数据结构是能够支持实现消息队列组件的</p>
<h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p>首先需要指出可能存在的一些问题</p>
<ul>
<li><p>存储昂贵</p>
<p>由于Redis是基于内存实现的缓存中间件，所以存储消息容量的限制比较大</p>
</li>
<li><p>数据丢失</p>
<ul>
<li><p>由于Redis是基于内存实现的缓存中间件，所以不可避免地会产生丢失数据的风险（比如断电和宕机），虽然有rdb&#x2F;aof这种持久化机制，但是无法做到百分百安全</p>
</li>
<li><p>此外，Redis走的是ap高可用流派，数据的主从复制流程是异步的，主从切换时数据存在弱一致的问题</p>
</li>
</ul>
</li>
</ul>
<h2 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h2><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>一种比较容易想到的思路就是使用Redis的List结构，这是一个双向链表，天然契合MQ的队列模型，只需要使用LPUSH和RPOP进行消息的投递和读取即可</p>
<p>这种方法的缺点也是显而易见的：如果生产者生产消息的速度赶不上消费者的消费速度，那么消费者使用RPOP拉取消息的时候就会立刻返回空值nil，也就是说，需要消费者不断轮询地访问，这种高频的自旋对于CPU是一种无用的损耗；另一方面，如果让消费者每次轮询之后休眠一段时间，那么可能会导致消息处理不及时，也是我们不希望看到的情况</p>
<p>最理想的方案是：在List中有数据到达时，消费者马上能够意识到，并且处理数据，此外始终保持睡眠状态，也就是阻塞态</p>
<p>因此，我们可以使用Redis中的BRPOP指令来代替RPOP，即可弥补上述的缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP my_topic 0</span><br></pre></td></tr></table></figure>

<p>其中topic后面的数字代表阻塞等待时长，达到此阈值仍未获取数据时会返回nil；如果设置为 0 ，则代表没有这个超时限制</p>
<h3 id="局限性分析"><a href="#局限性分析" class="headerlink" title="局限性分析"></a>局限性分析</h3><p>尽管解决了阻塞问题，List仍然不能算是一个合格的消息队列组件，原因如下：</p>
<ul>
<li><p>无法支持发布&#x2F;订阅模式</p>
<p>显然List的消费者和生产者是一对一的，因为数据在POP出去之后就不复存在，只此一份，如果我们有多个消费者，每个都需要消费者所生产的数据，那么List就束手无策了</p>
</li>
<li><p>无法支持消费端ack机制</p>
<p>当消费者出现了宕机等意外，没有一种有效的手段告诉MQ消息处理失败的反馈，在这种情况下，一旦数据POP，就真的完全丢失了</p>
</li>
</ul>
<h2 id="Redis-pub-x2F-sub"><a href="#Redis-pub-x2F-sub" class="headerlink" title="Redis pub&#x2F;sub"></a>Redis pub&#x2F;sub</h2><p>为了解决无法支持发布&#x2F;订阅模式的问题，Redis提供了pub&#x2F;sub机制，全称为publisher&#x2F;subscriber</p>
<h3 id="具体方法-1"><a href="#具体方法-1" class="headerlink" title="具体方法"></a>具体方法</h3><p>pub&#x2F;sub模式会在两者之间建立一个用于实时通信的信道channel，在传递消息时，会根据channel查找到所有建立订阅关系的subscriber，一一传送消息</p>
<p>操作指令为：</p>
<blockquote>
<p>发布者：publish topic_name message</p>
<p>比如：publish my_new_message 今天天气怎么样</p>
<p>订阅者：subscribe topic_name</p>
<p>订阅者会使用阻塞模式进行监听，解决了List方法中的CPU浪费问题</p>
</blockquote>
<p>这里解释一下背后的原理：</p>
<ul>
<li>首先，消费方 subscriber 通过 subscribe 指令建立和指定 channel 之间的订阅关系. 这时在 redis 中会维护好 channel 和对应 subscriber 列表的映射关系，并在内存中为每个在线活跃的 subscriber 分配好一个缓冲区 buffer，用以承载后续到来的消息数据</li>
<li>接下来随着 publisher 执行 publish 指令，往对应 channel 中投递消息后，此时 redis 会实时查看 channel 对应 subscriber 名单，往每个 subscriber 的缓冲区 buffer 中推送这条数据</li>
<li>各执行了 subscribe 指令的 subscriber 会处于阻塞监听缓冲区 buffer 的状态，随着新数据到达，subscriber 会获取到这笔数据</li>
</ul>
<p>基于这个流程，我们能看出来，pub&#x2F;sub 对于 channel 以及 subscribers 之间的实时映射关系存在强依赖. 因此在操作的执行顺序上，我们需要保证先执行 subscribe 指令，再执行 publish 执行，否则前几笔 publish 投递的数据就会因为不存在 subscriber 而被直接丢弃</p>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>pub&#x2F;sub模式最大的优点就是实现了发布&#x2F;订阅能力，然而其缺点也很明显：关于消息丢失的处理</p>
<ul>
<li><p>缺乏ack机制：</p>
<p>与List相同，没有ack意味着pub&#x2F;sub模式依然没有办法提醒发布者消息处理的成功与否，无法执行消息的重放</p>
</li>
<li><p>缺乏消息储存能力</p>
<p>Redis的pub&#x2F;sub模式相当于golang中的无缓冲型channel，仅仅是维护了channel和subscribers之间的映射关系，每当消息来临，不会停留在channel中，而是直接送往映射的buffer中，所以会出现以下问题：</p>
<ul>
<li>subscriber 宕机：倘若某个 subscriber 中途宕机，则会被踢出名单，在恢复前的这段时间内，到达的消息都会彻底与这个 subscriber 无缘</li>
<li>Redis 宕机：每条 publish 的消息都会第一时间分发到 subscriber 对应的内存缓冲区中，而这个缓冲区是完全基于内存实现的易失性存储，一旦 Redis 服务端宕机，缓冲区中的数据就完全丢失且不可恢复了；此外，pub&#x2F;sub 模式下的消息数据不属于 Redis 中的基本数据类型，因此 redis 中的持久化机制 rdb 和 aof 对于 pub&#x2F;sub 中的数据是完全不生效的，数据丢失的可能性大幅度提高</li>
<li>subscriber消息积压：由于消息数据会被放在 Redis 侧各 subscriber 的缓冲区 buffer 中，这部分空间是相对有限的，一旦某个 subscriber 因为消费能力弱，导致 buffer 中的的数据发生积压，此时 Redis 很可能会自动把 subscriber 踢除下线，于是这部分数据也丢失了</li>
</ul>
<p>对于最后这一点，可以在redis.conf文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60s</span><br></pre></td></tr></table></figure>

<p>对应的含义是，倘若某个 subscriber 的缓冲区 buffer 大小达到 32MB，则 subscriber 会被踢下线；倘若缓冲区内数据量在连续 60s 内达到 8MB 大小，subscriber 也会踢下线</p>
</li>
</ul>
<h2 id="Redis-Streams"><a href="#Redis-Streams" class="headerlink" title="Redis Streams"></a>Redis Streams</h2><h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><p>首先需要介绍一下几个核心的操作指令，所有指令都可以在<a target="_blank" rel="noopener" href="https://redis.io/commands/">官方文档</a>中找到：</p>
<ul>
<li><p>生产消息：</p>
<p>使用该指令可以向topic中投放一组键值对消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XADD my_streams_topic * key1 value1</span><br><span class="line">&quot;1710412272535-0&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>My_streams_topic：topic名称</li>
<li>*：表示该消息自动生成唯一标识id，基于时间戳+自增序列号生成</li>
<li>Key1、value1:输入的键值对</li>
</ul>
</li>
<li><p>消费消息：</p>
<p>使用该指令可以从对应的topic中获取消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread [BLOCK] [Time] streams my_streams_topic 0-0</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710412272535-0&quot;</span><br><span class="line">         2) 1) &quot;key1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>BLOCK：表示是否使用阻塞消费模式</li>
<li>Time：如果加入BLOCK参数，那么此处需要填写time表示阻塞等待时间，超过这个时间就会返回nil；设置为0表示不设置超时阈值</li>
<li>streams：表示从一个streams对象读取消息</li>
<li>my_streams_topic：topic名称</li>
<li>0-0：表示从头开始消费；这里如果填写的是某条消息的id的话，就会从这条消息之后开始消费</li>
</ul>
</li>
</ul>
<p>此外streams支持发布&#x2F;订阅模式，可以保证消息被多个消费者组访问</p>
<ul>
<li><p>创建消费者组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATE my_streams_topic my_group 0-0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<ul>
<li>my_streams_topic：topic 名称</li>
<li>my_group：消费者组名称</li>
<li>0-0：从头开始消费</li>
</ul>
</li>
<li><p>基于消费者组消费信息：</p>
<p>同一份数据在同一个消费者组下只会被消费到一次. 不同消费者组各自能获取到独立完整的消息数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP my_group consumer1 BLOCK 0 STREAMS my_streams_topic &gt;</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710412272535-0&quot;</span><br><span class="line">         2) 1) &quot;key1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">      2) 1) &quot;1710413025712-0&quot;</span><br><span class="line">         2) 1) &quot;key2&quot;</span><br><span class="line">            2) &quot;value2&quot;</span><br><span class="line">      3) 1) &quot;1710413031719-0&quot;</span><br><span class="line">         2) 1) &quot;key3&quot;</span><br><span class="line">            2) &quot;value3&quot;</span><br><span class="line">      4) 1) &quot;1710413036009-0&quot;</span><br><span class="line">         2) 1) &quot;key4&quot;</span><br><span class="line">            2) &quot;value4&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>my_group: 消费者组名称</li>
<li>Consumer1：消费者名称</li>
<li>my_streams_topic：topic 名称</li>
<li>BLOCK 0: 采用阻塞等待的模式，0 代表没有超时上限</li>
<li>&gt;：读最新的消息 (尚未分配给某个 consumer 的消息)</li>
</ul>
<p>此外还有一种消费模式，读取的是已经分配给当前消费者，但是还未经确认的旧消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP my_group consumer1 BLOCK 0 STREAMS my_streams_topic 0-0</span><br><span class="line">1) 1) &quot;my_streams_topic&quot;</span><br><span class="line">   2) 1) 1) &quot;1710413250364-0&quot;</span><br><span class="line">         2) 1) &quot;key5&quot;</span><br><span class="line">            2) &quot;value5&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>0-0：标识读取已分配给当前 consumer ，但是还没经过 xack 指令确认的消息</li>
</ul>
<p><strong>&gt; 与 0-0，两者之间的区别在于，“&gt;”读取新消息，“0-0”读取旧消息</strong></p>
</li>
<li><p>确认消息：</p>
<p>通过 xack 指令，携带上消费者组、topic 名称以及消息 id，能够完成对某条消息的确认操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XACK my_streams_topic my_group 1710413250364-0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<ul>
<li>my_streams_topic：topic 名称</li>
<li>my_group：消费者组名称</li>
<li>1710413250364-0：消息 id</li>
</ul>
</li>
</ul>
<h2 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><p>首先是最明显的优点：</p>
<ul>
<li><p>支持发布&#x2F;订阅模式</p>
<p>Redis Streams 引入了消费者组 group 的概念，因此是能够保证各个消费者组 consumer group 均能够获取到一份独立而完整的消息数据</p>
</li>
<li><p>数据可持久化</p>
<p>Redis 中的 streams 和 string、list 等数据类型一样，都能够通过 rdb( redis database)、aof( append only file) 的持久化机制进行落盘存储，能够在很大程度上降低数据丢失的概率</p>
</li>
<li><p>支持消费端 ack 机制</p>
<p>Redis Streams 中另一项非常重要的改进，是支持 consumer 的 ack 能力，consumer 在处理好某条消息后，能通过 xack 指令对该消息进行确认。这样对于没经过 ack 确认的消息，Redis Streams 还是为 consumer 保留了重新消费的能力</p>
</li>
<li><p>支持消息缓存</p>
<p>和 pub&#x2F;sub 模式不同的是，Redis Streams 中会实际开辟内存空间用于存储 Streams 中的数据，因此哪怕某个 consumer group 是在消息生产之后才完成注册操作，也能够进行消息溯源，从 topic 起点开始执行消息的消费操作</p>
<p>然而由于Redis是基于内存实现的存储，因此如果消息量过于庞大，可能会造成很大的资源压力甚至out of memory。因此，可以在XADD指令中加上maxlen，显式地设定topic中能缓存的数据长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD my_topic MAXLEN 10000 * key1 value1</span><br></pre></td></tr></table></figure>

<ul>
<li>最多缓存10000条数据</li>
</ul>
</li>
</ul>
<h1 id="整体对比"><a href="#整体对比" class="headerlink" title="整体对比"></a>整体对比</h1><p>现在对Redis实现MQ的各个方法做个比较：</p>
<table>
<thead>
<tr>
<th><strong>MQ 实现方案</strong></th>
<th><strong>发布&#x2F;订阅能力</strong></th>
<th><strong>消费端ACK机制</strong></th>
<th><strong>消息缓存能力</strong></th>
<th><strong>数据丢失风险</strong></th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>低</td>
</tr>
<tr>
<td>pub&#x2F;sub</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>高</td>
</tr>
<tr>
<td>Streams</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>低</td>
</tr>
</tbody></table>
<p>可以看到，在各项能力上 List 和 pub&#x2F;sub 互有千秋，而 Streams 可以说是兼具了各方面的优势，称得上是已经趋近于成熟的MQ实现方案</p>
<p>下面我们再进一步拿 Redis Streams 和业界专业的 MQ 组件进行对比</p>
<table>
<thead>
<tr>
<th><strong>MQ组件</strong></th>
<th><strong>消息存储介质</strong></th>
<th><strong>消息分区&#x2F;并发能力</strong></th>
<th><strong>数据丢失风险</strong></th>
<th><strong>运维成本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Redis Streams</td>
<td>内存</td>
<td>不支持</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>Kafka</td>
<td>磁盘</td>
<td>支持</td>
<td>理论上不存在</td>
<td>偏高</td>
</tr>
</tbody></table>
<p>由于Redis Streams在存储上需要使用内存，因此消息存储容量相对有限；且同一个 topic 的数据由于对应为同一个 key，因此会被分发到相同节点，无法实现数据的纵向分治，因此不具备类似于 kafka 纵向分区以提高并发度的能力</p>
<p>因此使用Redis作为MQ的主要优势就在于运维成本低，如果在实际的业务流程中，对于数据的精度没有特别高的要求，那么使用Redis Streams这种轻量化的MQ方案不失为一种好的选择</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/29/CMU15-445-2022Fall-Lecture-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/29/CMU15-445-2022Fall-Lecture-14/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-29 12:22:46 / 修改时间：12:25:04" itemprop="dateCreated datePublished" datetime="2024-02-29T12:22:46+08:00">2024-02-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-14-Query-Planning-amp-Optimization"><a href="#Lecture-14-Query-Planning-amp-Optimization" class="headerlink" title="Lecture 14: Query Planning &amp; Optimization"></a>Lecture 14: Query Planning &amp; Optimization</h1><p>主要讲了查询的规划以及优化</p>
<p>SQL查询在不同的规划下会有显著的性能上的差异，在先前介绍Join的那一章课已经提到过了</p>
<h1 id="Query-Optimization-Techniques"><a href="#Query-Optimization-Techniques" class="headerlink" title="Query Optimization Techniques"></a>Query Optimization Techniques</h1><p>需要注意的是，决定优化的方式、规模与执行查询一样是需要占用时间的，所以查询的优化不在于要做到极致（Query Optimization是一个NP-Hard问题），而是在可能的几个计划之中选取折中的一个</p>
<ul>
<li><p>Heuristics&#x2F;Rules：</p>
<ul>
<li><p>Rewrite the query to remove stupid&#x2F;inefficient things</p>
</li>
<li><p>Does not require a cost model</p>
</li>
</ul>
</li>
<li><p>Cost-based Search</p>
<ul>
<li>Use a cost model to evaluate multiple equivalent plans and pick the one with the lowest cost</li>
</ul>
</li>
</ul>
<h2 id="Logical-VS-Physical-Plans"><a href="#Logical-VS-Physical-Plans" class="headerlink" title="Logical VS. Physical Plans"></a>Logical VS. Physical Plans</h2><p>其实优化查询无非两个步骤：在逻辑上对操作对象进行编排（比如是Join(A,B)还是Join(B,A)，是否要下移谓词等等）、要选择用哪种方式来优化（比如对于nested loop join，是否要更换为nested index join，sort+limit是否要更换为topn算法等等），这就是所谓的逻辑计划与物理计划</p>
<h2 id="Heuristics-x2F-Rules"><a href="#Heuristics-x2F-Rules" class="headerlink" title="Heuristics&#x2F;Rules"></a>Heuristics&#x2F;Rules</h2><p>如果两个关系代数表达式 (Relational Algebra Expressions) 如果能产生相同的 tuple 集合，我们就称二者等价。DBMS 可以通过一些 Heuristics&#x2F;Rules 来将关系几何表达式转化成成本更低的等价表达式，从而达到查询优化的目的。这些规则通常试用于所有查询，如：</p>
<ul>
<li>Predicate Pushdown</li>
<li>Projections Pushdown</li>
</ul>
<h3 id="Predicate-Pushdown"><a href="#Predicate-Pushdown" class="headerlink" title="Predicate Pushdown"></a>Predicate Pushdown</h3><p>Predicate 通常有很高的选择性，可以过滤掉许多无用的数据。将 Predicate 推到查询计划的底部，可以在查询开始时就更多地过滤数据</p>
<p>核心思想如下：</p>
<ul>
<li>越早过滤越多数据越好</li>
<li>重排 predicates，使得选择性大的排前面</li>
<li>将复杂的 predicate 拆分，然后往下压，如 <code>X=Y AND Y=3</code> 可以修改成 <code>X=3 AND Y=3</code></li>
</ul>
<h3 id="Replace-Cartesian-Product"><a href="#Replace-Cartesian-Product" class="headerlink" title="Replace Cartesian Product"></a>Replace Cartesian Product</h3><p>将笛卡尔积替换成Join，不多赘述</p>
<h3 id="Projections-Pushdown"><a href="#Projections-Pushdown" class="headerlink" title="Projections Pushdown"></a>Projections Pushdown</h3><p>在行存储数据库中，越早过滤掉不用的字段越好，因此将 Projections 操作往查询计划底部推也能够缩小中间结果占用的空间大小</p>
<p><strong>需要注意的是这种方法对于列存储数据库是不管用的</strong></p>
<h2 id="Cost-based-Search"><a href="#Cost-based-Search" class="headerlink" title="Cost-based Search"></a>Cost-based Search</h2><p>除了 Predicates 和 Projections 以外，许多操作没有通用的规则，如 Join：Join 操作既符合交换律又符合结合律，等价关系代数表达式数量庞大，这时候就需要一些成本估算技术，将过滤性大的表作为 Outer Table，小的作为 Inner Table，从而达到查询优化的目的</p>
<p>由于需要遍历各种类型的plan来决定最终的选择，所以这里可以简单划分成三种类型的plan：</p>
<ul>
<li>Single relation</li>
<li>Multiple relations</li>
<li>Nested sub-queries</li>
</ul>
<h3 id="Single-relation-Query-Planning"><a href="#Single-relation-Query-Planning" class="headerlink" title="Single relation Query Planning"></a>Single relation Query Planning</h3><p>对于这类查找，只需要用简单的启发式方法譬如顺序扫描、二分搜索、索引扫描等就够用了</p>
<p>具体来说就是将查询拆分成若干个小块，为每一块都生成一个逻辑运算符，为每一个逻辑运算符都生成一组物理运算符，然后依次迭代构建一棵left-deep join tree（就是类似于哈夫曼树一样的结构，两个节点由join作为父节点），这样可以最小化工作量</p>
<p>这里直接去看课上那个Artist、Album、Appears的例子更加直观，整个搜索的过程就是在不断地[枚举、计算代价]</p>
<h3 id="Multi-relation-Query-Planning"><a href="#Multi-relation-Query-Planning" class="headerlink" title="Multi-relation Query Planning"></a>Multi-relation Query Planning</h3><p>又分为自顶向下与自底向上两种优化方式，这里重点讲了自顶向下的思路</p>
<blockquote>
<p> 比如一个操作的目标是<code>A join B join C</code>，这是我们的目标，也是优化的根节点。接下来需要考虑有哪些方法可以得到这个根节点，比如可以选择<code>Hash_Join(A join B, C)</code>或者<code>SM_Join(A join B, C)</code>两者之间选择一个代价更小的（这里假设hash join代价更小），然后继续决策有哪些方法可以得到hash join这个节点</p>
</blockquote>
<h3 id="Nested-Sub-Queries"><a href="#Nested-Sub-Queries" class="headerlink" title="Nested Sub-Queries"></a>Nested Sub-Queries</h3><p>有的时候一个查询的嵌套太深，如果对于每一个嵌套都分别优化，而没有一个整体的优化方向的话，最终会导致计划十分低效。因此可以考虑将一个嵌套查询扁平化，或者至少减少其嵌套层数，尽可能水平展开</p>
<p>这就延伸出了两种方法：</p>
<ul>
<li>重写查询，降低语句之间的关联性或者将其扁平化</li>
<li>分解嵌套查询，将其结果保存在临时的表中</li>
</ul>
<h4 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h4><p>直接举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select name from sailors as s</span><br><span class="line">	where exists(</span><br><span class="line">		select * from reservers as r</span><br><span class="line">  		where s.sid = r.sid</span><br><span class="line">  		and r.day = &#x27;2022.1.1&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以被改写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name from sailors as s, reservers as r</span><br><span class="line">	where s.sid = r.sid </span><br><span class="line">		and r.day = &#x27;2022.1.1&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Decomposing-Queries"><a href="#Decomposing-Queries" class="headerlink" title="Decomposing Queries"></a>Decomposing Queries</h4><p>同样举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT S.sid, MIN(R.day)</span><br><span class="line"> 	FROM sailors S, reserves R, boats B</span><br><span class="line">		WHERE S.sid = R.sid</span><br><span class="line"> 			AND R.bid = B.bid</span><br><span class="line"> 			AND B.color = &#x27;red&#x27;</span><br><span class="line"> 			AND S.rating = (SELECT MAX(S2.rating)</span><br><span class="line"> 		FROM sailors S2)</span><br><span class="line">	GROUP BY S.sid</span><br><span class="line">		HAVING COUNT(*) &gt; 1</span><br></pre></td></tr></table></figure>

<p>可以改写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(rating) FROM sailors</span><br><span class="line"></span><br><span class="line">SELECT S.sid, MIN(R.day)</span><br><span class="line"> 	FROM sailors S, reserves R, boats B</span><br><span class="line">		WHERE S.sid = R.sid</span><br><span class="line"> 			AND R.bid = B.bid</span><br><span class="line"> 			AND B.color = &#x27;red&#x27;</span><br><span class="line"> 			AND S.rating = (SELECT MAX(S2.rating)</span><br><span class="line"> 		FROM sailors S2)</span><br><span class="line">	GROUP BY S.sid</span><br><span class="line">		HAVING COUNT(*) &gt; 1</span><br></pre></td></tr></table></figure>

<p>毕竟<code>(SELECT MAX(S2.rating)</code>对于整个查询来说只是一个常量</p>
<h3 id="Cost-Estimation"><a href="#Cost-Estimation" class="headerlink" title="Cost Estimation"></a>Cost Estimation</h3><p>一个查询需要花费多长时间，取决于许多因素 </p>
<ul>
<li>CPU: Small cost; tough to estimate</li>
<li>Disk: #block transfers</li>
<li>Memory: Amount of DRAM used</li>
<li>Network: #messages</li>
</ul>
<p>但本质上取决于：<strong>整个查询过程需要读入和写出多少 tuples</strong></p>
<p>因此 DBMS 需要保存每个 table 的一些统计信息，如 attributes、indexes 等信息，有助于估计查询成本。值得一提的是，不同的 DBMS 的搜集、更新统计信息的策略不同</p>
<h3 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h3><p>对于任意table R，DBMS都保存了关于R的一些相关信息比如：</p>
<ul>
<li>$$N_{R}$$：R中tuple的数量</li>
<li>$$V(A, R)$$：R中A属性的不同取值的个数</li>
<li>$$A_{max}, A_{min}$$：A属性的最大值和最小值</li>
</ul>
<p>利用上面这些数据可以得到R中A属性的每一个值所对应的平均记录个数<br>$$<br>SC(A, R) &#x3D;N_R &#x2F; V(A, R)<br>$$<br>利用以上信息，就可以针对不同的predicate，预估不同的selectivity：</p>
<ul>
<li>Equality</li>
<li>Range</li>
<li>Negation</li>
<li>Conjunction</li>
<li>Disjunction</li>
</ul>
<h4 id="Equality-Predicate"><a href="#Equality-Predicate" class="headerlink" title="Equality Predicate"></a>Equality Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from people where age = 2</span><br></pre></td></tr></table></figure>

<p>假设people中有5个人，所有的age一共有5个取值，则$$N_R$$&#x3D;5，$$V(age, people)$$&#x3D;5：<br>$$<br>sel(A &#x3D; constant) &#x3D; SC(P) &#x2F; V(A, R) &#x3D; \frac{1}{5}<br>$$</p>
<h4 id="Range-Predicate"><a href="#Range-Predicate" class="headerlink" title="Range Predicate"></a>Range Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from people where age &gt;= 2</span><br></pre></td></tr></table></figure>

<p>则可以利用最大值最小值来估计：<br>$$<br>sel(A &gt;&#x3D; a) &#x3D; (A_{max} - a) &#x2F; (A_{max} - A_{min})<br>$$</p>
<h4 id="Negation-Predicate"><a href="#Negation-Predicate" class="headerlink" title="Negation Predicate"></a>Negation Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from people where age != 2</span><br></pre></td></tr></table></figure>

<p>其实就是Equality Predicate取个补集<br>$$<br>sel(not P) &#x3D; 1 - sel(P) &#x3D; 1 - SC(age &#x3D; 2) &#x3D; \frac{4}{5}<br>$$</p>
<h4 id="Conjunc-Predicate"><a href="#Conjunc-Predicate" class="headerlink" title="Conjunc Predicate"></a>Conjunc Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from people </span><br><span class="line">	where age = 2</span><br><span class="line">		and name like &#x27;A%&#x27;</span><br></pre></td></tr></table></figure>

<p>如果两个predicate是相互独立的话<br>$$<br>sel(P1 \bigwedge P2) &#x3D; sel(P1) \times sel(P2)<br>$$</p>
<h4 id="Disjunction-Predicate"><a href="#Disjunction-Predicate" class="headerlink" title="Disjunction Predicate"></a>Disjunction Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from people </span><br><span class="line">	where age = 2</span><br><span class="line">		or name like &#x27;A%&#x27;</span><br></pre></td></tr></table></figure>

<p>如果两个predicate相互独立，则有：<br>$$<br>sel(P1 \bigvee P2) &#x3D; sel(P1) + sel(P2) - sel(P1 \bigwedge P2) &#x3D; sel(P1) + sel(P2) - sel(P1) \times sel(P2)<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-12-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-12-13/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 12.13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:49:20 / 修改时间：13:00:25" itemprop="dateCreated datePublished" datetime="2024-02-28T12:49:20+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-12-13-Query-Execution"><a href="#Lecture-12-13-Query-Execution" class="headerlink" title="Lecture 12,13: Query Execution"></a>Lecture 12,13: Query Execution</h1><p>主要讲了SQL语句查询执行的相关问题</p>
<h1 id="Processing-Model"><a href="#Processing-Model" class="headerlink" title="Processing Model"></a>Processing Model</h1><p>首先是处理模型，定义了数据库中执行查询计划的三种模式，分别是：</p>
<ul>
<li>Iterator Model</li>
<li>Materialization Model</li>
<li>vectorization Model</li>
</ul>
<h2 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h2><p>又被称为Volcano Model或者Pipeline Model</p>
<ul>
<li><p>Iterator Model一共有三种基本的接口：Next()、Open()、Close()</p>
</li>
<li><p>该计算将关系代数中的每一种操作都抽象为一个operator，将整个SQL语句构造成一个operator树，这样一来，在进行查询的时候会从树顶向下不断调用next函数，而数据则会被自底向上拉取</p>
</li>
<li><p>迭代模型的优点：</p>
<ul>
<li>简单，每个operator可以单独实现逻辑，达到模块化处理，因此市面上有很多数据库都使用了迭代模型比如：SQLite、MongoDB、Impala、DB2、SQLServer、Greenplum、PostgreSQL、Oracle、MySQL</li>
</ul>
</li>
<li><p>迭代模型的缺点：</p>
<ul>
<li>查询树调用的Next接口次数太多，而且每次调用都指返回一条数据，使得CPU执行效率很低</li>
<li>Join、Subqueries、Order by等操作经常会阻塞</li>
</ul>
</li>
</ul>
<h2 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h2><p>物化模型优化了迭代模型的缺点：对于每一个operator，一次性处理所有的输入，处理完之后将所有结果一次性输出</p>
<p>伪代码看上去和火山模型大差不差，区别只在于每一个operator都会将结果放到一个out列表中，最后进行输出</p>
<ul>
<li>物化模型对于OLTP负载更加友好，因为每一个查询所涉及到的数据范围都是较小的，并且调用的函数更少</li>
<li>因此从另一方面来说，物化模型不适用于OLAP负载（因为OLAP涉及到的中间数据太多）</li>
</ul>
<h2 id="Vectorization-Model"><a href="#Vectorization-Model" class="headerlink" title="Vectorization Model"></a>Vectorization Model</h2><p>向量化模型与火山模型类似，对于每一种operator都要实现一种Next()函数，区别在于，向量化模型返回的是一批tuple，而不是火山模型中的一个tuple，可以简单理解成火山模型与物化模型两者的结合</p>
<p>该模型适用于OLAP数据库，使得中间的结果不需要溢出到磁盘，同时也能够减少Next函数的调用次数</p>
<h1 id="Access-Methods"><a href="#Access-Methods" class="headerlink" title="Access Methods"></a>Access Methods</h1><p>在执行查找的时候，DBMS需要一定的手段去访问叶子结点处的数据</p>
<p>一共可以分为三种方法</p>
<h2 id="Sequential-Scan"><a href="#Sequential-Scan" class="headerlink" title="Sequential Scan"></a>Sequential Scan</h2><p>最容易想到的就是顺序扫描：对于表中的每一个page，DBMS都从缓冲池中对其进行检索，并在此基础上遍历每一个tuple来决定是否要将其作为数据进行返回</p>
<ul>
<li>DBMS会保存一个游标（cursor），用来标记其上次访问的page&#x2F;slot</li>
</ul>
<h3 id="Sequential-Scan-Optimization"><a href="#Sequential-Scan-Optimization" class="headerlink" title="Sequential Scan : Optimization"></a>Sequential Scan : Optimization</h3><p>尽管顺序扫描是一种比较笨拙的方法，但可能也是我们唯一的选择</p>
<p>然而顺序扫描是可以进行优化的，我们在之前的课中已经接触过一些了，比如：</p>
<ul>
<li>Pre-Fetching（Lecture 6）</li>
<li>Buffer Pool Bypass（Lecture 6）</li>
<li>Parallelization（Lecture 13）</li>
<li>Heap Clustering（Lecture 8）</li>
<li>Late Materialization（Lecture 11）</li>
</ul>
<p>这节课讲了一个新的方法，Data Skipping</p>
<h4 id="Data-Skipping"><a href="#Data-Skipping" class="headerlink" title="Data Skipping"></a>Data Skipping</h4><p>有两种方法可以实现数据跳过组件：</p>
<ol>
<li><p>Approximate Queries（Lossy）</p>
<p>近似查询会首先对整张表做一个抽样，形成一个表的子集，对这个子集执行查询，这样能够得到一个近似的结果</p>
<p>近似查询是易失性的，这里的易失性应该是指会丢失一些本来应到能够找到的数据</p>
</li>
<li><p>Zone Map（Lossless）</p>
<p>这里重点介绍的方法就是Zone Map法，简单来说就是对于查询涉及到的每一个page，都实现处理出一些聚合属性，比如这个page上的MAX、MIN、AVG、SUM、COUNT，这样在查询到来的时候就能够直接进行比较，判断是否值得花时间遍历这个page，达到加速的效果</p>
<blockquote>
<p>比如现在我们有如下数据，我们要执行<code>select * from table where val &gt; 600</code>，DBMS拿到了查询指令和Zone Map进行比较，发现这个page的MAX值为400，显然整个page的数据都是我们不需要的，那么直接跳过这个page即可</p>
</blockquote>
</li>
</ol>
<h2 id="Index-Scan"><a href="#Index-Scan" class="headerlink" title="Index Scan"></a>Index Scan</h2><p>由DBMS来选择一个index来查找tuple（13章会详细解释DBMS根据哪几个方面的来选择index）</p>
<ul>
<li>索引扫描又分为单索引扫描和多索引扫描（Multi-Index Scan），两者的区别和特点从名字就可以看出来，需要知道的是，多索引扫描会根据查询条件，在多个索引上查询结果并且将结果集合做一个并集或者交集</li>
</ul>
<h1 id="Modification-Queries"><a href="#Modification-Queries" class="headerlink" title="Modification Queries"></a>Modification Queries</h1><p>负责修改数据库中的表以及相关索引的操作称为修改查询，这些查询的输出可以是数据记录的id，也可以是tuple（比如returning）</p>
<p>这里首先介绍了Halloween Problem（万圣节难题）：</p>
<p>譬如在火山模型的数据库中执行更新操作<code>update people set salary = salary + 100 where salary &lt; 1100</code>的时候，会首先根据index，调用Next（）查找出来目标tuple，删除、重新赋值、插入，由此完成更新</p>
<p>然而如果有一个tuple为：（Andy，999），在被更新之后会变成（andy，1099），此时这个tuple的物理位置已经改变，很有可能会被插入到原本位置之后，并且依然满足salary &lt; 1100的条件，所以会被第二次进行更新，变为（Andy，1199），这并不符合我们更新操作的目的</p>
<p>解决办法就是：跟踪所有修改过的记录id</p>
<h1 id="Expression-Evaluation"><a href="#Expression-Evaluation" class="headerlink" title="Expression Evaluation"></a>Expression Evaluation</h1><p>对于Where子句，DBMS会将其表示为一棵表达式树（expression tree），树中的不同结点代表不同的表达式类型例如：比较、析取、连接、算术运算符、常值、元祖属性引用等</p>
<p>还介绍了Prepare子句，类似于函数的功能</p>
<p>这一部分感觉就是普通的介绍，没有做很深入的讲解，看看就行</p>
<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>迄今为止我们所讨论的内容几乎都是基于数据流的角度来看待查询处理模型的，控制流以隐式的形式藏在一系列的查询操作中</p>
<p>而有了scheduler（调度器），我们就可以显式地明确控制流了</p>
<blockquote>
<p>以下是个人理解：</p>
<p>面向数据流是一件很复杂的事情，因为你没有办法非常细致地划分数据。比如人脑是没有办法清晰地认知：这一团数据是从哪里来的、要对它做什么、要把它发到哪里去之类的问题</p>
<p>但是面向控制流就会让上述的事情变得很简单明了，是一种抽象程度更高的方法，此外可能对于分布式存储的系统更加友好？因为可以将每一个控制任务push或者pull到远程主机做处理然后再传输回来，比单纯发送数据的方式封装程度更高？</p>
</blockquote>
<hr>
<h1 id="Parallel-x2F-Distributed"><a href="#Parallel-x2F-Distributed" class="headerlink" title="Parallel &#x2F; Distributed"></a>Parallel &#x2F; Distributed</h1><p>首先需要区分并行数据库和分布式数据库：</p>
<ul>
<li><p>首先需要明确的是，对于用户而言，两者是一样的，即对于某个查询返回某种结果，区别在于其内部设计</p>
</li>
<li><p>Parallel DBMSs：</p>
<ul>
<li>结点资源在物理上离得很近</li>
<li>结点资源通过高速互联进行通信</li>
<li>通信开销小并且是可靠的</li>
</ul>
</li>
<li><p>Distributed DBMSs：</p>
<ul>
<li>结点资源之间的物理位置相距远</li>
<li>结点资源通过低速互联进行通信</li>
<li>无法忽视结点之间的通信开销</li>
</ul>
</li>
</ul>
<h1 id="Process-Model"><a href="#Process-Model" class="headerlink" title="Process Model"></a>Process Model</h1><p>过程模型定义了系统将为何种架构以处理并发的请求&#x2F;查询，其中，Worker负责执行一个单独的任务并且返回结果，是DBMS中的一个组件</p>
<p>而模型的不同点就在于Worker的形式</p>
<h2 id="Process-per-Worker"><a href="#Process-per-Worker" class="headerlink" title="Process per Worker"></a>Process per Worker</h2><p>第一种形式是进程模型：给每一个Worker都分配一个进程，由OS负责调度，对于一个查询中的每一个operator，都交给一个Worker来负责执行</p>
<p>在线程的思想流行之前诞生的很多数据库都是用了这种模型</p>
<p>优点是：其中一个进程的崩溃并不会影响整个系统的崩溃</p>
<p>缺点是：极度依赖OS的调度，DBMS没有办法做到自行调度工作</p>
<h2 id="Thread-per-Worker"><a href="#Thread-per-Worker" class="headerlink" title="Thread per Worker"></a>Thread per Worker</h2><p>第二种是线程模型：以线程的形式管理每一个Worker，是如今常用的数据库并行处理模型，DBMS能够主动控制线程的调度，调度算法能够更加灵活</p>
<p>线程相对于进程的区别，即为线程模型相对于进程模型的优点和缺点——减少了进程带来的上下文切换、相比创建&#x2F;销毁一个进程，创建&#x2F;销毁一个线程的开销更小、不用管理公共内存；与此同时，一个线程的崩溃也会导致整个系统的崩溃</p>
<blockquote>
<p>关于Scheduling</p>
<p>对于每一个查询计划，DBMS都要决定执行的时间、地点和方式</p>
<p>需要考虑这个查询需要用到多少个Worker？需要用多少个CPU？这个查询需要在哪个CPU上处理？输出要保存在哪里？等等问题</p>
<p>因此DBMS知道的内容（比如上下文相关的信息）总是要比OS多一些</p>
</blockquote>
<h2 id="Embedded-DBMS"><a href="#Embedded-DBMS" class="headerlink" title="Embedded DBMS"></a>Embedded DBMS</h2><p>最后一种方式是嵌入式，DBMS与应用程序运行在同一地址空间，由应用程序来负责线程和调度（这一部分没怎么看懂）</p>
<h1 id="Inter-VS-Intra-Query-Parallelism"><a href="#Inter-VS-Intra-Query-Parallelism" class="headerlink" title="Inter- VS. Intra-Query Parallelism"></a>Inter- VS. Intra-Query Parallelism</h1><p>这里提出了两种并行化的思想的大概内容，姑且将其翻译为查询内并行性和查询间并行性</p>
<h2 id="Inter-Query"><a href="#Inter-Query" class="headerlink" title="Inter-Query"></a>Inter-Query</h2><p>查询内并行性通过允许多个查询同时进行从而提高整体性能</p>
<p>如果查询都是只读的，那么没有必要显式地协调查询与查询之间的先后，必要时，buffer pool可以处理大部分共享</p>
<p>然而如果有多个查询在同时更新数据库，那么将会很难保持正确性，这个问题会在Lecture 15讨论事务相关内容的时候提及</p>
<h2 id="Intra-Query"><a href="#Intra-Query" class="headerlink" title="Intra-Query"></a>Intra-Query</h2><p>通过并行执行运算符来提高单个查询的性能，在组织操作符的时候可以参考生产者&#x2F;消费者模型</p>
<p>每一个operator都有一个并行化的版本</p>
<p>这样可以让多个线程访问集中式的数据结构，也或者使用分区来分工合作</p>
<p>其中操作又可以被划分为横向并行和纵向并行</p>
<h3 id="Horizontal"><a href="#Horizontal" class="headerlink" title="Horizontal"></a>Horizontal</h3><p>横向并行，也可以称为操作内并行，将运算符分解为独立的片段，这些片段在不同的数据子集中执行相同的功能</p>
<p>DBMS在查询计划中插入一个exchange操作符，用来合并&#x2F;拆分多个子操作符&#x2F;父操作符的结果</p>
<p>即把一个操作分配给多个Worker，每个Worker都执行一部分，最终用exchange算子对结果进行合并</p>
<h4 id="Exchange-Operator"><a href="#Exchange-Operator" class="headerlink" title="Exchange Operator"></a>Exchange Operator</h4><p>exchange算子有三种类型：</p>
<ul>
<li><p>Gather：</p>
<p>从多个Worker处得到结果，进行合并之后作为一个单独的输出传递给上游</p>
</li>
<li><p>Distribute：</p>
<p>将一个单独的输入分裂成多个输出传递给上游</p>
</li>
<li><p>Repartition：</p>
<p>将多个输入重新分组成多个输出传递给上游</p>
</li>
</ul>
<h3 id="Vertical"><a href="#Vertical" class="headerlink" title="Vertical"></a>Vertical</h3><p>纵向并行，思想类似于CPU的流水线，在运行一个操作的同时，另一个操作也在准备运行，一旦操作1处理完了一道数据就马上发给下一个操作2，因此不会出现类似于物化模型那样一次性传递一个数组的数据的情况</p>
<h2 id="Bushy-Parallelism"><a href="#Bushy-Parallelism" class="headerlink" title="Bushy Parallelism"></a>Bushy Parallelism</h2><p>Inter和Intra-Parallelism的结合，上下游之间的不同部分都可以被划分成一个个独立的部分交给一个或几个Worker来处理</p>
<h1 id="I-x2F-O-Parallelism"><a href="#I-x2F-O-Parallelism" class="headerlink" title="I&#x2F;O Parallelism"></a>I&#x2F;O Parallelism</h1><p>前面从过程模型的角度，介绍了基于并行查询的操作并行性。这里介绍了I&#x2F;O并行，是一种更加底层的并行方式</p>
<p>对于单设备来说，I&#x2F;O始终是DBMS的瓶颈，如果能够把I&#x2F;O任务分配到多个设备中并行处理，那么就能够一定程度上突破这个瓶颈</p>
<p>相关的方法有很多，这里主要介绍了两种：Multi-Disk Parallelism和Database Partitioning</p>
<h2 id="Multi-Disk-Parallelism"><a href="#Multi-Disk-Parallelism" class="headerlink" title="Multi-Disk Parallelism"></a>Multi-Disk Parallelism</h2><p>即数据库文件分布在多个磁盘进行存储</p>
<p>多磁盘并行主要考虑三方面因素：Performance、Durability、Capacity</p>
<ul>
<li><p>如果是基于硬件实现的多磁盘并行化：</p>
<p>硬件控制器需要能够支持管理多个设备：例如现在有1～6号page，3个磁盘，那么控制器需要将page按照顺序分配给每个磁盘；或者将每一个page都复制3份到不同的磁盘上</p>
</li>
<li><p>如果是基于软件实现的多磁盘并行化：</p>
<p>需要在文件&#x2F;对象的级别上使用擦除码，相较于传统的基于硬件实现，更加高效灵活（这一部分没怎么听懂）</p>
</li>
</ul>
<p>无论基于哪种方法实现，数据交换的过程对于DBMS都是透明的</p>
<h2 id="Database-Partitioning"><a href="#Database-Partitioning" class="headerlink" title="Database Partitioning"></a>Database Partitioning</h2><p>将数据库本身拆分成多个不相交的子集，进行分布式存储，这对于应用层而言是透明的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-11/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:49:07 / 修改时间：13:00:21" itemprop="dateCreated datePublished" datetime="2024-02-28T12:49:07+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-11-Join-Algorithms"><a href="#Lecture-11-Join-Algorithms" class="headerlink" title="Lecture 11: Join Algorithms"></a>Lecture 11: Join Algorithms</h1><p>本章介绍了join算法的思想和实现</p>
<h1 id="Join-Operator"><a href="#Join-Operator" class="headerlink" title="Join Operator"></a>Join Operator</h1><ul>
<li><p>首先是join在底层是如何实现的：这里有两种方式</p>
<p>例如对于MySql语句：<code>select R.id, S.date from R join S on R.id = S.id where S.value &gt; 100</code></p>
<ul>
<li><p>Early Materialization：</p>
<p>这种方法一开始就将所有我们需要用到的具体数据都读取好放入内存，详细一点来讲就是把R.id和S.data直接作为新的tuple插入表中，这样一来，该查询的所有后续操作都不用再回到磁盘中读取数据</p>
</li>
<li><p>Late Materialization：</p>
<p>与前者相对的，滞后具象方法在一开始只会将匹配到的tuple的Record IDS放入表中，等到上层的操作需要获取数据的时候再去磁盘中拿。这种方法对于列存储的DBMS比较友好，因为最终除了我们需要的数据以外，我们不会读取到任何无关的数据</p>
</li>
</ul>
</li>
</ul>
<h1 id="Join-vs-Cross-Product"><a href="#Join-vs-Cross-Product" class="headerlink" title="Join vs. Cross-Product"></a>Join vs. Cross-Product</h1><p>这里需要进行一下连接操作与笛卡尔积之间的比较：</p>
<p>相对而言笛卡尔积是一种更加低效的方法，因为对于两张大小分别为m和n的表，一次笛卡尔积操作需要用两个for循环来遍历两张表，最终获得一张m*n大小的输出表</p>
<blockquote>
<p>例如<code>select * from s cross join e</code>就是一个笛卡尔积操作，最终输出的结果一来没有规律可言，而来耗费时间更长</p>
<p>而<code>select * from s join e on s.id = e.id</code>是一个join操作，输出结果明显会更小更快</p>
</blockquote>
<h1 id="Join-Algorithms"><a href="#Join-Algorithms" class="headerlink" title="Join Algorithms"></a>Join Algorithms</h1><h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h2><h3 id="Naive-Nested-Loop-Join"><a href="#Naive-Nested-Loop-Join" class="headerlink" title="Naive Nested Loop Join"></a>Naive Nested Loop Join</h3><ul>
<li><p>这是最简单的join算法，遍历两个表中的所有tuple，如果两两匹配，则输出</p>
</li>
<li><p>显然这是一个糟糕的算法，如果R表有M个page、m个tuple，S表有N个page、n个tuple，则对于一次join，开销将会是$$M + (m \times N)$$</p>
<blockquote>
<p>例如R有1000页，100000个tuple；S有500页，40000个tuple</p>
<p>那么做一次join的IO次数为：$$1000 + (100000 \times 500) &#x3D; 50001000$$次</p>
<p>如果一次IO要0.1ms，那么join一次就要将近1.3小时</p>
<p>即使使用大小比较小的S表作为outer loop的主体，最终也要近乎1.1小时</p>
</blockquote>
</li>
</ul>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested Loop Join"></a>Block Nested Loop Join</h3><p>朴素的循环算法没有充分利用缓冲池，由此引出了块嵌套循环</p>
<ul>
<li><p>假设我们缓冲区大小为B，则我们使用B-2个缓冲区用来装载外表（即外侧遍历的表），用一个缓冲区装载内表，最后一个缓冲区用来输出，写成伪代码如下：</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each page pR(Belong to R) <span class="keyword">in</span> <span class="built_in">range</span>(B-<span class="number">2</span>):</span><br><span class="line">	<span class="keyword">for</span> each page pS(Belong to S) <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> each <span class="built_in">tuple</span> r <span class="keyword">in</span> pR:</span><br><span class="line">		    <span class="keyword">for</span> each <span class="built_in">tuple</span> s <span class="keyword">in</span> pS:</span><br><span class="line">  		        <span class="keyword">if</span> r matches s then emit</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>这个算法的IO复杂度为$$M + \lceil M &#x2F; (B-2) \rceil \times N$$</p>
<blockquote>
<p><strong>如果外循环可以完全装入内存：</strong></p>
<p>加入一次IO要0.1ms，那么总时长只要0.15秒</p>
</blockquote>
</li>
</ul>
<h3 id="Index-Nested-Join-Loop"><a href="#Index-Nested-Join-Loop" class="headerlink" title="Index Nested Join Loop"></a>Index Nested Join Loop</h3><p>上述两种算法，性能瓶颈在于：对于外循环中的每一个tuple，都需要遍历一次内循环中的tuple来进行判断，因此我们可以使用索引进行优化</p>
<ul>
<li>具体做法为：在关系S的连接属性上建立索引，对于R中的每一个元组，根据索引找到对应的S中元组进行连接</li>
<li>假设在索引上查找的代价为C，则IO复杂度为：$$M + m \times C$$</li>
</ul>
<h2 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort-Merge Join"></a>Sort-Merge Join</h2><p>如果我们手上的两张表都是有序的，那么join工作就会简单很多；如果他们不是有序的，那就可以考虑使用上节课讲到的排序算法让他们变得有序</p>
<ul>
<li><p>具体流程如下：</p>
<ul>
<li><p>Phase #1: Sort</p>
<ul>
<li><p>对两张表以join所使用到的key作为关键字进行排序</p>
</li>
<li><p>如果内存放不下这么多page，则需要使用外部排序</p>
</li>
</ul>
</li>
<li><p>Phase #2: Merge</p>
<ul>
<li>对两张排好序的表进行配对，这样外循环的元素就不用每次都遍历一遍内循环的元素了</li>
<li>可能会需要根据join的类型进行回溯，这里具体</li>
</ul>
<blockquote>
<p>比如表R：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Andy</td>
</tr>
<tr>
<td>200</td>
<td>GZA</td>
</tr>
<tr>
<td>200</td>
<td>GZA</td>
</tr>
</tbody></table>
<p>表S：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>value</th>
<th>cdate</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>2222</td>
<td>10&#x2F;4&#x2F;2023</td>
</tr>
<tr>
<td>100</td>
<td>9999</td>
<td>10&#x2F;4&#x2F;2023</td>
</tr>
<tr>
<td>200</td>
<td>8888</td>
<td>10&#x2F;4&#x2F;2023</td>
</tr>
<tr>
<td>400</td>
<td>7777</td>
<td>10&#x2F;4&#x2F;2023</td>
</tr>
</tbody></table>
<p>当R表遍历到第二行，而S表遍历到第三行时，会输出这组tuple，S表的指针会向下移动到第四行，此时发现R表中仍然有id&#x3D;200的tuple存在，则需要进行回溯，将指针退回第三行</p>
</blockquote>
</li>
</ul>
</li>
<li><p>IO开销如下：</p>
<blockquote>
<p>Sort Cost(R) : $$2M \times (1 + \lceil log_{B-1}{\lceil M &#x2F; B \rceil} \rceil)$$</p>
<p>Sort Cost(S) : $$2N \times (1 + \lceil log_{B-1}{\lceil N &#x2F; B \rceil} \rceil)$$</p>
<p>Merge Cost : $$M + N$$</p>
<p>-&gt;Total Cost : Sort + Merge</p>
<p>例如R有1000页，100000个tuple；S有500页，40000个tuple</p>
<p>则一共需要IO次数7500次，如果每次IO需要0.1ms，则一共需要0.75s</p>
</blockquote>
</li>
<li><p>排序join算法的最坏情况为：如果两张表的所有tuple都一模一样，那么回溯的次数将会大大增加，开销会来到$$(M \times N) + (sort cost)$$</p>
</li>
</ul>
<h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><ul>
<li><p>哈希join算法也有两个阶段：</p>
<ul>
<li><p>Phase #1: Build</p>
<p>首先使用哈希函数h1扫描外层表来获取一张哈希表，其中哈希方式可以任选，只不过在实际应用中，线性探查法是效果最好的</p>
</li>
<li><p>Phase #2: Probe</p>
<p>扫描内层表并且使用哈希函数h1来跳转并且寻找匹配的tuple</p>
</li>
</ul>
</li>
</ul>
<h3 id="Hash-Table-Contents"><a href="#Hash-Table-Contents" class="headerlink" title="Hash Table Contents"></a>Hash Table Contents</h3><p>对于一张哈希表，我们不仅仅要记录哈希值，还要记录对应的key，以防发生冲突时形成错误的match</p>
<p>此外，有些DBMS还会记录下来tuple的value，这取决于其使用的策略是一开始所提到的Early Materialization 还是Later Materialization</p>
<h3 id="Optimization-Probe-Filter"><a href="#Optimization-Probe-Filter" class="headerlink" title="Optimization : Probe Filter"></a>Optimization : Probe Filter</h3><p>对于Hash Join的一种常见的优化方式是使用Bloom Filter。这是一种概率性的数据结构，存放在CPU的cache中，Bloom Filter会在创建哈希表的时候判断：这个key是否存在于内层表中，他可能会将不存在误判为存在，但不会将存在的key误判为不存在</p>
<p>这样一来，当我们想要进入哈希表进行查找的时候，我们可以首先访问一下Bloom Filter，可以加快join的速度</p>
<h3 id="Partition-Hash-Join"><a href="#Partition-Hash-Join" class="headerlink" title="Partition Hash Join"></a>Partition Hash Join</h3><ul>
<li><p>有的时候哈希表没有办法装进内存，这个时候我们可以使用聚类哈希join，大概意思就是在build之前就先对输入的relation进行分类，然后针对每一个partition进行前面提到的hash join算法</p>
</li>
<li><p>Recursive Partition: 关于这一部分其实有点没太看懂，好像是说要用两个哈希函数来对两个表分别进行递归聚类，然后看tuple是否匹配（？）</p>
</li>
<li><p>IO开销如下：</p>
<blockquote>
<p>如果我们不使用递归聚类，那么</p>
<p>Partition Phase: $$2(M+N)$$次IO</p>
<p>Probe Phase: $$M+N$$次IO</p>
</blockquote>
</li>
</ul>
<h4 id="Optimization-Hybrid-Hash-Join"><a href="#Optimization-Hybrid-Hash-Join" class="headerlink" title="Optimization : Hybrid Hash Join"></a>Optimization : Hybrid Hash Join</h4><p>如果一个表中的key是skewed的（大概意思就是这个key在这个表中非常多），那么DBMS会将这个partition视作热点分区，将其保存在内存而非写回磁盘</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-10/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:48:49 / 修改时间：13:00:10" itemprop="dateCreated datePublished" datetime="2024-02-28T12:48:49+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-10-Sorting-amp-Aggregation-Algorithms"><a href="#Lecture-10-Sorting-amp-Aggregation-Algorithms" class="headerlink" title="Lecture 10: Sorting &amp; Aggregation Algorithms"></a>Lecture 10: Sorting &amp; Aggregation Algorithms</h1><p>本章主要介绍了几种排序与聚合算法的思想</p>
<h1 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h1><p>在关系型数据库中，tuple之间并没有特定的顺序关系，因此在进行诸如group by, distinct, partition by, order by, join之类的操作时，需要对tuple进行排序<br>如果内存足够放下这些数据，那么使用qsort进行排序即可；然而内存未必能够放下这么多的tuple，因此在这种情况下需要使用external sorting，能够根据需要将排序溢出到磁盘，并且倾向于顺序I&#x2F;O</p>
<h2 id="Top-N-Heap-Sorting"><a href="#Top-N-Heap-Sorting" class="headerlink" title="Top-N Heap Sorting"></a>Top-N Heap Sorting</h2><ul>
<li>如果一个查询包含一个带有limit的order by，则DBMS只需要查找到前N个元素即可，也就是使用Top-N Heap Sort。理想情况是将前N个元素放入内存，这样DBMS只需要维护一个优先队列即可</li>
</ul>
<blockquote>
<p>例如我们有以下查询：<code>select * from enrolled order by sid fetch first 4 rows with ties</code>，我们需要输出学号前四小的学生信息，如果学号相同，则并列输出。排序方法如下：</p>
<ul>
<li>首先创建大小为4的堆</li>
<li>遍历数据，如果堆未满，则直接放入堆；否则，如果fetch指向的数据已经在堆中，则将堆的大小扩大到两倍（因为要求with ties）并且放入堆；如果该数据不在堆中，则判断是否是我们需要的数据：如果是，则将堆首的相同元素全部pop，放入堆；如果不是，则跳过该fetch</li>
</ul>
</blockquote>
<h2 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h2><h3 id="Two-way-Merge-Sort"><a href="#Two-way-Merge-Sort" class="headerlink" title="Two-way Merge Sort"></a>Two-way Merge Sort</h3><ul>
<li>最基本的两路归并排序：在排序阶段从磁盘中读取page到内存，排序结束后写回磁盘；在合并阶段，他使用三个缓冲页——从磁盘中读取两个page到其中两个frame，并且将其合并到第三个frame，每当第三个frame被填满，就会将其写回磁盘，并且替换成一个空的page。其中每一组排好序的page被称为一个run，每一次遍历称为一个pass</li>
<li>如果参与排序的page数量为N，则该算法一共进行了$$1+\lceil\log_2N\rceil$$次遍历，总IO成本为$$2N\times (pass nums)$$</li>
</ul>
<h3 id="General（K-way）-Merge-Sort"><a href="#General（K-way）-Merge-Sort" class="headerlink" title="General（K-way） Merge Sort"></a>General（K-way） Merge Sort</h3><ul>
<li><p>该算法的一般版本允许DBMS使用三个以上的缓冲页</p>
<p>B表示缓冲页总数，在排序阶段，一次可以读取B个page，并且将$$\lceil \frac{N}{B} \rceil$$个排好序的run写回磁盘；在合并阶段，可以在每个通道中合并最多B-1个runs，将结果放入最后一个缓冲页并且写回磁盘</p>
</li>
<li><p>在一般的版本中，一共需要遍历$$1 + \lceil log_{B-1} \lceil \frac{N}{B} \rceil  \rceil$$次排序，总IO开销依然是$$2N\times (pass nums)$$</p>
</li>
</ul>
<h3 id="Double-Buffering-Optimization"><a href="#Double-Buffering-Optimization" class="headerlink" title="Double Buffering Optimization"></a>Double Buffering Optimization</h3><ul>
<li>优化思想是：假设我们从原本有的4个缓冲页扩大到了8个，那么如果还是按照原本3+1的思路进行串行的归并排序和写回，就会浪费一部分的IO请求等待时间。双缓冲优化使用多线程，组成两个3+1：当第一组缓冲区正在进行归并排序的时候，第二组缓冲区已经开始从磁盘中预读取page到frame中，这样一旦第一组IO结束，即可马上开始下一组IO的运算</li>
</ul>
<h3 id="Using-B-Tree"><a href="#Using-B-Tree" class="headerlink" title="Using B+ Tree"></a>Using B+ Tree</h3><ul>
<li>对于DBMS，可以使用聚类B+索引来帮助排序，因为在B+树的叶子结点中，所有数据的存储都是有序的，IO的访问也都是顺序的，可以有效减小计算开销，这比外部归并排序要来的高效</li>
<li>反之，如果是非聚类的B+索引，那么使用它就不是一个很好的选择（因为数据不连续），几乎所有访问都要从磁盘中读取而非buffer pool</li>
</ul>
<h1 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h1><p>在执行聚合运算的时候，往往是将一个或者多个tuple的值折叠成一个标量值，例如<code>select distinct cid from enrolled where grade in (&#39;B&#39;,&#39;C) order by cid</code></p>
<p>总体来说有两种实现聚合的方法：(1)排序，(2)散列</p>
<h2 id="Sorting-1"><a href="#Sorting-1" class="headerlink" title="Sorting"></a>Sorting</h2><ul>
<li>DBMS首先根据group by语句对tuple进行排序，如果buffer pool够用，则直接使用qsort，否则使用外部归并算法。然后DBMS会对排好序的数据进行顺序扫描来计算聚合</li>
<li>在执行排序聚合，重要是要对查询操作进行排序，以效率最大化。例如：如果查询需要一个过滤器，最好先执行过滤器，然后对过滤后的数据进行排序，以减少数据量</li>
</ul>
<h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><ul>
<li><p>由于在计算聚合的时候，散列的计算成本总是要比排序低得多，所以DBMS在扫描表的时候会填充一个临时的哈希表（ephemeral hash table），对于每一条记录，都会检查哈希表中是否已经有该条目，并且进行适当的修改。如果哈希表太大，DBMS就会将其溢出到磁盘上（？）。完成这个任务有两个阶段：</p>
<ul>
<li><p>Phase #1 - Partition：</p>
<p>使用哈希函数h1，根据目标的hash key将tuple分割到不同的磁盘分区，这样所有匹配的tuple都会被分配到同一片区域，然后DBMS会通过输出缓冲区将分区溢出到磁盘上</p>
</li>
<li><p>Phase #2 - ReHash：</p>
<p>对于磁盘上的每一个分区，将其page读入内存，并且根据第二个哈希函数h2，建立一个哈希表，由此把所有匹配的tuple都聚集到一起。如果hash表太小了以至于无法容纳所有数据，那么可以考虑将当前分区重新进行分割，或者混杂其他基于排序或者基于散列的算法</p>
</li>
</ul>
</li>
<li><p>在ReHash阶段，DBMS可以将需要输出的聚合存储为（GroupByKey -&gt; RunningValue）的配对，RunningValue的内容取决于聚合函数</p>
<blockquote>
<p>例如如果我们想要输出<code>select cid, AVG(gpa) from enrolled</code>，可以将AVG存储为(COUNT,SUM)的形式</p>
</blockquote>
</li>
<li><p>而对于一个新插入的tuple</p>
<ul>
<li>如果它能够找到一个匹配的GroupByKey，则适当更新RunningValue</li>
<li>否则插入一个新的(GroupByKey -&gt; RunningValue)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-9/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 9</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:48:06 / 修改时间：13:00:12" itemprop="dateCreated datePublished" datetime="2024-02-28T12:48:06+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-9-Index-Concurrency-Control"><a href="#Lecture-9-Index-Concurrency-Control" class="headerlink" title="Lecture 9: Index Concurrency Control"></a>Lecture 9: Index Concurrency Control</h1><p>本章主要介绍了数据库中几种闩锁的概念和简单的实现（非代码）</p>
<h1 id="Locks-vs-Latches"><a href="#Locks-vs-Latches" class="headerlink" title="Locks vs. Latches"></a>Locks vs. Latches</h1><ul>
<li>lock<ol>
<li>保护当前事务的索引内容不会受到其他事务的影响</li>
<li>lock在整个事务的执行期间都会被持有</li>
<li>DBMS需要在发生冲突的时候回滚变更</li>
</ol>
</li>
<li>latch<ol>
<li>保护索引内部数据不会被其他线程影响</li>
<li>仅在线程对索引进行某个操作的时刻被持有（一般持有时间很短）</li>
<li>DBMS不需要对数据的更新进行回滚</li>
<li>latch有两种mode，分别为Read Mode和Write Mode，其中Read Mode可以同时被多个线程持有，但Write Mode不行</li>
</ol>
</li>
</ul>
<h1 id="Latch-Implementation"><a href="#Latch-Implementation" class="headerlink" title="Latch Implementation"></a>Latch Implementation</h1><h2 id="Blocking-OS-Mutex"><a href="#Blocking-OS-Mutex" class="headerlink" title="Blocking OS Mutex"></a>Blocking OS Mutex</h2><ul>
<li>依赖OS内置的互斥机制，由<strong>用户空间的自旋latch</strong>以及<strong>OS的互斥锁</strong>组成。当DBMS无法获得用户空间的latch时，会试图进入内核态并获取更加昂贵的mutex，如果还是无法获取，则会被阻塞</li>
<li>OS mutex在DBMS中不是一个好的选择，因为会被OS介入，而且开销比较大<ul>
<li>例子：std::mutex  </li>
<li>优点：使用简单</li>
<li>缺点：消耗大，不可扩展</li>
</ul>
</li>
</ul>
<h2 id="Test-and-Set-Spin-Latch-TAS"><a href="#Test-and-Set-Spin-Latch-TAS" class="headerlink" title="Test-and-Set Spin Latch(TAS)"></a>Test-and-Set Spin Latch(TAS)</h2><ul>
<li>自旋锁比mutex更有效，因为DBMS可以控制自旋锁在无法获取latch的情况下的下一步动作：比如可以继续尝试获取或者允许OS取消调度<ul>
<li>例子：std::atomic&lt;T&gt;</li>
<li>优点：上锁更高效，一个<code>std::atomic_flag latch</code>指令即可上锁</li>
<li>缺点：没有扩展性，对于cache和OS并不友好</li>
</ul>
</li>
</ul>
<h2 id="Reader-Writer-Latches"><a href="#Reader-Writer-Latches" class="headerlink" title="Reader-Writer Latches"></a>Reader-Writer Latches</h2><ul>
<li>mutex和自旋锁并不区分读写（对于数据库而言是不好的），DBMS需要一种可以支持并发读取的方法，这样如果程序有大量读取的需求就可以获得更好的效果</li>
<li>读写锁允许latch以read或者write的mode进行等待，可以跟踪有多少线程持有该latch，以及有多少线程在等待获取latch。对于read锁，我们可以定义其在任何情况下都可以获得这把latch，也可以指定其只有在等待write的线程为空的时候才能获取；对于write锁，则需要等待read锁被全部释放<ul>
<li>例子：std::shared_mutex</li>
<li>优点：能够并发读取</li>
<li>缺点：必须要额外维护两个队列：read线程和write线程以防止饥饿现象，内存开销会更大</li>
</ul>
</li>
</ul>
<h1 id="Hash-Table-Latching"><a href="#Hash-Table-Latching" class="headerlink" title="Hash Table Latching"></a>Hash Table Latching</h1><ul>
<li>由于Hash数据结构本身的特性，所有线程在访问的时候都是按照顺序自上而下的，每次也都只会访问一个slot，因此不会出现死锁现象</li>
<li>按照粒度的大小，Hash Table Latching可以被分成两种：<ul>
<li>Page Latches：每个Page都用一把大锁锁住，每个线程在访问Page之前获取一个Read或者Write锁，这样的做法会降低程序的并发性，但是由于线程访问每个slot的速度很快，因为只需要一把锁即可实现</li>
<li>Slot Latches：Page中的每个slot都有自己的锁，所以读写线程可以同时访问一个Page的不同slot，提高了并发度，但同时也增加了存储和计算开销</li>
</ul>
</li>
</ul>
<h1 id="B-Tree-Latching"><a href="#B-Tree-Latching" class="headerlink" title="B+ Tree Latching"></a>B+ Tree Latching</h1><ul>
<li>B+树的锁主要为了防止以下问题：<ul>
<li>不同线程同时修改同一个结点</li>
<li>当一个线程对结点进行插入&#x2F;删除，导致结点出现了split&#x2F;merge现象时，另一个线程正在遍历树</li>
</ul>
</li>
<li>Latch Crabbing&#x2F;Couping Protocol（锁存耦合协议）允许多个线程并发访问B+树，具体规则如下：<ul>
<li>获取父节点锁</li>
<li>获取子结点锁</li>
<li>如果子结点被认为是安全的（不会发生split、merge、再分配），则释放父节点的锁</li>
</ul>
</li>
<li>Basic Latch Crabbing Protocol<ul>
<li>Search：从根结点开始向下，获取子结点锁-&gt;释放父节点锁，重复此步骤</li>
<li>Insert&#x2F;Delete：从根结点向下按需获取x个结点的latch，一旦孩子结点被锁住了，检查是否安全，如果安全，则释放所有祖先的锁</li>
<li>释放锁的顺序在逻辑上不重要，然而在现实中越靠近根结点的锁需要更先释放，否则会造成性能的下降</li>
</ul>
</li>
<li>Better Latch Crabbing Protocol：<ul>
<li>在改进的算法中，每一个线程都会默认到达目标结点的路径是安全的，并且以不断抓去Read锁的形式来到达，最终检验是否安全。如果不安全，则停止操作，重新开始，只不过重新遍历会抓去Write锁</li>
<li>Search：与朴素的算法一致</li>
<li><strong>Insert&#x2F;Delete</strong>：跟Search一样，不断获取和释放READ latch。最后在叶子结点上设置WRITE latch。如果叶子不安全，则重来，这次用基本算法的思路</li>
</ul>
</li>
<li>Leaf Node Scan<ul>
<li>前两种算法都是自上而下的，线程无法获取更上一层的锁存器，因此不会出现死锁现象</li>
<li>然而扫描叶子结点的时候很容易出现死锁，当两个线程以相反的方向遍历到了相邻的叶子结点，就会出现死锁，而Index Latch本身并不支持死锁的检测和预防</li>
<li>因为，唯一能够解决这个问题的方式就是通过code discipline，叶子结点的兄弟结点的锁存器必须遵循“no wait”原则。B+树必须面对锁存器获取失败的情况，一般会选择终止操作，重新启动</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-6/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:45:09 / 修改时间：13:00:48" itemprop="dateCreated datePublished" datetime="2024-02-28T12:45:09+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Letcure-6-Memory-Management"><a href="#Letcure-6-Memory-Management" class="headerlink" title="Letcure 6: Memory Management"></a>Letcure 6: Memory Management</h1><p>本章主要介绍了数据库中内存管理的相关内容，主要引入了缓冲池的概念</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>DBMS的任务就是管理内存以及从磁盘写入写出数据。数据库如果希望对磁盘上的数据进行处理，则必须首先将数据移动到内存中</p>
<p>因此我们需要设计一个DBMS，满足以下几个要求：</p>
<ul>
<li>其能够处理的数据量超出内存的大小</li>
<li>最小化磁盘上执行查询所带来的低效率问题</li>
<li>使得所有的操作看起来都像是在磁盘上进行的一样</li>
</ul>
<p>这个问题可以从时间上和空间上两个方面来考虑：</p>
<ul>
<li><strong>空间上</strong>：我们需要将Page写在磁盘的哪一个部分？这是为了保证数据的空间局部性</li>
<li><strong>时间上</strong>：我们应该何时进行Page的写入写出？这是为了尽可能减少从磁盘上读取数据的停顿次数</li>
</ul>
<h1 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><ul>
<li>执行引擎在请求Page的时候会先去buffer pool查询，如果没有，则buffer pool会执行替换算法将目标Page换入其中。此时脏页会被写会磁盘，而非脏页会被直接舍弃。可以参考cache在计算机硬件中的作用</li>
<li>缓冲池是一个从磁盘上读取数据的内存区域，该内存区域被组织称一个个固定大小的页面阵列，被称为frame。每个frame保存的都是磁盘中的一个Page，因此为了方便调度，我们需要Page Table（页表）。</li>
<li>页表是一个Hash表，用来跟踪处于buffer pool中的Page，我们可以通过页表以及上面的page_id来确认此Page是否还在buffer pool中。当然页表还会记录一些元数据<ul>
<li>Dirty Flag：标志位，表示这个Page是否被改写过，这是为了保证数据持久化</li>
<li>Pin Count：正在引用或者正在访问该Page的线程的数量，如果这个meta data非零，那么我们当下就不应该将这个Page驱逐出buffer pool</li>
</ul>
</li>
</ul>
<h1 id="Lock-vs-Latch"><a href="#Lock-vs-Latch" class="headerlink" title="Lock vs. Latch"></a>Lock vs. Latch</h1><p>由于我们并不希望我们在移动Page的时候被其他线程干扰（比如修改这个Page上的数据），所以我们需要对Page进行上锁操作</p>
<p>这涉及到了数据库中Lock和Latch的一些区别：</p>
<ul>
<li>lock<ol>
<li>保护当前事务的索引内容不会受到其他事务的影响</li>
<li>lock在整个事务的执行期间都会被持有</li>
<li>DBMS需要在发生冲突的时候回滚变更</li>
</ol>
</li>
<li>latch<ol>
<li>保护索引内部数据不会被其他线程影响</li>
<li>仅在线程对索引进行某个操作的时刻被持有（一般持有时间很短）</li>
<li>DBMS不需要对数据的更新进行回滚</li>
<li>latch有两种mode，分别为Read Mode和Write Mode，其中Read Mode可以同时被多个线程持有，但Write Mode不行</li>
</ol>
</li>
</ul>
<h1 id="Page-Table-vs-Page-Directory"><a href="#Page-Table-vs-Page-Directory" class="headerlink" title="Page Table vs. Page Directory"></a>Page Table vs. Page Directory</h1><p>这里需要辨析两个概念，页表和页目录虽然看上去很像，但本质上有很大区别：</p>
<ul>
<li>Page Table：内存中的一个哈希表，并不需要持久化，即哪怕丢弃了，只需要重新建立一个就行</li>
<li>Page Directory：从page_id到数据库文件中页面位置的映射，对于页目录的所有改变都必须要记录到磁盘上，以允许DBMS在重启之后能够发现，否则会破坏数据的一致性</li>
</ul>
<h1 id="Allocation-Policies"><a href="#Allocation-Policies" class="headerlink" title="Allocation Policies"></a>Allocation Policies</h1><p>数据库中的内存是根据两个策略来分配给buffer pool的</p>
<ul>
<li>Global Policies：<br>全局策略处理DBMS应该作出的决定，以有利于正在执行的整个工作负载<br>他考虑到所有活动的事务，以找到分配内存的最佳策略</li>
<li>Local Policies：<br>本地策略作出的决定会使得单个查询或事务的执行更快<br>本地策略将框架分配给特定的事务而不考虑事务的并发行为</li>
</ul>
<h1 id="Buffer-Pool-Optimization"><a href="#Buffer-Pool-Optimization" class="headerlink" title="Buffer Pool Optimization"></a>Buffer Pool Optimization</h1><p>有许多方法可以来优化buffer pool</p>
<h2 id="Multiple-Buffer-Pool"><a href="#Multiple-Buffer-Pool" class="headerlink" title="Multiple Buffer Pool"></a>Multiple Buffer Pool</h2><p>我们可以分配多块内存区域以支持多个Buffer Pool，每个区域可以有自己的页表，并且自己一套page id和frame的映射关系，这样可以更好地运用局部策略，并且根据不同的类型来分配page的置换策略（例如index或者table data），这样也能减少访问缓存池的不同线程之间对于页表锁的争夺</p>
<p>有两种办法来将Page映射到不同的buffer pool中：</p>
<ul>
<li>Objects IDs：<br>对象ID涉及扩展记录标识(extending the record IDs)，使其具有一个对象标识符(object identifier)。然后，通过对象标识符，可以维持一个从对象到特定缓冲池的映射关系。</li>
<li>Hashing：<br>哈希也是老生常谈的方法了，不展开</li>
</ul>
<h2 id="Pre-Fetching"><a href="#Pre-Fetching" class="headerlink" title="Pre-Fetching"></a>Pre-Fetching</h2><p>DBMS也可以通过基于查询计划的预取页面来进行优化。然后，当第一组页面被处理时，第二组页面可以被预取到缓冲池中。<strong>这种方法是DBMS在连续访问许多页面时常用的</strong></p>
<h2 id="Scan-Sharing"><a href="#Scan-Sharing" class="headerlink" title="Scan Sharing"></a>Scan Sharing</h2><p>查询游标可以有效减少对于数据的访问</p>
<blockquote>
<p>Q1:select sum(val) from A<br>Q2:select avg(val) from A limit 100<br>对于以上两个查询，如果Q1在执行到一半的时候，Q2加入了进来，那么就可以将Q2定位到Q1此时的游标位置，当游标遍历结束之后，Q2再针对前面没有被查询到的数据进行访问</p>
</blockquote>
<h2 id="Buffer-Pool-Bypass"><a href="#Buffer-Pool-Bypass" class="headerlink" title="Buffer Pool Bypass"></a>Buffer Pool Bypass</h2><p>对于需要线性读取大量数据的查询操作，可以选择不将获取的页面存储在buffer pool中，可以随意丢弃</p>
<p>此外，对于中间数据（类似于join和sorting），也可以这么做</p>
<h1 id="Buffer-Replacement-Policies"><a href="#Buffer-Replacement-Policies" class="headerlink" title="Buffer Replacement Policies"></a>Buffer Replacement Policies</h1><p>buffer pool在写入新页而没有空间时，需要执行evict操作给新页腾位子<br>替换策略的目标是准确性、正确性、并发性、和元数据的开销</p>
<h2 id="Least-Recently-Used（LRU）"><a href="#Least-Recently-Used（LRU）" class="headerlink" title="Least Recently Used（LRU）"></a>Least Recently Used（LRU）</h2><p>对于缓存池中每个page维护一个时间戳，时间戳记录着每个page最后被访问的时刻。当DBMS需要驱逐（evict）一个page时，选择时间戳最早的page执行驱逐。一般来说我们可以让page按照时间戳排序（优先级队列）以减少搜索的时间。</p>
<h2 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h2><p>CLOCK策略是LRU的一个近似值，不需要每页有单独的时间戳。在CLOCK策略中，每个页面被赋予一个参考位。当一个页面被访问时，设置为1<br>为了形象地说明这一点，可以用 “时钟指针 (clock hand)”将页面组织在一个圆形的缓冲区中。在清扫时检查一个页面的位是否被设置为1，如果是，则设置为0，如果不是，则驱逐它。通过这种方式，时钟指针在驱逐之间记住了位置</p>
<h2 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h2><p>无论是LRU还是Clock，都会受到sequential flooding的影响：在进行顺序访问的时候，DBMS会不断把连续的page读入内存，但这些正在使用的page是我们最不想要的（因为我们不过是为了查找到自己想要的page，迫不得已才把之前的page读入buffer pool）<br>有三种方法可以解决LRU和Clock的缺点：</p>
<ul>
<li>LRU-K：<br>frame组成的链表被分为两个区域：young list和old list，当old list中的page被再一次访问到，则将其放入young list的头部；而新加入buffer pool的页面会被放入old list的头部<br>它跟踪最后K个引用的历史作为时间戳，并计算出后续访问的间隔。这个历史记录被用来预测一个页面下次被访问的时间</li>
<li>Localization per Query<br>DBMS跟踪每一个查询的访问情况，在每个查询的基础上选择哪些页面要被驱逐。这使得每次查询对缓冲池的污染最小化</li>
<li>Priority Hints<br>优先级提示允许事务根据查询执行过程中每个页面的上下文，告诉缓冲池页面是否重要</li>
</ul>
<h1 id="Dirty-Page"><a href="#Dirty-Page" class="headerlink" title="Dirty Page"></a>Dirty Page</h1><p>DBMS有两种办法来处理有脏位的页面：</p>
<ul>
<li>Fast Path：直接丢弃掉buffer pool中任何非脏页</li>
<li>Slow Path：将脏页写回磁盘</li>
</ul>
<p>避免不必要的页面写回的方法是<strong>后台写入</strong><br>通过后台写入，DBMS可以周期性地通过页表来写回脏页到磁盘上<br>当一个脏页被后台写入，DBMS可以要么将这个page驱逐出去，或者保持其在buffer pool中的位置但是重置其dirty flag</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/28/CMU15-445-2022Fall-Lecture-3-4-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/CMU15-445-2022Fall-Lecture-3-4-5/" class="post-title-link" itemprop="url">CMU15-445 2022Fall Lecture 3.4.5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-28 12:44:50 / 修改时间：12:59:22" itemprop="dateCreated datePublished" datetime="2024-02-28T12:44:50+08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lecture-3-4-5-Database-Storage-amp-Storage-Model"><a href="#Lecture-3-4-5-Database-Storage-amp-Storage-Model" class="headerlink" title="Lecture 3,4,5: Database Storage &amp; Storage Model"></a>Lecture 3,4,5: Database Storage &amp; Storage Model</h1><p>本章主要介绍了数据库的存储方式以及几种常见的存储模型</p>
<h1 id="Disk-Oriented-DBMS"><a href="#Disk-Oriented-DBMS" class="headerlink" title="Disk_Oriented DBMS"></a>Disk_Oriented DBMS</h1><ul>
<li>数据库保存在磁盘上，按照页（page）作为单元进行划分，第一页为目录页，如果想要对数据库进行操作，则首先需要将数据库中的page调度到内存中<ul>
<li>通过一个保存在内存中的缓冲池（buffer pool）来管理数据在磁盘和内存之间的移动</li>
<li>DBMS有一个负责查询的执行引擎，缓冲池将page带入内存，并且给执行引擎返回一个指向该page的指针，以确保在执行引擎在对该page进行操作的时候，此page的确存在于该位置</li>
</ul>
</li>
</ul>
<h1 id="DBMS-vs-OS"><a href="#DBMS-vs-OS" class="headerlink" title="DBMS vs OS"></a>DBMS vs OS</h1><p>DBMS的一个高级设计目标就是：创造一个容量远大于内存的数据库，与此同时并不希望过于频繁地访问数据库，因为访问磁盘的代价很大<br>这就类似于操作系统中的虚拟内存，保证磁盘中的地址空间能够映射到内存中<br>提起磁盘和内存之间数据的迁移，很容易想起mmap，的确曾经有很多DBMS选择使用mmap来执行，然而实际上是会造成一些问题的</p>
<ol>
<li>DBMS并不知道哪些page在内存中，而mmap在遇到page fault时会阻塞进程</li>
<li>OS可以在任何时刻写回脏页，然而OS并不知道哪些page需要在其他page之前写回磁盘，这会造成并发控制方面出现问题<br>尽管有办法解决这方面的问题，但是从性能和安全性两方面考虑，并不建议由操作系统来完成这一任务<br>因此根据Andy所言，由DBMS自己来实现数据的控制是一个更好的选择</li>
</ol>
<h1 id="DataBase-Storage"><a href="#DataBase-Storage" class="headerlink" title="DataBase Storage"></a>DataBase Storage</h1><h2 id="File-Storage"><a href="#File-Storage" class="headerlink" title="File Storage"></a>File Storage</h2><p>DBMS使用自己独有的编码形式将数据库作为单个文件或者多层次文件保存在磁盘中，OS对此一无所知<br>DBMS的存储管理器负责管理数据库的文件，它会将这些文件作为一个page的集合，并且追踪哪些数据被读写、这些page有多少可用空间</p>
<h2 id="DataBase-Page"><a href="#DataBase-Page" class="headerlink" title="DataBase Page"></a>DataBase Page</h2><p>DBMS将数据库文件中固定大小的数据块称为页（page），可以参考OS中的虚拟内存，页面可以包含不同的数据结构（tuple、indexes、log等）<br>在大多数DBMS中，一个page会被要求只能存储一种类型的数据</p>
<blockquote>
<p>例如page1只能存储tuple，page2只能存储日志<br>所以，每个page都会被赋予⼀个唯⼀的内部标识符，系统会生成属于page的ID。之后，就会有一个indirection层。indirection层允许将⼀个page ID映射到某个物理位置，即某个文件中的某个位置（类似于一个字典映射，其实就是记录⼀个相对位置，方便文件整体移动后，只要知道整体文件的初始位置，我依然可以通过该相对位置（即page ID）找到某个文件某个位置的数据所对应的page）。这样的话，就可以支持磁盘的压缩或者使用另一块磁盘而不改变page ID。</p>
</blockquote>
<h2 id="DataBase-Heap"><a href="#DataBase-Heap" class="headerlink" title="DataBase Heap"></a>DataBase Heap</h2><p>关于page之间是如何进行存储的——<br>堆文件组织是是一个无序的页面集合，是从磁盘上查找我们想要的page地址的一种方法<br>DBMS可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面ID：</p>
<blockquote>
<ol>
<li>Linked List：<br>是一种顺序存储（顺序存储并不意味着有序），这是一种很容易想到的存储方式，然而弊端也是显然的：链表的查询时间复杂度为O（n），效率远不及hash</li>
<li>Page Directory：<br>可以类比书的目录，每次查询只需要从page directory中获取目标page的偏移量即可，然而弊端在于：必须时刻保证目录与实际page信息的同步。如果往某个page中写入数据，此时page满了，但系统也崩溃了，那么目录中的信息是相对滞后的，在重启系统之后需要有对应策略来重新扫描以维护信息的一致性；如果数据量很大，在极端条件下可能始终无法统一</li>
</ol>
</blockquote>
<h2 id="Page-Layout"><a href="#Page-Layout" class="headerlink" title="Page Layout"></a>Page Layout</h2><p>关于page中的信息是如何存放的——<br>每一个page都有一个页头（header）来存放该page的，譬如页面大小、DBMS版本号之类的相关信息，这些信息被称为元数据（meta data）<br>一般来说数据在page中有2种常见的存储方式：tuple-oriented和log-structured</p>
<ol>
<li>tuple storage<br>一种朴素的思想就是将tuple以数组的方式存放，同时header记录page的信息，但这是一个strawman idea：因为当我们删除其中的一个tuple时，会产生内部碎片，导致文件的不连续；如果tuple的长度是不定长的话，这个问题会更加显著。同时tuple的查找也只能够顺序遍历，所以并不推荐</li>
<li>slotted storage<br>page中除了header以外还有两种数据结构，一种是slot，一种是tuple<br>其中slot从header之后顺序存储，每个slot都保存了对应的tuple在该page中的偏移量；而tuple本身是从page的末尾开始从后往前循序存储。虽然必然会出现一定的内部碎片，然而这是为了处理变长tuple不得不做出的牺牲，当然有些数据库支持对于内部碎片的再整理<br>对于slotted storage，一个tuple的查询需要其所在的page_id和slot_id</li>
<li>log-structured storage<br>slotted storage依然有很多问题没有能够解决：例如删除tuple的时候会留下空隙、必须从磁盘中读取整个page来获取其中的一个tuple、随机读取的效率很低<br>由此诞生了log-structured storage，这是一种只允许创建新数据而不允许覆盖已有数据的存储方式，DBMS中只会存放日志记录<ul>
<li>将数据库如何被修改的记录存储到文件中（放入和删除）。每条日志包含tuples的唯一标识符</li>
<li>要读取一条记录，DBMS会从最新的到最旧的逆向扫描日志文件，并 “重新创建 “这个 tuple。</li>
<li>写的快，读的可能慢。磁盘写入是连续的，现有的页面是不可改变的，这导致了随机磁盘I&#x2F;O的减少。</li>
<li>在append-only的存储上工作得很好，因为DBMS不能回溯并更新数据。</li>
<li>为了避免长时间的读取，DBMS可以有索引来允许它跳到日志中的特定位置。它还可以定期地压缩日志。（如果它有一个tuple，然后对其进行了更新，它可以将其压缩到只插入更新的tuple）</li>
<li>由于不再需要时间信息，数据库可以将日志压缩到一个按id排序的表中。这些被称为分类字符串表（SSTables），它们可以使tuple搜索非常快。</li>
<li>紧凑化的问题是，DBMS最终会出现写入放大的情况。（它一次又一次地重写相同的数据）</li>
</ul>
</li>
</ol>
<h2 id="Tuple-Layout"><a href="#Tuple-Layout" class="headerlink" title="Tuple Layout"></a>Tuple Layout</h2><p>关于tuple的具体结构——<br>其实通过sql的创建table的句式就可以观察出来，tuple本质上是一个字节的序列，DBMS的工作就是将字节的序列翻译成不同的属性和值</p>
<ul>
<li>Tuple Header：包含了tuple的元数据<ul>
<li>DBMS的并发控制协议的可见性信息。关于哪个事务创建&#x2F;修改了该元组</li>
<li>NULL值的位图</li>
</ul>
</li>
<li>Tuple Data：数据的实际属性<ul>
<li>属性通常按照你创建表时指定的顺序存储</li>
<li>大多数DBMS不允许一个tuple超过一个页面的大小</li>
</ul>
</li>
<li>Unique Identifier<ul>
<li>数据库中的每个tuple都被分配一个唯一的标识符</li>
<li>一般是：page_id + （offset or slow）</li>
</ul>
</li>
</ul>
<h1 id="Storage-Model"><a href="#Storage-Model" class="headerlink" title="Storage Model"></a>Storage Model</h1><p>数据库并没有规定应该按照哪一种模型来保存数据，然而在实际操作中，storage model的影响是很大的</p>
<h2 id="OLTP（On-line-Transaction-Processing）"><a href="#OLTP（On-line-Transaction-Processing）" class="headerlink" title="OLTP（On-line Transaction Processing）"></a>OLTP（On-line Transaction Processing）</h2><p>意思是从外界拿到数据后，只会将其放入数据库中进行简单的查询或者更新，一个具体的例子就是网购的购物车，将购物车中的东西删除、或者新增东西到购物车里，tuple的改变是很小的</p>
<h2 id="OLAP（On-line-Analytical-Processing）"><a href="#OLAP（On-line-Analytical-Processing）" class="headerlink" title="OLAP（On-line Analytical Processing）"></a>OLAP（On-line Analytical Processing）</h2><p>从数据库中的到数据后不会修改原有的数据，而是希望能够从数据中挖掘出更加深入的信息，例如数据挖掘、数据分析之类的工作，某种意义上OLAP是只读的，并且join的操作很多</p>
<p>以上两种不同的数据库使用方式就导致诞生了各种数据的存储模型：</p>
<ol>
<li>N-ary Storage Model（NSM）<br>简单来说就是一个tuple会保存表中的所有属性，例如（姓名，性别，生日，年龄）作为一个tuple<br>这是一种典型的row storage，并且利好OLTP：因为内容都是顺序排列的，存储粒度足够小，我们可以只关心自己想要的数据<br>但是对于OLAP而言，NSM是灾难性的，显然我们的查询会涉及到很多我们并不想要的数据</li>
<li>Decomposition Storage Model（DSM）<br>这是一种典型的列存储模型，他将每一个tuple按照属性进行拆分存储，例如姓名作为一个tuple，性别作为第二个tuple……<br>对于列存储而言，每次查询可以只读取某几个属性的值，这对于OLAP是有利的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/14/%E5%8F%9B%E9%80%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/14/%E5%8F%9B%E9%80%86/" class="post-title-link" itemprop="url">叛逆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-14 00:08:30" itemprop="dateCreated datePublished" datetime="2024-01-14T00:08:30+08:00">2024-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-28 13:00:43" itemprop="dateModified" datetime="2024-02-28T13:00:43+08:00">2024-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">碎碎念</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>“你的叛逆期似乎比其他的小孩来得更晚一些，我不知道这是好是坏”</p>
<p>在某一次与父亲的饭间闲聊产生了激烈的观念冲突后，他对我如是说道。</p>
<p>我知道他口中的“叛逆期”并不针对他们，应该说，即使真的针对他们，他们也只认为是我成长途中自我意识的觉醒，不以为然，更不至于为我感到担忧——我听得出来，我也心知肚明，我所叛逆的对象要比“父母”庞大的多，也难相处的多</p>
<p>自从升入大三，我便开始经常翘课，并不是因为我贪图玩乐，而是因为我认为“没必要”：既然这个老师上课不讲课，那我不如找资料自学，既然我要自学，那我也没必要去他的课堂。同样的，既然我不想卷绩点，那么平时的实验也就没必要做到完美，差不多糊弄糊弄拿个平时分就足够。每当母亲唠叨期末考试的结果，我都嗤之以鼻——因为对我来说，这东西无论是高是低，最终脑回路导向的结果都是“没必要”的</p>
<p>上述所说的讲课跑火车的老师也好，比夏天吸血的雌蚊子的存在更不合理的教学大纲也好，都是客观上存在的事实，直到现在我依然觉得自己的做法是有理可据的，是在特定环境下作出的自救行为。事实上翘课的那段时间我也的确没有荒废，拿来学自己想学的东西，相信着自己能够全凭自己一步步向自己所期望的目标挪动，却又始终放不下我所认为的“没必要”的学校的教学课程</p>
<p>我为自己想要实践却饱受阻挠的生活而痛苦，为身不由己无法从已经被预先定死的框架中彻底脱身而烦恼</p>
<p>所以我选择了最辛苦的方式：鱼和熊掌我全都要，毕竟再怎么说，至少我不想挂科</p>
<p>这就是我的叛逆，认为被形式束缚住的生活是错误的，认为向不合理的事情妥协应当是被禁止的，激进到想要对所有对我指手画脚的人漏出獠牙，推翻循规蹈矩愚昧至极的一切</p>
<p>即使无法甩开像臭虫一般令人讨厌的条条框框也无所谓，幻想着只要我足够强大，就能建立属于自己的秩序，做自己的独裁者</p>
<p>超级幼稚超级天真超级不切实际</p>
<p>人在年轻的时候总是一股冲劲蛮不讲理，从脚心诞生的一瞬间就开始野蛮生长，来不及等待中枢神经的控制就能直上脑门，用殉道者的姿态看待自己，用自毁心态丈量世界，觉得自己总是对的，藏在丹田里的小宇宙总有一天能改变这个垃圾一样的世界</p>
<p>用自己为是的眼光看待周遭而不听劝阻，就叫叛逆</p>
<p>当然叛逆期总会结束的</p>
<p>当我真的用了两个学期的时间去尝试兼顾自己想要的生活和当下的规矩，终于发现，似乎处理得没有想象中那么得心应手，我依然在煎熬，只不过原因从平时作业的拖累这一条，又加上了自己缓慢的学习进度以及对未来愈发强烈的迷茫</p>
<p>我从来不怀疑自己的努力，我只是终于开始怀疑自己的叛逆——赌气一般的行为，是否真的给自己带来了什么东西？取舍之间，结果的确匹配得了长久以来的预期吗？</p>
<p>叛逆期在人生的这个阶段到来，究竟是好是坏，我不知道，父亲不知道，谁都不知道</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/14/%E8%BF%BD%E6%82%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/NiJiKa.GIF">
      <meta itemprop="name" content="愚者大人的铁质卷烟盒">
      <meta itemprop="description" content="琐碎和思考的堆放处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CigaCase">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/14/%E8%BF%BD%E6%82%BC/" class="post-title-link" itemprop="url">追悼</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-14 21:53:07" itemprop="dateCreated datePublished" datetime="2023-11-14T21:53:07+08:00">2023-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-15 01:17:16" itemprop="dateModified" datetime="2023-11-15T01:17:16+08:00">2023-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>灵堂的大小比想象中更小，黑白色调的压迫感让人喘不过气，抽泣声比哀乐更抢先一步涌入耳蜗，枯萎的浅黄菊花是一片黑色孝布中唯一显眼的色彩<br>死者是娘家的某位亲戚，在生死线上挣扎了许久之后撒手人寰，他是家里的老幺，众兄弟姐妹没有想到亲生弟弟会由自己亲手送走<br>沉默、低语、泪水，身处如此环境之中，很难催生出悲伤以外的情绪</p>
<p>自我出生以来，身边的绝大部分至亲，不说身体健康，顶多也只是小病不断大病没有的程度，所以说来惭愧，我深知自己的这种想法有些猎奇甚至十分冒犯，但我在追悼会开始之前的确是有些兴奋——这是我人生中第一次参加追悼会，第一次亲眼见到逝者</p>
<p>仪式流程就和普通的追悼会一样：奏哀乐，念悼词，绕场一周告别遗体<br>受到众人情绪的感染，很难不鼻尖泛酸，眼眶微红，但也仅限于此。我并非铁石心肠，恰恰相反是一个很情绪化的人，只不过今天我尽量让自己仿佛置身事外，不参与其中<br>我也的确做的不错——逝者的仪容、盖住遗体的鲜花、棺材里他最喜欢戴的帽子、沉默的人、流泪的人、情绪激动的人、号啕大哭的人，我都一一看过，记在了这里</p>
<p>终于到了最后的时刻，侍者慢慢合上棺材盖，渲染着悲伤氛围的分贝达到了顶峰</p>
<blockquote>
<p>“他还那么年轻……”——有人已经无法控制自己的声带<br>“让我再看他最后一眼”——有人歇斯底里抓着棺材板<br>“我们就送你到这里了……”——有人嘶哑着念叨着告别的言语</p>
</blockquote>
<p>逝者的儿子接过不知从哪里递过来的锤子和四个钉子<br>一下<br>一下<br>一下<br>一下<br>……<br>敲打铁钉的声音盖过人群的哽咽，抹消光线再一次照进棺材的机会，以及生者再次见到他的机会</p>
<p>至此，结束</p>
<p>尽管我一再憋住悲伤，努力当一个无情的摄像机，但我似乎高估了自己的心理防线<br>之前也提过，我是一个情绪化的人，这里又不得不再加一句：<br>我是一个很傲慢的人<br>我天真地以为，在网络上看过这么多的生离死别之后，自己多多少少会有所防备<br>所以不曾设想过，自己不切实际的傲慢在现实的冲击之下会有多么脆弱</p>
<p>在钉棺材板的时候，我的情绪管理就已经小小地失控了，恐惧教唆着泪水逃出眼眶，前赴后继<br>在将来某个必将到来的时间，我也会拿起锤子，敲下钉子，亲手埋葬我最重视的人<br>我在害怕，害怕父母的死去，害怕重要之人的离开<br>那会是多久之后？二十年？十年？几个月？几周？还是明天？没有人能够保证<br>在那一天到来之前，我会变得足够坚强吗？坚强到能够坦然接受他们的离开，坚强到能够不在敲下钉子的时候因悲伤而脱力？<br>我会变得足够优秀吗？优秀到让他们不用担心自己的后事，优秀到能够不留遗憾地送别他们？<br>我要送别多少人，体验多少次今天体验过的恐惧，才能不再恐惧呢？<br>到时候我会没有出息地说出诸如“对不起，要是再多点时间就好了”之类的话吗？<br>我把死亡想得太过温柔，把离别想得太过轻松，以至于忽略了它们将伴随我的一生<br>在敲击声不断的督促下我终于明白：</p>
<blockquote>
<p>关于死亡，关于离别，我尚且什么都不明白，而在我什么都没有准备好的时候，丧钟已经悄悄响起</p>
</blockquote>
<p>快点长大吧，趁着一切为时未晚</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="愚者大人的铁质卷烟盒"
      src="/images/NiJiKa.GIF">
  <p class="site-author-name" itemprop="name">愚者大人的铁质卷烟盒</p>
  <div class="site-description" itemprop="description">琐碎和思考的堆放处</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jinziguan123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jinziguan123" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18917950960@163.com" title="E-Mail → mailto:18917950960@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">愚者大人的铁质卷烟盒</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
